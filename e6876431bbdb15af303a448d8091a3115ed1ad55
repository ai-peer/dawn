{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "05129edf_25f9cc8d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-22T13:57:09Z",
      "side": 1,
      "message": " I think this can be abandoned.",
      "revId": "e6876431bbdb15af303a448d8091a3115ed1ad55",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff1675ec_f1d37526",
        "filename": "src/dawn_native/TaskManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-14T06:36:08Z",
      "side": 1,
      "message": "Hi Austin,\n\nWhen I was working on this proposal, I found the following two issues, which should both be handled carefully in the multi-threading environment:\n\nmPendingTasks.find() may return mPendingTasks.end() as\n1. It may be executed before mPendingTasks.emplace() (always called in main thread).\n- It is easy to be handled as we can just move [1] before PostWorkerTask().\n2. It may be executed after the call of WaitForTasks() (always called in main thread), where all the items in mPendingTasks are moved out.\n- Maybe we can make WaitForTasks() to be simply { while(HasPendingTasks());}?\n- This may introduce another lock to protect mPendingTasks, which may add more complexity and performance loss. Note that in my previous method (only delete waitableEvent in Device.tick()) we can avoid using this lock.\n\nWhat do you think?",
      "range": {
        "startLine": 45,
        "startChar": 24,
        "endLine": 45,
        "endChar": 69
      },
      "revId": "e6876431bbdb15af303a448d8091a3115ed1ad55",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "465167be_ffacc73a",
        "filename": "src/dawn_native/TaskManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-14T06:38:03Z",
      "side": 1,
      "message": "Sorry point (2) should be:\n\nIt may be executed after \"tasks \u003d std::move(mPendingTasks)\" in the call of WaitForTasks() (always called in main thread), where all the items in mPendingTasks have been moved out.",
      "parentUuid": "ff1675ec_f1d37526",
      "range": {
        "startLine": 45,
        "startChar": 24,
        "endLine": 45,
        "endChar": 69
      },
      "revId": "e6876431bbdb15af303a448d8091a3115ed1ad55",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f841e16_0ca2a076",
        "filename": "src/dawn_native/TaskManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-17T01:01:24Z",
      "side": 1,
      "message": "I have another concern about allowing waitableEvent to be deleted inside the async function - we should be careful to call its member functions in the main thread because it may become invalid if we forget it may be deleted inside the async function.",
      "parentUuid": "465167be_ffacc73a",
      "range": {
        "startLine": 45,
        "startChar": 24,
        "endLine": 45,
        "endChar": 69
      },
      "revId": "e6876431bbdb15af303a448d8091a3115ed1ad55",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e9d7952_cf2a6b81",
        "filename": "src/dawn_native/TaskManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-17T02:09:33Z",
      "side": 1,
      "message": "Oh today I realized I can implement WaitForTasks() with std::condition_variable instead of  { while(HasPendingTasks());}, please ignore my previous comment.",
      "parentUuid": "2f841e16_0ca2a076",
      "range": {
        "startLine": 45,
        "startChar": 24,
        "endLine": 45,
        "endChar": 69
      },
      "revId": "e6876431bbdb15af303a448d8091a3115ed1ad55",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3823cbab_b5b8030b",
        "filename": "src/dawn_native/TaskManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-14T06:36:08Z",
      "side": 1,
      "message": "[1]",
      "range": {
        "startLine": 51,
        "startChar": 0,
        "endLine": 54,
        "endChar": 9
      },
      "revId": "e6876431bbdb15af303a448d8091a3115ed1ad55",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1559f9b_f6563042",
        "filename": "src/dawn_native/TaskManager.h",
        "patchSetId": 1
      },
      "lineNbr": 57,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-12T23:34:56Z",
      "side": 1,
      "message": "note: we could probably actually completely remove this by using a condition variable.",
      "range": {
        "startLine": 57,
        "startChar": 8,
        "endLine": 57,
        "endChar": 59
      },
      "revId": "e6876431bbdb15af303a448d8091a3115ed1ad55",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}