{
  "comments": [
    {
      "key": {
        "uuid": "f8d93f06_b7aac960",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2020-08-21T11:28:46Z",
      "side": 1,
      "message": "The failure is not related to this patch and will be skipped once https://dawn-review.googlesource.com/c/dawn/+/26960 is merged. PTAL, thanks!",
      "revId": "67905866c589e6ce7e44d1710eb19d5bed9c655c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8a91e503_48479126",
        "filename": "src/dawn_native/d3d12/BufferD3D12.cpp",
        "patchSetId": 5
      },
      "lineNbr": 415,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-08-21T17:42:50Z",
      "side": 1,
      "message": "Hm, so for buffers in the READBACK heap, this will memset the CPU-side virtual mapping. However, will that actually change the GPU buffer contents? That is, is it possible for:\n\nbuffer \u003d CreateBuffer();\nvoid* ptr \u003d buffer.Map(Read); // data in ptr is cleared, and state is marked as initialized.\nbuffer.Unmap();\n\nptr \u003d buffer.Map(Read); // data in ptr is uninitialized ??\n\nI think we should be able to test a case like this with the NonzeroClearResourcesOnCreationForTesting toggle.",
      "range": {
        "startLine": 406,
        "startChar": 12,
        "endLine": 415,
        "endChar": 13
      },
      "revId": "67905866c589e6ce7e44d1710eb19d5bed9c655c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9331556_5dae3b2c",
        "filename": "src/tests/end2end/BufferTests.cpp",
        "patchSetId": 5
      },
      "lineNbr": 473,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2020-08-24T01:00:32Z",
      "side": 1,
      "message": "[1]",
      "range": {
        "startLine": 473,
        "startChar": 8,
        "endLine": 473,
        "endChar": 65
      },
      "revId": "67905866c589e6ce7e44d1710eb19d5bed9c655c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a77cf4d_c630bc92",
        "filename": "src/tests/end2end/BufferTests.cpp",
        "patchSetId": 5
      },
      "lineNbr": 495,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2020-08-24T01:00:32Z",
      "side": 1,
      "message": "Hi Corentin and Austin, sorry that I still have some problems with this test. In this test, do we want to first create a buffer with MapRead and CopyDst usage, and upload the data myData into the buffer from the CPU side at [1]? In fact now myData won\u0027t be uploaded to the GPU side on D3D12 because the buffer is created at the Readback heap, so when we enable the buffer lazy initialization, on D3D12 the logic will be:\n1. create a buffer on the Readback heap\n2. clear the buffer to 0 on the GPU side\n3. call memcpy to write myData to the mapped pointer at the CPU side\n4. unmap the buffer\n5. re-map the buffer and check the content in the buffer. The content of the buffer should not be myData but all 0 because actually we cannot upload myData to the GPU side on D3D12.\n\nOn Metal and Vulkan it\u0027s OK because now the mapped pointer on those backends are both readable and writable on the CPU side.",
      "range": {
        "startLine": 489,
        "startChar": 0,
        "endLine": 495,
        "endChar": 24
      },
      "revId": "67905866c589e6ce7e44d1710eb19d5bed9c655c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb4b505e_4114985a",
        "filename": "src/tests/end2end/BufferTests.cpp",
        "patchSetId": 5
      },
      "lineNbr": 495,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-08-25T16:14:25Z",
      "side": 1,
      "message": "so for MapRead buffers created with mappedAtCreation \u003d\u003d true, it seems like the initial mapping created on creation has to be a mapping of a different buffer in the upload heap. On Unmap(), we copy the buffer into the MapRead buffer. Would that resolve the issue?",
      "parentUuid": "3a77cf4d_c630bc92",
      "range": {
        "startLine": 489,
        "startChar": 0,
        "endLine": 495,
        "endChar": 24
      },
      "revId": "67905866c589e6ce7e44d1710eb19d5bed9c655c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac331eff_b5d4caae",
        "filename": "src/tests/end2end/BufferTests.cpp",
        "patchSetId": 5
      },
      "lineNbr": 495,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2020-08-26T00:09:30Z",
      "side": 1,
      "message": "Yes and thanks Corentin to explain it for me.\n\nBut now I don\u0027t see the staging buffer is created and used when I try to create a D3D12 buffer with MapRead and mappedAtCreation?  Here the staging buffer won\u0027t be created if the backend of IsMappableAtCreation() return true: https://source.chromium.org/chromium/chromium/src/+/master:third_party/dawn/src/dawn_native/Buffer.cpp;l\u003d176. And on D3D12 IsMappableAtCreation() return true if the buffer is created with MapRead: https://source.chromium.org/chromium/chromium/src/+/master:third_party/dawn/src/dawn_native/d3d12/BufferD3D12.cpp;l\u003d254.\n\nSo at Buffer::Unmap() the CopyFromStagingBuffer() won\u0027t be executed because the staging buffer is empty: https://source.chromium.org/chromium/chromium/src/+/master:third_party/dawn/src/dawn_native/Buffer.cpp;l\u003d346\n\nI think it a bug on D3D12 and this patch will not be needed after the fix and https://dawn-review.googlesource.com/c/dawn/+/27220.",
      "parentUuid": "eb4b505e_4114985a",
      "range": {
        "startLine": 489,
        "startChar": 0,
        "endLine": 495,
        "endChar": 24
      },
      "revId": "67905866c589e6ce7e44d1710eb19d5bed9c655c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}