{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b7b0081d_46f29f07",
        "filename": "src/tests/end2end/CopyTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 850,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-01T06:13:20Z",
      "side": 1,
      "message": "Per my understanding, if we define rowsPerImage, we should have at least that many rows in buffer (include padding). It is similar to bytesPerRow: if we define bytesPerRow, the buffer\u0027s length should have that many bytes (including padding) if it has only one single row. Although bytesPerRow is more meaningful for a 2D texture whose height \u003e\u003d 2 and rowsPerImage is for a 2DArray or 3D texture whose depthOrArrayLayers \u003e\u003d2, but it still take effect when height is 1 and depthOrArrayLayers is 1 respectively. \n\nIf you set bytesPerRow to 256 with one single row like bufferSpec \u003d MinumumBufferSpec(2, 1), and don\u0027t increase the bufferSize to 256 bytes, I guess it will fail too. I mean, if we set bufferSpec.size \u003d bufferSpec.size * 2 + offset, it will be correct. So, this problem is caused by the test itself. \n\nWDYT?",
      "revId": "4244c45a2634c13cce8c36fb62272895e708641a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "293cdf10_f12d7711",
        "filename": "src/tests/end2end/CopyTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 850,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-01T06:47:12Z",
      "side": 1,
      "message": "I verified the test I just proposed, it would fail too if you set bytesPerRow (say 512) to a bigger one than the bytesPerRow indicated by copySize (say 256). \n\nThe problem is that when we allocate buffer size in CopyTests.cpp, we don\u0027t calculate buffer size according to copySize, we don\u0027t respect bufferSpec\u0027s bytesPerRow and rowsPerImage. I feel like this problem is caused by the test code itself. I will submit a CL to fix it.",
      "parentUuid": "b7b0081d_46f29f07",
      "revId": "4244c45a2634c13cce8c36fb62272895e708641a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b5974f3_1008e6b8",
        "filename": "src/tests/end2end/CopyTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 850,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-01T18:35:32Z",
      "side": 1,
      "message": "I misunderstood this issue. After more investigation and carefully read WebGPU spec, I realized that rowsPerImage should not take effect if there is only one depth/array slice in copy size. Likewise, bytesPerRow should not take effect if there is only one row in copy size. See https://gpuweb.github.io/gpuweb/#dictdef-gpuimagedatalayout, these two arguments are required only when there are multiple slices/rows. \n\nI borrowed your test and fixed the issue in https://dawn-review.googlesource.com/c/dawn/+/52680. \n\nI said that bytesPerImage will fail too because I didn\u0027t change copySize.height to 1. If I change copy\u0027s row number to 1, then bytesPerImage will not take effect and it can pass in current implementation. So the problem only happens for rowsPerImage.",
      "parentUuid": "293cdf10_f12d7711",
      "revId": "4244c45a2634c13cce8c36fb62272895e708641a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}