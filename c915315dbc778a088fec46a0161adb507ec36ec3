{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7cc13030_f29ed552",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-06-08T18:32:04Z",
      "side": 1,
      "message": "PTAL!",
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d6c81b9c_256b3114",
        "filename": "generator/templates/dawn/wire/client/ApiProcs.cpp",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-08T21:39:27Z",
      "side": 1,
      "message": "Hmm, not sure if it\u0027s worth it (or work), but I think we could avoid having to pass the type if we add generated templates that map the types in the ObjectAllocators to the enums. Then in the ObjectAllocator header, we could use those templates to get the type? See [1] for where I imagine this would be.",
      "range": {
        "startLine": 63,
        "startChar": 24,
        "endLine": 63,
        "endChar": 129
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df637638_d01b2ed0",
        "filename": "generator/templates/dawn/wire/client/ApiProcs.cpp",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-08T21:44:17Z",
      "side": 1,
      "message": "Ah, maybe ignore this suggestion actually... I think this would require changing all the ctors for the derived types to take the type enum also so probably doesn\u0027t accomplish much.",
      "parentUuid": "d6c81b9c_256b3114",
      "range": {
        "startLine": 63,
        "startChar": 24,
        "endLine": 63,
        "endChar": 129
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1a6669a_dbbb7b05",
        "filename": "generator/templates/dawn/wire/client/ApiProcs.cpp",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-08T21:47:41Z",
      "side": 1,
      "message": "Alternatively, would it not be possible to take the Client as an explicit argument before the rest of the forwarded args? (And then pass it to the make unique call like you do for the id?)",
      "parentUuid": "df637638_d01b2ed0",
      "range": {
        "startLine": 63,
        "startChar": 24,
        "endLine": 63,
        "endChar": 129
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4a3a15d_42a650d2",
        "filename": "generator/templates/dawn/wire/client/ApiProcs.cpp",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-08T22:08:16Z",
      "side": 1,
      "message": "Ah... please ignore all the other comments and sorry about the noise lol... I\u0027m just confusing myself...\n\nI think in order to accomplish removing this explicit `type` argument, moving some of the Client functions/members (i.e. TrackObject and mObjects) into the autogen-ed ClientBase and, passing the ClientBase to the ctor of the ObjectAllocators would be the most reasonable. Then we could call the TrackObject in the New calls and still make it so that the New calls look like the ctors. (This assumes my understanding that ClientBase isn\u0027t used for anything else and is just to separate some auto-gen vs manually written code.)\n\nAgain sorry for all the noise... haha",
      "parentUuid": "b1a6669a_dbbb7b05",
      "range": {
        "startLine": 63,
        "startChar": 24,
        "endLine": 63,
        "endChar": 129
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "feb27649_ec46c061",
        "filename": "generator/templates/dawn/wire/client/ApiProcs.cpp",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-06-09T16:14:08Z",
      "side": 1,
      "message": "Correct, ClientBase is used to separate autogen vs. not. Is the suggestion to add a Client[Base]* member to ObjectAllocator so it can reference back to it? That could be possible. See the other comment thread for an alternative idea.",
      "parentUuid": "f4a3a15d_42a650d2",
      "range": {
        "startLine": 63,
        "startChar": 24,
        "endLine": 63,
        "endChar": 129
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c98e1273_f225fbd0",
        "filename": "generator/templates/dawn/wire/client/ApiProcs.cpp",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-09T18:49:41Z",
      "side": 1,
      "message": "See conversation in other thread.",
      "parentUuid": "feb27649_ec46c061",
      "range": {
        "startLine": 63,
        "startChar": 24,
        "endLine": 63,
        "endChar": 129
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4ee57da_a39526e0",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-08T23:28:56Z",
      "side": 1,
      "message": "maybe I missed something, but we couldn\u0027t have `New(Client* client, Args\u0026\u0026... args)` ?\n\nu-nit: Args\u0026\u0026 instead of Args, though I don\u0027t think it matter much in practice here since all the args are primitives",
      "range": {
        "startLine": 47,
        "startChar": 25,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad9cd6ea_d588f647",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-08T23:37:33Z",
      "side": 1,
      "message": "maybe it\u0027s because in the next CL you\u0027re doing:\n\n`wireClient-\u003eBufferAllocator().New(device, descriptor);`\n\nwe could do:\n\n`wireClient-\u003eBufferAllocator().New(wireClient, device, descriptor);` though\n\nit\u0027s unfortunate a bit that the `wireClient` argument could be inferred from `device`, but we could break even (from a verbosity point-of-view) if we:\n\n`Client::NewBuffer(args...) { return client-\u003eBufferAllocator().New(client, args...) }`\n?",
      "parentUuid": "d4ee57da_a39526e0",
      "range": {
        "startLine": 47,
        "startChar": 25,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e59b949_efbd91c9",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-08T23:50:17Z",
      "side": 1,
      "message": "(sorry multi-comment)\nnow that I\u0027m looking at it though, we could probably completely hide away \"BufferAllocator()\"\n\n```\ntemplate \u003ctypename T, typename... Args\u003e\nObjectAllocator\u003cT\u003e::ObjectAndSerial Client::New(Args\u0026\u0026...args) {\n  auto* allocator \u003d AllocatorFor\u003cT\u003e;\n  this-\u003e*allocator.New(this, args...);\n}\n\nvoid Client::Free(T* object);\n```\nfeel free to not actually do this change though because though it might be nice and concise, it\u0027s a bunch more complexity to go from type T to the member allocator.\nI think just always having the Client* argument first is good enough for now",
      "parentUuid": "ad9cd6ea_d588f647",
      "range": {
        "startLine": 47,
        "startChar": 25,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c46733a_58e8df8f",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-06-09T16:14:08Z",
      "side": 1,
      "message": "No worries about multi-comment. I wasn\u0027t sure what approach to take either.\n\nWhat do you think of having\n\n1. A `struct ObjectBaseData {uint32_t id; Client* client; ObjectType type}`\n2. Making ObjectAllocator::New be `New(Client*, ObjectType, Args...args)`\n3. Adding `NewBuffer(Args ... args)` and friends to the autogened code of ClientBase, that forwards to a variadic `ObjectAllocator::New` like in this current iteration with \n4. Changing all the constructors to pipe `ObjectBaseData` around.",
      "parentUuid": "6e59b949_efbd91c9",
      "range": {
        "startLine": 47,
        "startChar": 25,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af50b5c8_0149a4c6",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-09T16:40:10Z",
      "side": 1,
      "message": "(2, 3, 4) SGTM\n\n(1) unit: perhaps call it `ObjectBaseParams`\nbut, why do we need the type? if stuff is created via NewBuffer, then we can do client-\u003eTrackObject immediately after creation. I think the tracking only needs to be done before destruction of the object itself, so it should be OK if it\u0027s not done immediately in the constructor. Client* and id we do need in the constructor since as you said, some constructors may start generating some commands.\n\nWe\u0027re not storing the type though, and it would get set from autogen code so you can\u0027t do it wrong, so sounds OK with me though.\nI guess it is a bit nice in that we would have one TrackObject symbol in the binary instead of a bunch of TrackObject\u003cT\u003e which effectively do the same thing. dunno if they would dedup.",
      "parentUuid": "1c46733a_58e8df8f",
      "range": {
        "startLine": 47,
        "startChar": 25,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00918f53_0f0a4def",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-09T18:49:41Z",
      "side": 1,
      "message": "I think the suggested way would work but seems more verbose than necessary. I don\u0027t think we need both a `New` and a `New[ObjectType]`. It would be more concise to just have `New` forwards all its arguments to the ctors.\n\nSo regarding the other comment I had, yes, I was suggesting having a Client[Base]* member as a part of the allocators, this would effectively hide all of this into the current New functions since we can just call the TrackObjects there now and infer the type through the templating. Downside being that we would need to move some of the functions/members between Client and ClientBase, and potentially rewriting the ctor to forward `this` to all the allocators.",
      "parentUuid": "af50b5c8_0149a4c6",
      "range": {
        "startLine": 47,
        "startChar": 25,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3702f5d2_d13dd90e",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-06-10T14:52:06Z",
      "side": 1,
      "message": "I\u0027m still thinking about how to make this nice. In the end it would be ideal if the code to create objects could just be something like:\n\n  client-\u003eGetAllocator()-\u003eMake\u003cBuffer\u003e(a, bunch, of, args);\n  \nAnd that the user just has to define something like\n\n  client::Buffer::Initialize(A a, Bunch bunch, Of of, Args args) {...}\n  \nThis way the only boilerplate on the client objects is that 1) you need to do `using ObjectBase::ObjectBase` and 2) you can\u0027t do things in the constructor but have to do them inside an Initialize method. WDYT of this idea in general? Then the `ObjectAllocator` would have a `PerObjectType\u003cObjectBaseAllocator\u003e mAllocators` which would act on `unique_ptr\u003cObjectBase\u003e` (we already have a vtable so making the destructor virtual is cheap). Then ObjectAllocator would just be a type-safe wrapper around the type erased allocators acting on ObjectBase.\n\nAlso I\u0027m thinking of moving the generation counter in ObjectBase.",
      "parentUuid": "00918f53_0f0a4def",
      "range": {
        "startLine": 47,
        "startChar": 25,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8621693_7ee65060",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-06-14T17:47:46Z",
      "side": 1,
      "message": "Update the CL to do that PTAL again!",
      "parentUuid": "3702f5d2_d13dd90e",
      "range": {
        "startLine": 47,
        "startChar": 25,
        "endLine": 47,
        "endChar": 37
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ae8fa19_7b669036",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-08T21:39:27Z",
      "side": 1,
      "message": "[1] After re-ordering the arguments in [2]:\n\n```\n  auto object \u003d std::make_unique\u003cT\u003e(id, ObjectToEnum\u003cT\u003e::type, std::forward\u003cArgs\u003e(args)...);\n```",
      "range": {
        "startLine": 46,
        "startChar": 4,
        "endLine": 49,
        "endChar": 75
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "730be9ce_5cdf36f5",
        "filename": "src/dawn/wire/client/ObjectAllocator.h",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-08T22:08:16Z",
      "side": 1,
      "message": "n/a",
      "parentUuid": "7ae8fa19_7b669036",
      "range": {
        "startLine": 46,
        "startChar": 4,
        "endLine": 49,
        "endChar": 75
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "495cd7ba_2f545d5f",
        "filename": "src/dawn/wire/client/ObjectBase.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-08T21:39:27Z",
      "side": 1,
      "message": "[2] Re-order such that client is the last arg.",
      "range": {
        "startLine": 33,
        "startChar": 4,
        "endLine": 33,
        "endChar": 61
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fca2b6a9_bf7c8d6a",
        "filename": "src/dawn/wire/client/ObjectBase.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-06-08T22:08:16Z",
      "side": 1,
      "message": "n/a",
      "parentUuid": "495cd7ba_2f545d5f",
      "range": {
        "startLine": 33,
        "startChar": 4,
        "endLine": 33,
        "endChar": 61
      },
      "revId": "c915315dbc778a088fec46a0161adb507ec36ec3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}