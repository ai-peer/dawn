{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "cb361b33_93038ac8",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 41,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-11T16:01:53Z",
      "side": 1,
      "message": "nit: would prefer to pass the WaitableEventManager into the constructor because that is precisely what we need. The WorkerThreadTask shouldn\u0027t be using any other Device-facilities (many of which are not thread-safe)",
      "range": {
        "startLine": 41,
        "startChar": 39,
        "endLine": 41,
        "endChar": 57
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ead85e24_9336b327",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 41,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-12T08:59:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cb361b33_93038ac8",
      "range": {
        "startLine": 41,
        "startChar": 39,
        "endLine": 41,
        "endChar": 57
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40872b98_90203b19",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 55,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-11T16:01:53Z",
      "side": 1,
      "message": "and, would prefer to pass the WorkerTaskPool into this function as it is the only time when we actually need it\n\nWe should also have an ASSERT to check that you don\u0027t call Start(..) more than once. Perhaps by checking that mWaitableEvent \u003d\u003d nullptr",
      "range": {
        "startLine": 55,
        "startChar": 32,
        "endLine": 55,
        "endChar": 34
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b81998bf_6861f079",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 55,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-12T08:59:20Z",
      "side": 1,
      "message": "Done\n\nToday I find another issue here:\nIn DoTask() the WorkerThreadTask object will be released at the end of DoTask(), so after calling PostWorkerTask() here all the members of WorkerThreadTask may be invalid as it is possible that DoTask() is completed before \"mWaitableEvent \u003d waitableEvent.get()\". In fact we cannot use any members in WorkerThreadTask() after PostWorkerTask() is called.\n\nTherefore, I just move all the configurations of WorkerThreadTask into WaitableEventManager,and I decide not to use WaitableEvent* as key because we can only get waitableEvent after PostWorkerTask, when the WorkerThreadTask object may have already been invalid.\n\nPTAL, thanks!",
      "parentUuid": "40872b98_90203b19",
      "range": {
        "startLine": 55,
        "startChar": 32,
        "endLine": 55,
        "endChar": 34
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c2ee321_892b2523",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 55,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-12T23:35:10Z",
      "side": 1,
      "message": "I think that what you have works, but I don\u0027t think it\u0027s a good abstraction. Now the callbacks are intermixed with the worker tasks, and there\u0027s an optional waitable event manager to handle removing tasks from list of tasks.\n\nThe system that creates the tasks should be able to keep track of whether or not those tasks are complete in a self-contained way without too much complexity.\n\nIt seems like part of the problem here is that we\u0027re running into issues with std::future, potential deadlocks with when the std::future is destroyed, and problems where we need the waitable event or some key which references the task to outlive the worker function itself. I\u0027d suggest not using std::launch::async given the problems we\u0027re finding. And I\u0027d suggest making a separate ref-counted allocation to hold onto the task \"handle\". This way, the handle can outlive the task, but we can also access the handle inside the task so the task can remove itself from the list of in-flight tasks.\n\nI cloned your Patchset 24 and applied some of these suggestions in https://dawn-review.googlesource.com/c/dawn/+/50805",
      "parentUuid": "b81998bf_6861f079",
      "range": {
        "startLine": 55,
        "startChar": 32,
        "endLine": 55,
        "endChar": 34
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ab8ec91_ecb1051f",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 55,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-13T01:25:41Z",
      "side": 1,
      "message": "Thanks for your advice. Yes I am also annoyed by std::future which doesn\u0027t allow me deleting itself in the callback function. The only concern to use std::thread instead of std::async is to use std::thread we need to carefully ensure that all the resources are cleared before we delete std::thread object inside the function executed on that thread, but I am still OK if you don\u0027t mind it when using std::thread in Dawn.\n\nI really don\u0027t want to give up this CL and I\u0027d like to use https://dawn-review.googlesource.com/c/dawn/+/50805 as a reference to improve this CL. What do you think?",
      "parentUuid": "8c2ee321_892b2523",
      "range": {
        "startLine": 55,
        "startChar": 32,
        "endLine": 55,
        "endChar": 34
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e7dcb127_9a2aa327",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 55,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-13T01:45:42Z",
      "side": 1,
      "message": "Sounds good to improve this CL.\n\nre std::thread - maybe we can still use std::launch::async.\n\nThe problem is that we\u0027re using the std::future from the launch as the WaitableEvent. It doesn\u0027t have to be this way. We could instead launch an event loop and then use a separate primitive to indicate a task is done.\n\nOverly simplified, but something like:\n\nstd::async(std::launch::async, []() {\n  while(!mTaskQueue.empty()) {\n    // process tasks, wait on a condition variable if there are none.\n  }\n});\n\nclass AsyncWaitableEvent {\n  void Wait() {\n    cv.wait(mutex, [this]() {\n       return !isDone;\n    });\n  }\n \n  std::condition_variable cv;\n  std::mutex mutex;\n  std::atomic\u003cbool\u003e isDone \u003d false;\n};\n\nAsyncWaitableEvent PostWorkerTask(closure) {\n\n  unique_ptr\u003cAsyncWaitableEvent\u003e ev \u003d ...;\n\n  mTaskQueue.push([fn \u003d std::move(closure), ev \u003d ev.get()]() {\n    fn();\n    {\n       lock_guard lock(ev-\u003emutex);\n       ev-\u003eisDone \u003d true;\n    }\n    ev-\u003econditionVariable.notify_one();\n  });\n\n  return ev;\n}",
      "parentUuid": "2ab8ec91_ecb1051f",
      "range": {
        "startLine": 55,
        "startChar": 32,
        "endLine": 55,
        "endChar": 34
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a5702cd_185c00a4",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 55,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-13T01:47:53Z",
      "side": 1,
      "message": "This way completion of the task is just a closure that sets a condition variable when it\u0027s done, and there\u0027s no use of std::future for that part.",
      "parentUuid": "e7dcb127_9a2aa327",
      "range": {
        "startLine": 55,
        "startChar": 32,
        "endLine": 55,
        "endChar": 34
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58f616d7_b984b74d",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 55,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-13T02:07:35Z",
      "side": 1,
      "message": "Oh according to [1], std::async() will always return a std::future, and \"If the std::future obtained from std::async is not moved from or bound to a reference, the destructor of the std::future will block at the end of the full expression until the asynchronous operation completes\", so we will always meet the std::future issue as long as we are using std::async().\n\n[1] https://en.cppreference.com/w/cpp/thread/async",
      "parentUuid": "6a5702cd_185c00a4",
      "range": {
        "startLine": 55,
        "startChar": 32,
        "endLine": 55,
        "endChar": 34
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "877f0973_ef70d0c0",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 86,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-11T16:01:53Z",
      "side": 1,
      "message": "Maybe this function should be called \"MarkWaitableEventCompleted\"\n\nI think mCompletedWaitableEventQueue should become a vector\u003cunique_ptr\u003cWaitableEvent\u003e\u003e and this function should move the event from mWaitableEventsInFlight into mCompletedWaitableEventQueue.\n\nThen, ClearAllCompletedWaitableEvents would simply do mCompletedWaitableEventQueue.clear();\n\nThe reason is because once the events are complete, we need to move them out of mWaitableEventsInFlight immediately, otherwise HasWaitableEventsInFlight will return true even though events are done.",
      "range": {
        "startLine": 85,
        "startChar": 8,
        "endLine": 86,
        "endChar": 62
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9436ff5_a67c3d8c",
        "filename": "src/dawn_native/CallbackTaskManager.cpp",
        "patchSetId": 24
      },
      "lineNbr": 86,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-12T08:59:20Z",
      "side": 1,
      "message": "In fact I don\u0027t want to use too many locks in this CL as it may introduce more potential bugs. Handling mWaitableEventsInFlight here means we should also make it thread-safe, thus adding the complexity of the whole CL.\n\nIn my latest CL I put the removal of waitableEvent in the Callback again, when we are always in the main thread and we don\u0027t need to care about the thread safety of mWaitableEventsInFlight.\n\nWhat do you think?",
      "parentUuid": "877f0973_ef70d0c0",
      "range": {
        "startLine": 85,
        "startChar": 8,
        "endLine": 86,
        "endChar": 62
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0e02b9f_60f547c7",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 24
      },
      "lineNbr": 404,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-11T16:01:53Z",
      "side": 1,
      "message": "true?",
      "range": {
        "startLine": 404,
        "startChar": 19,
        "endLine": 404,
        "endChar": 24
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc6bfc80_619d4c11",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 24
      },
      "lineNbr": 404,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-12T08:59:20Z",
      "side": 1,
      "message": "I think \"has waitableEvents in flight\" means \"device is doing something async and not idle\", so here we should return false. What do you think?",
      "parentUuid": "c0e02b9f_60f547c7",
      "range": {
        "startLine": 404,
        "startChar": 19,
        "endLine": 404,
        "endChar": 24
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5fb9494a_93331cc7",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 24
      },
      "lineNbr": 404,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-12T23:35:10Z",
      "side": 1,
      "message": "Right, sorry I read this in the opposite direction.",
      "parentUuid": "bc6bfc80_619d4c11",
      "range": {
        "startLine": 404,
        "startChar": 19,
        "endLine": 404,
        "endChar": 24
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8de0ae02_ab17913c",
        "filename": "src/dawn_native/Instance.cpp",
        "patchSetId": 24
      },
      "lineNbr": 228,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-11T16:01:53Z",
      "side": 1,
      "message": "Can we lazily create mDefaultPlatform here instead? That way if someone manually sets it with SetPlatform, it is never instantiated",
      "range": {
        "startLine": 228,
        "startChar": 0,
        "endLine": 228,
        "endChar": 75
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cdaf06c9_9e59e507",
        "filename": "src/dawn_native/Instance.cpp",
        "patchSetId": 24
      },
      "lineNbr": 228,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-12T08:59:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8de0ae02_ab17913c",
      "range": {
        "startLine": 228,
        "startChar": 0,
        "endLine": 228,
        "endChar": 75
      },
      "revId": "697ba1d27f8626848f769c55726eb114373870ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}