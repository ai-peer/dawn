{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c12a653d_e83adb8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 14
      },
      "lineNbr": 0,
      "author": {
        "id": 1000685
      },
      "writtenOn": "2023-02-09T00:41:51Z",
      "side": 1,
      "message": "Thanks for the review, will land after the bindings validation perf test",
      "revId": "aa0d99294e2182cdb43065225fe3948afdb14713",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b243e0af_46334e22",
        "filename": "src/dawn/native/CommandBufferStateTracker.cpp",
        "patchSetId": 14
      },
      "lineNbr": 106,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-02-09T00:58:56Z",
      "side": 1,
      "message": "nit: I think it\u0027s better to do the loops like\n```\nfor i in range(0, length):\n  for j in range(i + 1, length):\n```\n\nit\u0027s still O(n^2) but it\u0027s half as many iterations. n(n+1)/2 vs n*n\n\nyou would need to change your overlap condition to check for two cases. I think right now, it only checks for:\n\n```\nrange 0: [     ]\nrange 1:    [       ]\n```\n\nbut we would also need to check the other direction:\n```\nrange 0:      [     ]\nrange 1: [       ]\n```\n\nwe should also make sure the tests cover both cases",
      "range": {
        "startLine": 103,
        "startChar": 13,
        "endLine": 106,
        "endChar": 13
      },
      "revId": "aa0d99294e2182cdb43065225fe3948afdb14713",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "56338daa_a610f307",
        "filename": "src/dawn/native/CommandBufferStateTracker.cpp",
        "patchSetId": 14
      },
      "lineNbr": 106,
      "author": {
        "id": 1000685
      },
      "writtenOn": "2023-02-09T18:41:05Z",
      "side": 1,
      "message": "Fix the for loop and add tests.\n\nRegards to the second part:\n\nFor our if condition `offset0 \u003c\u003d offset1 + bufferBinding1.size - 1 \u0026\u0026 offset1 \u003c\u003d offset0 + bufferBinding0.size - 1`\n\n```\nrange 0: [0   5]\nrange 1:    [2    8]\n```\n\noffset1 \u003d 2 \u003c\u003d 5 \u003d offset0 + size0 -\u003e there is overlap\n\n```\nrange 0:    [2    8]\nrange 1: [0   5]\n```\n\noffset0 \u003d 2 \u003c\u003d 5 \u003d offset1 + size1 -\u003e there is overlap\n\nYou can think of \"having overlap\" as the inverse of \"[min0, max0] has no overlap with [min1, max1]\", which can be more intuitively mapped to `!(min0 \u003e max1 || min1 \u003e max0)`. (From stackoverflow)",
      "parentUuid": "b243e0af_46334e22",
      "range": {
        "startLine": 103,
        "startChar": 13,
        "endLine": 106,
        "endChar": 13
      },
      "revId": "aa0d99294e2182cdb43065225fe3948afdb14713",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f0acd066_057ca5e7",
        "filename": "src/dawn/native/CommandBufferStateTracker.cpp",
        "patchSetId": 14
      },
      "lineNbr": 106,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-02-09T22:23:38Z",
      "side": 1,
      "message": "ah I see - thanks for the explanation",
      "parentUuid": "56338daa_a610f307",
      "range": {
        "startLine": 103,
        "startChar": 13,
        "endLine": 106,
        "endChar": 13
      },
      "revId": "aa0d99294e2182cdb43065225fe3948afdb14713",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52af6919_b4a5d3fd",
        "filename": "src/dawn/native/CommandBufferStateTracker.cpp",
        "patchSetId": 14
      },
      "lineNbr": 112,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-02-09T00:58:56Z",
      "side": 1,
      "message": "sorry - I just thought of another idea. If you have the perf test locally, you could try it out to verify if it\u0027s actually better\n\nright now, this inner part happens O(n^2) times which is a lot of lookups and indirections. Between this and the outer loop, we look up the same binding many times.\n\nIf, inside the reduction step, we ALSO did all these indirections AND applied dynamic offsets, then we would avoid all the extra lookups.\nIt can also pre-filter out bindings that are zero-sized.\n\nSo, `bindingsToCheck` would actually be std::vector\u003cBufferBinding\u003e.\nTakes more space than just the indices, but less work is done in the inner loop",
      "range": {
        "startLine": 108,
        "startChar": 12,
        "endLine": 112,
        "endChar": 44
      },
      "revId": "aa0d99294e2182cdb43065225fe3948afdb14713",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5baa25b_8af70736",
        "filename": "src/dawn/native/CommandBufferStateTracker.cpp",
        "patchSetId": 14
      },
      "lineNbr": 112,
      "author": {
        "id": 1000685
      },
      "writtenOn": "2023-02-22T00:36:18Z",
      "side": 1,
      "message": "cpu_time truncated mean: 44652.53 -\u003e 41546.34 (-7%); But additionally adding a .reserve(8) -\u003e 38873.35 (-13%). The binding validation perf test don\u0027t have buffer size \u003d 0 so the real world perf can be no worse.\n\nWe are losing groupIndex and bindingIndex info for error message. Fix by using a template with return type to store a additional groupIndex and bindingIndex vector at unlikely callsite. (need another look)",
      "parentUuid": "52af6919_b4a5d3fd",
      "range": {
        "startLine": 108,
        "startChar": 12,
        "endLine": 112,
        "endChar": 44
      },
      "revId": "aa0d99294e2182cdb43065225fe3948afdb14713",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "796eae52_8f7d8973",
        "filename": "src/dawn/native/CommandBufferStateTracker.cpp",
        "patchSetId": 14
      },
      "lineNbr": 112,
      "author": {
        "id": 1000685
      },
      "writtenOn": "2023-02-22T19:21:06Z",
      "side": 1,
      "message": "Forgot to put here:\n\nbefore and after adding the validation, busy validation at every dispatch: the cpu_time truncated mean: 32147.55 -\u003e 38363.98, + ~19% (not a small amount)\n\nlazy validation (only validate at first dispatch): almost same before and after",
      "parentUuid": "d5baa25b_8af70736",
      "range": {
        "startLine": 108,
        "startChar": 12,
        "endLine": 112,
        "endChar": 44
      },
      "revId": "aa0d99294e2182cdb43065225fe3948afdb14713",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}