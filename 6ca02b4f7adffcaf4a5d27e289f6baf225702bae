{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "71a37aad_a1aea435",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-11-29T12:24:38Z",
      "side": 1,
      "message": "Can you detail what are the unexpected behaviors when the buffer size isn\u0027t set to 0? It seems that the map async wouldn\u0027t work so it doesn\u0027t matter what the reflection gives?",
      "revId": "6ca02b4f7adffcaf4a5d27e289f6baf225702bae",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3dd604d_5ef393ff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-30T01:21:20Z",
      "side": 1,
      "message": "Here is why the test webgpu:api,operation,buffers,map_oom:mapAsync:oom\u003dtrue;size\u003d9007199254740984 fails on Win10_x86 bots:\n\n1. In the test the size exceeds kGuaranteedBufferOOMSize (std::numeric_limits\u003csize_t\u003e::max(), on x86 systems it is MAX_UINT), so it will be clamped to MAX_UINT.\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/modules/webgpu/gpu_buffer.cc;l\u003d134\n\n2. On wire_client, when we create an error buffer, mSize won\u0027t be set to 0, it will be MAX_UINT:\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/wire/client/Buffer.cpp;l\u003d141\n\n3. On wire_server, size64 is MAX_UINT, which is equal to WGPU_WHOLE_MAP_SIZE (std::numeric_limits\u003csize_t\u003e::max(), on x86 systems it is MAX_UINT)\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/wire/server/ServerBuffer.cpp;l\u003d83\n\n4. Then an WGPUBufferMapAsyncStatus_Error will be directly returned without any validations in dawn_native, so the test fails (the test checks if the validation error has been correctly generated).\n\nSo if we set mSize to 0 for OOM buffers at wire_client (like what we did before https://dawn-review.googlesource.com/c/dawn/+/109040), the step 3 will be avoided, then we will pass the test.\n\nIn fact theoretically an OOM buffer shouldn\u0027t have valid mSize, and we are using mSize in MapAsync() and GetMappedRange(), so I think we should ensure OOM buffer not have a valid mSize to avoid any potential issues about using an unexpected mSize for an OOM buffer on wire_client.",
      "parentUuid": "71a37aad_a1aea435",
      "revId": "6ca02b4f7adffcaf4a5d27e289f6baf225702bae",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89a82881_09631862",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-30T03:09:31Z",
      "side": 1,
      "message": "hmm.. thanks for the explanation!\n\nto me, I think the problem is happening in (3). with the `|| size64 \u003e\u003d WGPU_WHOLE_MAP_SIZE` part of the check. the size is equal to WHOLE_MAP_SIZE so it\u0027s erroring early before going to dawn::native for validation.\nThe intent of this code is to catch problems where the client is a 64-bit platform and the server is a 32-bit platform. So the client is expressing some size that can\u0027t be interpreted by the server. It can\u0027t even be passed into dawn::native because the 64-bit size would narrow into a 32-bit size_t. The problem is, this doesn\u0027t work very well because that means on a 32-bit server, the \"magic\" value for WHOLE_MAP_SIZE is right in the middle of the representable range of values the client might be sending.\n\nWhat we probably should do instead is have a separate boolean in the MapAsync message that indicates whether the client wants to use \"WHOLE_MAP_SIZE\" or not since over the wire in this situation, the value is an overloaded concept.\n\nHowever, applications where the client is 64-bit and the server is 32-bit don\u0027t exist right now (that we know of) so I think the simplest thing we can right now is change `|| size64 \u003e\u003d WGPU_WHOLE_MAP_SIZE` into `|| size64 \u003e WGPU_WHOLE_MAP_SIZE`.\n\nThat will let through the \u003d\u003d case which would otherwise be valid if the buffer were not an error.\nIt\u0027ll go to dawn::native and hit the correct validation",
      "parentUuid": "f3dd604d_5ef393ff",
      "revId": "6ca02b4f7adffcaf4a5d27e289f6baf225702bae",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "306b7d5a_664f9f8c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-30T04:52:58Z",
      "side": 1,
      "message": "Oh I once thought I should change the code back to the previous version (https://dawn-review.googlesource.com/c/dawn/+/109040/16/src/dawn/wire/client/Device.cpp#b203), where the error buffer is always created with size \u003d\u003d 0 (in fact it is using an empty buffer descriptor, but we shouldn\u0027t do that because we need to validate other parameters on the server side).",
      "parentUuid": "89a82881_09631862",
      "revId": "6ca02b4f7adffcaf4a5d27e289f6baf225702bae",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "93745d14_4b2a70f7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-29T08:24:30Z",
      "side": 1,
      "message": "I\u0027ve verified this CL can fix the failures on the Windows x86 bots.\n\nPTAL, thanks!",
      "revId": "6ca02b4f7adffcaf4a5d27e289f6baf225702bae",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}