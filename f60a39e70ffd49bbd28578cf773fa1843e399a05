{
  "comments": [
    {
      "key": {
        "uuid": "06059ccd_e21713f2",
        "filename": "src/dawn_native/ResourceMemoryAllocation.h",
        "patchSetId": 37
      },
      "lineNbr": 48,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "With comments other comments both of these wouldn\u0027t be needed:\n\n - mMemoryFlags would stay a backend-specific thing and could be stored in the ResourceHeapAllocation structure.\n - mMemorySize isn\u0027t needed anymore once we use a single buddy system per heapFlags + heapType combination.",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f66f938_cd56b7bb",
        "filename": "src/dawn_native/ResourceMemoryAllocation.h",
        "patchSetId": 37
      },
      "lineNbr": 48,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Only memory flags + type can be hard coded and dealt with ahead-of-time. Memory size is still needed for the optimization without over-committing memory.",
      "parentUuid": "06059ccd_e21713f2",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ad11cc59_0bd621bd",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 42,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-10-09T22:49:57Z",
      "side": 1,
      "message": "Is it necessary that the heap be stored in a ComPtr? If the D3D12 heap object outlives this method, consider storing it as a raw pointer.",
      "range": {
        "startLine": 42,
        "startChar": 8,
        "endLine": 42,
        "endChar": 31
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3cb67cf6_04235b63",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ad11cc59_0bd621bd",
      "range": {
        "startLine": 42,
        "startChar": 8,
        "endLine": 42,
        "endChar": 31
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b30212d3_8dd3a001",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-10-09T22:49:57Z",
      "side": 1,
      "message": "Good that you put the placed resource into the \u0027reference until unused\u0027 list. \n\nHowever, if we tell the buddy allocation that offset in the heap is available right away, it could be reallocated to a different placed resource at the same time that the original one is still in use by the GPU.  \n\nI think we\u0027ll need to enhance ReferenceUntilUnused to also run code which does the deallocation in the buddy allocator.",
      "range": {
        "startLine": 61,
        "startChar": 1,
        "endLine": 62,
        "endChar": 53
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bf8d684_3d96f262",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-10-10T00:15:53Z",
      "side": 1,
      "message": "Bryan is indeed calling mBuddyMemoryAllocator.Deallocate right away which will allow it to hand out an offset that\u0027s currently in use.\n\nThe Resource will still be in use by the GPU, but we\u0027ll allocate another PlacedResource that aliases the same memory. (Can you do that? I think the answer is yes).\n\nI don\u0027t think we have the necessary aliasing barriers though..",
      "parentUuid": "b30212d3_8dd3a001",
      "range": {
        "startLine": 61,
        "startChar": 1,
        "endLine": 62,
        "endChar": 53
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a873835_1de8a252",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-10-10T00:26:46Z",
      "side": 1,
      "message": "Austin, yes you can have two placed resources aliasing the same memory.  Aliasing barriers are necessary if you want to change the representation of the heap memory from one resource to another. \nThe source and/or destination resource may require hardware specific formatting changes.  \n\nWhat I wrote above doesn\u0027t really apply to our use case.  Since we\u0027re implementing a general purpose allocator, we don\u0027t want to have the contents of the second resource stomp on the first resource if the GPU is not finished accessing the first resource.",
      "parentUuid": "8bf8d684_3d96f262",
      "range": {
        "startLine": 61,
        "startChar": 1,
        "endLine": 62,
        "endChar": 53
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6aad2783_216489e2",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "In the D3D12 advanced barrier model, there is an implicit aliasing barrier between each command list, so we only need them if we reuse resource memory in the same command list. This can never happen here because in Dawn, at the moment, resource de-allocation is done one Tick, which happens after the last command list using the resource is done executing.\n\nWe should definitely have a comment to explain this non-trivial behavior here.",
      "parentUuid": "8a873835_1de8a252",
      "range": {
        "startLine": 61,
        "startChar": 1,
        "endLine": 62,
        "endChar": 53
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "661f36ab_00a11870",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Good catch, RC. \n\nSynchronization (not aliasing) is the issue. It needs a two-phase deletion: Deallocate + FreeMemory, like Vulkan\u0027s FencedDeleter.\n\nI also left a comment on aliasing to avoid future confusion.",
      "parentUuid": "6aad2783_216489e2",
      "range": {
        "startLine": 61,
        "startChar": 1,
        "endLine": 62,
        "endChar": 53
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b00b0355_39d82833",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-14T15:46:00Z",
      "side": 1,
      "message": "I actually think the code here was correct: it is valid to reallocate resources even if the same memory region is in use by the GPU because by the time the new resource starts using the memory range, the old resource will have completely finished running on the GPU.",
      "parentUuid": "661f36ab_00a11870",
      "range": {
        "startLine": 61,
        "startChar": 1,
        "endLine": 62,
        "endChar": 53
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ce22b2e_8a76cdc4",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-15T18:54:47Z",
      "side": 1,
      "message": "I don\u0027t believe that\u0027s correct.\n\nThere is no guarantee the CPU wont stomp over the memory regardless if the GPU is finished with it or not.",
      "parentUuid": "b00b0355_39d82833",
      "range": {
        "startLine": 61,
        "startChar": 1,
        "endLine": 62,
        "endChar": 53
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "18acd316_8f3078c8",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 21,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "nit: this is only every used by the ResourceAllocator so it could be a helper class defined in the same file and with just a forward declaration in the header.",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "844e1114_0b0dce19",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 21,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "SGTM. Also, moved committed resource allocator to be consistent.",
      "parentUuid": "18acd316_8f3078c8",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6aae06a0_ab07e46d",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 40,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "heapFlags is constant for each BuddyPlacedResourceAllocator so it could be passed in the constructor and stored in a member. (we really don\u0027t want to mix heaps with different heapFlags in the same buddy system).",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ed4e693_377f4520",
        "filename": "src/dawn_native/d3d12/BuddyPlacedResourceAllocatorD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6aae06a0_ab07e46d",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d14e926f_4c67ede4",
        "filename": "src/dawn_native/d3d12/CommittedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 34,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-09T21:12:14Z",
      "side": 1,
      "message": "Note to update this comment to \"...and do not need to be explicitly...\".",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36ee9578_8f76d3e7",
        "filename": "src/dawn_native/d3d12/CommittedResourceAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 34,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d14e926f_4c67ede4",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9906a3f7_a053c366",
        "filename": "src/dawn_native/d3d12/HeapAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 25,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "We are piping the memoryFlags from [1] to here but there is always a single memory flag used for each buddy system.\n\nHow about making BuddyPlacedResourceAllocator implement the MemoryAllocator interface and pass itself to the BuddyMemoryAllocator?",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d92b90be_c5326cb9",
        "filename": "src/dawn_native/d3d12/HeapAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 25,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "\u003e We are piping the memoryFlags from [1] to here but there is always a single memory flag used for each buddy system.\n\nThe memory flag is used here to create the sized heap on-demand.\n\n\u003e How about making BuddyPlacedResourceAllocator implement the MemoryAllocator interface and pass itself to the BuddyMemoryAllocator\n\nI think it\u0027s better to keep resources near the device and not tied to implementing heap-interfaces. Perhaps we can revisit for committed resource based sub-allocation.",
      "parentUuid": "9906a3f7_a053c366",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cfc16499_59a41c5f",
        "filename": "src/dawn_native/d3d12/HeapAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 25,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-14T15:46:00Z",
      "side": 1,
      "message": "\u003e \u003e We are piping the memoryFlags from [1] to here but there is always a single memory flag used for each buddy system.\n\u003e \n\u003e The memory flag is used here to create the sized heap on-demand.\n\u003e \nYes, that\u0027s orthogonal: we can store the memory flags as a member of this class instead of piping it through several function calls if we make this class implement the MemoryAllocator interface.\n\n\u003e \u003e How about making BuddyPlacedResourceAllocator implement the MemoryAllocator interface and pass itself to the BuddyMemoryAllocator\n\u003e \n\u003e I think it\u0027s better to keep resources near the device and not tied to implementing heap-interfaces. Perhaps we can revisit for committed resource based sub-allocation.\n\nI don\u0027t understand your answer, making this class implement MemoryAllocator doesn\u0027t make \"resources farther to the device\".",
      "parentUuid": "d92b90be_c5326cb9",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52a30049_b6e02814",
        "filename": "src/dawn_native/d3d12/HeapAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 25,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-15T18:54:47Z",
      "side": 1,
      "message": "\u003e Yes, that\u0027s orthogonal: we can store the memory flags as a member of this class instead of piping it through several function calls if we make this class implement the MemoryAllocator interface.\n\nThese seem unrelated. Flags can be cached on HeapAllocator without further changes.\n\n\u003e I don\u0027t understand your answer, making this class implement MemoryAllocator doesn\u0027t make \"resources farther to the device\".\n\nI understood \"pass itself\" to mean BuddyMemoryAllocator::mClient becomes BuddyPlacedResourceAllocator (was HeapAllocator). This means CreatePlacedResource would not be directly called from ResourceAllocatorManager. This is another layer between Device::AllocateMemory and Device::CreatePlacedResource, hence \"further from the device\".\n\nI would prefer to have CreatePlacedResource be called at the same level as CreateCommittedResource, removing the need for BuddyPlacedResourceAllocator.",
      "parentUuid": "cfc16499_59a41c5f",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73903c88_1a17b81c",
        "filename": "src/dawn_native/d3d12/HeapAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 25,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-16T18:13:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "52a30049_b6e02814",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d8c2e205_6b3110f9",
        "filename": "src/dawn_native/d3d12/HeapAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 45,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-10-10T00:15:53Z",
      "side": 1,
      "message": "nit: I don\u0027t think the assignment is necessary. We can just return std::make_unique\n\n(I may be wrong because of ResultOrError)",
      "range": {
        "startLine": 44,
        "startChar": 8,
        "endLine": 45,
        "endChar": 26
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c903f16d_136b696c",
        "filename": "src/dawn_native/d3d12/HeapAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 45,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "Yeah it could maybe require:\n\n return {std::make_unique\u003cHeap\u003e(std::move(heap)));",
      "parentUuid": "d8c2e205_6b3110f9",
      "range": {
        "startLine": 44,
        "startChar": 8,
        "endLine": 45,
        "endChar": 26
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47f99b22_15b1a4f8",
        "filename": "src/dawn_native/d3d12/HeapAllocatorD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 45,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c903f16d_136b696c",
      "range": {
        "startLine": 44,
        "startChar": 8,
        "endLine": 45,
        "endChar": 26
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ebe57ab4_b1805256",
        "filename": "src/dawn_native/d3d12/HeapD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 23,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "This should probably be called ResourceHeap so that the relation with ResourceHeapBase is clear wherever this type is used.",
      "range": {
        "startLine": 23,
        "startChar": 10,
        "endLine": 23,
        "endChar": 14
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "453eb3d7_f5404326",
        "filename": "src/dawn_native/d3d12/HeapD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 23,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Rather than rename d3d::Heap to be prefixed with something it\u0027s not, a Resource. How about we rename ResourceHeapBase to [Memory|Heap]Base?",
      "parentUuid": "ebe57ab4_b1805256",
      "range": {
        "startLine": 23,
        "startChar": 10,
        "endLine": 23,
        "endChar": 14
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d27d5d9a_462b4e1a",
        "filename": "src/dawn_native/d3d12/HeapD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 23,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-17T16:11:46Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "453eb3d7_f5404326",
      "range": {
        "startLine": 23,
        "startChar": 10,
        "endLine": 23,
        "endChar": 14
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "57a25b73_d6a49f05",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 19,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-10-10T00:15:53Z",
      "side": 1,
      "message": "unit: common/ before dawn_native/",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 19,
        "endChar": 0
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5760a83c_6f3e9c9e",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 19,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "57a25b73_d6a49f05",
      "range": {
        "startLine": 17,
        "startChar": 0,
        "endLine": 19,
        "endChar": 0
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "686176da_42a14432",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 107,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-10-10T00:15:53Z",
      "side": 1,
      "message": "If the two allocators implemented the same interface, then we could switch on the allocation method to choose the allocator, and then factor the part where we call -\u003eDeallocate.\n\nIs there a reason the placed buddy allocator and committed resource allocators don\u0027t share a base class?\n\nWe could also factor ::AllocateMemory in the same way. First choose the allocator and then call -\u003eAllocate on it.",
      "range": {
        "startLine": 106,
        "startChar": 12,
        "endLine": 107,
        "endChar": 46
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c22aa0c_0984a97a",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 107,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "\u003e Is there a reason the placed buddy allocator and committed resource allocators don\u0027t share a base class?\n\nThey have unlike interfaces. Well, only ::Deallocate is common but that\u0027s by happenstance.",
      "parentUuid": "686176da_42a14432",
      "range": {
        "startLine": 106,
        "startChar": 12,
        "endLine": 107,
        "endChar": 46
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "905cda0a_469a413c",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 126,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "What else would we do for small resources? Also it will be a common advice for WebGPU users to batch things so small resources should be rare.",
      "range": {
        "startLine": 125,
        "startChar": 0,
        "endLine": 126,
        "endChar": 66
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2369298_1ff669d1",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 126,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "\u003e What else would we do for small resources?\n\nThat\u0027s where CommittedResource + BuddyAllocator comes in. \u003d)\n\n\u003e Also it will be a common advice for WebGPU users to batch things so small resources should be rare.\n\nAnecdotally, Aquarium allocates 4KB buffers which requires a whole new 64KB page per allocation.",
      "parentUuid": "905cda0a_469a413c",
      "range": {
        "startLine": 125,
        "startChar": 0,
        "endLine": 126,
        "endChar": 66
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ebc57219_16993117",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 126,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-14T15:46:00Z",
      "side": 1,
      "message": "\u003e \u003e What else would we do for small resources?\n\u003e \n\u003e That\u0027s where CommittedResource + BuddyAllocator comes in. \u003d)\n\u003e \n\nI thought we agreed that wouldn\u0027t work. For example with this mechanism we wouldn\u0027t be able to produce the correct resource transition barriers.",
      "parentUuid": "a2369298_1ff669d1",
      "range": {
        "startLine": 125,
        "startChar": 0,
        "endLine": 126,
        "endChar": 66
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9010c06e_b8cb266c",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 126,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-15T18:54:47Z",
      "side": 1,
      "message": "Don\u0027t recall coming to that conclusion. Only that we never felt strongly about using it over placed resources.",
      "parentUuid": "ebc57219_16993117",
      "range": {
        "startLine": 125,
        "startChar": 0,
        "endLine": 126,
        "endChar": 66
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "82288eaa_1977342c",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 128,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "Creating things lazily like this always adds complexity, since there are only 5 cases we care about, can we initialize things in the constructor?",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32655136_57a9a4f6",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 128,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "82288eaa_1977342c",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca9d457a_4202a7b7",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 140,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-10-10T00:15:53Z",
      "side": 1,
      "message": "Reading this was quite confusing both branches do CreatePlacedResourceAllocators(...). \n\nCan we separate creating the map entry from populating it with the vector of allocators?\n\nif (allocators.find(...) \u003d\u003d allocators.end)) {\n    allocators.emplace(heapFlags, emptyArray);\n}\n\nif (allocators[heapFlags][heapTypeIndex].empty()) {\n    allocators[heapFlags][heapTypeIndex] \u003d CreatePlacedResourceAllocators(...);\n}",
      "range": {
        "startLine": 127,
        "startChar": 8,
        "endLine": 140,
        "endChar": 9
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a23a092_98211f87",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 140,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "ca9d457a_4202a7b7",
      "range": {
        "startLine": 127,
        "startChar": 8,
        "endLine": 140,
        "endChar": 9
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0429a431_eaae8a65",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 156,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "This heapLevel logic would be simplified out when we use a single buddy system per heapType + heapFlags combination.",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "501c99b4_0abb11db",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 156,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Please see my other response.",
      "parentUuid": "0429a431_eaae8a65",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b83aebf_4915c756",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 160,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "Having the logic here hides it a bit, how about moving it in [1] so we can do:\n\n if (resource is too large) {\n   create committed\n } else {\n   create placed\n }\n\nThis way SubAllocateMemory is guaranteed to provide an allocation or a DAWN_OUT_OF_MEMORY_ERROR.",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6108893_88b95f45",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 160,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Does [1] refer to ::AllocateMemory?",
      "parentUuid": "6b83aebf_4915c756",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af6a438c_67763911",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 160,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-14T15:46:00Z",
      "side": 1,
      "message": "Yes, sorry, it should have been [2] and I forgot to add the marker.\n\nNot that this isn\u0027t solved in patchset 39.",
      "parentUuid": "f6108893_88b95f45",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e23f89e3_a6037373",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 160,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-15T18:54:47Z",
      "side": 1,
      "message": "This check is no longer needed.",
      "parentUuid": "af6a438c_67763911",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "15db9dde_841480c8",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 177,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "This heapLevel logic would be simplified out when we use a single buddy system per heapType + heapFlags combination.",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac1db9c0_4413f857",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 177,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Please see my other response.",
      "parentUuid": "15db9dde_841480c8",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b13a7674_325ce655",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 190,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-10-10T00:15:53Z",
      "side": 1,
      "message": "This bug seems unrelated?",
      "range": {
        "startLine": 189,
        "startChar": 8,
        "endLine": 190,
        "endChar": 44
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1de0bf82_228acb19",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.cpp",
        "patchSetId": 37
      },
      "lineNbr": 190,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "Done.",
      "parentUuid": "b13a7674_325ce655",
      "range": {
        "startLine": 189,
        "startChar": 8,
        "endLine": 190,
        "endChar": 44
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9b53c0df_7a5fe98d",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-09T21:08:05Z",
      "side": 1,
      "message": "+Rafael. Is it OK to use this enum as such?",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "54e8ad04_10de985f",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 62,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-15T18:54:47Z",
      "side": 1,
      "message": "No longer relevant.",
      "parentUuid": "9b53c0df_7a5fe98d",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0328b9b1_06245c81",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 72,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "When / what do we expect to use the custom heap for?",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fea59386_f8d382ac",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 72,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "I do not have plans for using custom heaps. But I do plan to investigate.",
      "parentUuid": "0328b9b1_06245c81",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9fef3083_f0ed0a16",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 78,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "nit: prefer using \"using\"\n\nWhy do we need this extra dimension? We seem to bucket by heap level, but the point of the buddy allocator is that it can allocate resources of various sizes in the same buddy system no?",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fe6c084_f705117b",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 78,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "The level is a heap threshold (or max resource size) each buddy system can satisfy. The fact the heap is created on-demand up to a specific threshold is very important for managing residency - we do not want to allocate a 32GB heap when only a 1MB heap was sufficient.",
      "parentUuid": "9fef3083_f0ed0a16",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3386d1e_edb12d06",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 78,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-14T15:46:00Z",
      "side": 1,
      "message": "Yes, and the point of the meta-buddy system is that we can have code like the following:\n\n if (resourceSize \u003e kMaxBuddyBlock) {\n   create committed resource (or create a heap + create placed resource)\n } else {\n   get a memory range from the buddy system\n   create placed resource in that range\n }\n\nif kMaxBuddyBlock is 1MB you get the property you desire. Right now the logic is more like having a bunch of slab allocators for powers of two.",
      "parentUuid": "8fe6c084_f705117b",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb2e8029_4080c470",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 78,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-15T18:54:47Z",
      "side": 1,
      "message": "That\u0027s not the property I desire and the condition check is incorrect.\n\nThere is no benefit to the meta-buddy system when kMaxBuddyBlock \u003d\u003d heapSize. Instead, kMaxBuddyBlock would be 32GB with a heapSize \u003d 1MB. Then, only one buddy system (vs 32K) is needed.\n\nThe extra dimension was used so heapSize did not need to be set to some arbitrary value.\n\nHowever, per our discussion, I\u0027m OK to set the heapSize \u003d\u003d 4MB to simplify this CL.",
      "parentUuid": "f3386d1e_edb12d06",
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c46abb17_a3fb5f3d",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 80,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T12:55:08Z",
      "side": 1,
      "message": "There are only 5 cases that we care about (even with only Tier 1 support):\n\n - D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS + D3D12_HEAP_TYPE_READBACK\n - D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS + D3D12_HEAP_TYPE_UPLOAD\n - D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS | D3D12_HEAP_FLAG_ALLOW_SHADER_ATOMICS + D3D12_HEAP_TYPE_DEFAULT\n - D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES | D3D12_HEAP_FLAG_ALLOW_SHADER_ATOMICS + D3D12_HEAP_TYPE_DEFAULT\n - D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES | D3D12_HEAP_FLAG_ALLOW_SHADER_ATOMICS + D3D12_HEAP_TYPE_DEFAULT\n\nHow about having an internal enum to represent them and just have an std::array of std::vector here.",
      "range": {
        "startLine": 80,
        "startChar": 0,
        "endLine": 80,
        "endChar": 87
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b82dec8_d8ac4599",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 80,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-10-11T18:47:07Z",
      "side": 1,
      "message": "I\u0027m not sure what D3D12_HEAP_FLAG_ALLOW_SHADER_ATOMICS does across drivers. It\u0027s not very well documented and I suspect its separated due to side-effects. This is a downside of that approach. If the flags are not combined right, more attention is needed.\n\nI don\u0027t have a strong opinion either way, SGTM.",
      "parentUuid": "c46abb17_a3fb5f3d",
      "range": {
        "startLine": 80,
        "startChar": 0,
        "endLine": 80,
        "endChar": 87
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e56c4d92_77af2514",
        "filename": "src/dawn_native/d3d12/ResourceAllocatorManagerD3D12.h",
        "patchSetId": 37
      },
      "lineNbr": 80,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-14T15:46:00Z",
      "side": 1,
      "message": "Yes it will be interesting to know what effect ALLOW_SHADER_ATOMICS has. We definitely need this flag for storage buffer / textures because they support atomic operations but we can see later if we need to split between atomic vs. not or use a single heap type for both.",
      "parentUuid": "2b82dec8_d8ac4599",
      "range": {
        "startLine": 80,
        "startChar": 0,
        "endLine": 80,
        "endChar": 87
      },
      "revId": "f60a39e70ffd49bbd28578cf773fa1843e399a05",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    }
  ]
}