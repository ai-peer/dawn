{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1ad8fb1a_6bc91fe9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000257
      },
      "writtenOn": "2022-11-03T12:06:14Z",
      "side": 1,
      "message": "PTAL.",
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d09354d0_b68af255",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1580,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-11-03T12:18:14Z",
      "side": 1,
      "message": "Use `IsSignedIntegral\u003cNumberT\u003e`",
      "range": {
        "startLine": 1580,
        "startChar": 27,
        "endLine": 1580,
        "endChar": 83
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1ec7629_e7b7f3da",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1580,
      "author": {
        "id": 1000257
      },
      "writtenOn": "2022-11-03T12:50:49Z",
      "side": 1,
      "message": "Nack. Changing this caused compile errors around constexpr and then errors around `abs` being ambiguous.",
      "parentUuid": "d09354d0_b68af255",
      "range": {
        "startLine": 1580,
        "startChar": 27,
        "endLine": 1580,
        "endChar": 83
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c667c21_fdb7a8e2",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1580,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2022-11-03T13:21:03Z",
      "side": 1,
      "message": "The only difference between what you\u0027ve written and using `IsSignedIntegral\u003cNumberT\u003e` is that `IsSignedIntegral` unwraps the template type with `UnwrapNumber` - which would be required if `NumberT` were a `Number\u003cT\u003e`.\n\nGiven that it causes errors, it sounds like this condition is always `false` (`std::is_integral_v\u003cNumber\u003cT\u003e\u003e` is always `false`).",
      "parentUuid": "a1ec7629_e7b7f3da",
      "range": {
        "startLine": 1580,
        "startChar": 27,
        "endLine": 1580,
        "endChar": 83
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6468f965_572193c3",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1580,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-11-03T13:34:22Z",
      "side": 1,
      "message": "I messed around with this, and the fact that it compiles at all is weird, given that `e \u003d\u003d std::numeric_limits\u003cNumberT\u003e::min()` is not a constant expression.\n\nThis works:\n\n```\n            NumberT result;\n            if constexpr (IsUnsignedIntegral\u003cNumberT\u003e) {\n                result \u003d e;\n            } else if constexpr (IsSignedIntegral\u003cNumberT\u003e) {\n                if (e \u003d\u003d NumberT::Lowest()) {\n                    result \u003d e;\n                } else {\n                    result \u003d NumberT{std::abs(e)};\n                }\n            } else {\n                result \u003d NumberT{std::abs(e)};\n            }\n```",
      "parentUuid": "2c667c21_fdb7a8e2",
      "range": {
        "startLine": 1580,
        "startChar": 27,
        "endLine": 1580,
        "endChar": 83
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "398c713b_9946cc61",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1580,
      "author": {
        "id": 1000257
      },
      "writtenOn": "2022-11-03T13:37:25Z",
      "side": 1,
      "message": "Except the code worked, and returned i32::min when i32::min was provided. Either way, Antonio re-wrote it as we don\u0027t understand why this is allowed by the compiler.",
      "parentUuid": "2c667c21_fdb7a8e2",
      "range": {
        "startLine": 1580,
        "startChar": 27,
        "endLine": 1580,
        "endChar": 83
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a0bade7_eddf83dd",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1580,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-11-03T13:41:19Z",
      "side": 1,
      "message": "It\u0027s odd that it worked - on all compilers too. Changing the previous condition to `IsSignedIntegral\u003cNumberT\u003e` resulted in the compiler complaining that \u0027e \u003d\u003d std::numeric_limits\u003cNumberT\u003e::min()` is not a constant expression... which is what it should have done before. Very weird.",
      "parentUuid": "398c713b_9946cc61",
      "range": {
        "startLine": 1580,
        "startChar": 27,
        "endLine": 1580,
        "endChar": 83
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a54e055_455441b1",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1581,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-11-03T12:18:14Z",
      "side": 1,
      "message": "Uou can use `e \u003d\u003d NumberT::Smallest()`",
      "range": {
        "startLine": 1581,
        "startChar": 27,
        "endLine": 1581,
        "endChar": 67
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ef23ecc_c20dc60b",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1581,
      "author": {
        "id": 1000257
      },
      "writtenOn": "2022-11-03T12:50:49Z",
      "side": 1,
      "message": "Lowest I think, Smallest appears to be 0 for integral types.",
      "parentUuid": "2a54e055_455441b1",
      "range": {
        "startLine": 1581,
        "startChar": 27,
        "endLine": 1581,
        "endChar": 67
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4e7b8be_17022633",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1581,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-11-03T13:34:22Z",
      "side": 1,
      "message": "Yeah, I suggested Smallest because you used min(), but I think you\u0027re right:\n\n```\n    /// Lowest finite representable value of this type.\n    static constexpr type kLowestValue \u003d std::numeric_limits\u003ctype\u003e::lowest();\n\n    /// Smallest positive normal value of this type.\n    static constexpr type kSmallestValue \u003d\n        std::is_integral_v\u003ctype\u003e ? 0 : std::numeric_limits\u003ctype\u003e::min();\n```",
      "parentUuid": "8ef23ecc_c20dc60b",
      "range": {
        "startLine": 1581,
        "startChar": 27,
        "endLine": 1581,
        "endChar": 67
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "25c475e0_f732eac5",
        "filename": "src/tint/resolver/const_eval.cc",
        "patchSetId": 4
      },
      "lineNbr": 1581,
      "author": {
        "id": 1000257
      },
      "writtenOn": "2022-11-03T13:37:25Z",
      "side": 1,
      "message": "Yes, min was an error because c++ is weird.",
      "parentUuid": "f4e7b8be_17022633",
      "range": {
        "startLine": 1581,
        "startChar": 27,
        "endLine": 1581,
        "endChar": 67
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1caee147_6f0fd5c7",
        "filename": "src/tint/resolver/const_eval_builtin_test.cc",
        "patchSetId": 4
      },
      "lineNbr": 162,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-11-03T12:18:14Z",
      "side": 1,
      "message": "This is why I added the `Negate` helper (see const_eval_test.h). This lets you write your tests in one function without getting warnings/errors from the compiler.",
      "range": {
        "startLine": 162,
        "startChar": 34,
        "endLine": 162,
        "endChar": 86
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f0700f98_01226494",
        "filename": "src/tint/resolver/const_eval_builtin_test.cc",
        "patchSetId": 4
      },
      "lineNbr": 162,
      "author": {
        "id": 1000257
      },
      "writtenOn": "2022-11-03T12:50:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1caee147_6f0fd5c7",
      "range": {
        "startLine": 162,
        "startChar": 34,
        "endLine": 162,
        "endChar": 86
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22913f74_0603d78d",
        "filename": "src/tint/resolver/const_eval_builtin_test.cc",
        "patchSetId": 4
      },
      "lineNbr": 183,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-11-03T12:19:30Z",
      "side": 1,
      "message": "Please also make these non-vector cases above. Easier to understand if the scalar case fails that it has to do with the value, and not the vectorizing.",
      "range": {
        "startLine": 183,
        "startChar": 22,
        "endLine": 183,
        "endChar": 35
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "78292904_4a5429ea",
        "filename": "src/tint/resolver/const_eval_builtin_test.cc",
        "patchSetId": 4
      },
      "lineNbr": 183,
      "author": {
        "id": 1000257
      },
      "writtenOn": "2022-11-03T12:50:49Z",
      "side": 1,
      "message": "Done. Altough I just look at the first one error ignoring if it\u0027s vec or not.",
      "parentUuid": "22913f74_0603d78d",
      "range": {
        "startLine": 183,
        "startChar": 22,
        "endLine": 183,
        "endChar": 35
      },
      "revId": "a347ed5dcc2a64218cff07130b941a05f198e945",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}