{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3d6373c9_7738d3dc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004191
      },
      "writtenOn": "2024-06-10T17:18:11Z",
      "side": 1,
      "message": "This fully fixes `bundle_libraries` to traverse both private and public dependencies.",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0780faae_f09e3404",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-10T18:13:54Z",
      "side": 1,
      "message": "Great fix! LGTM. Jim PTAL",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "280a0d4b_e9561b05",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004846
      },
      "writtenOn": "2024-06-10T19:06:09Z",
      "side": 1,
      "message": "Are the missing symbols only happening since https://dawn-review.googlesource.com/c/dawn/+/192561 ?\n\nWhen I tried this approach it nearly doubled the number of object files included in the bundle, many of which were not practically required.\n\nCan you measure the number of files in the bundle before and after these pairs of CLs?",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5e887489_6b6a3ac8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004846
      },
      "writtenOn": "2024-06-10T19:13:14Z",
      "side": 1,
      "message": "LINK_LIBRARIES should be sufficient as the network is traversed recursively. I think this only fixes the absl::raw_hash_set issue as a side-effect, and the cost is many unnecessary other files going into the bundle.",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "452a0434_d65e3282",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004191
      },
      "writtenOn": "2024-06-10T19:25:44Z",
      "side": 1,
      "message": "The symbols from raw_hash_set were missing even before that. `raw_hash_set` was forcefully added on the link list. About the other extra symbols, they never turned up most likely because they don\u0027t have external linkage.\n\nHere\u0027s the diff -\n```\ndiff no-interface-link.list interface-link.list \n1c1\n\u003c webgpu_c_bundled depends on 88 objects\n---\n\u003e webgpu_c_bundled depends on 116 objects\n2a3,4\n\u003e absl_bad_optional_access\n\u003e absl_bad_variant_access\n3a6,22\n\u003e absl_city\n\u003e absl_civil_time\n\u003e absl_cord\n\u003e absl_cord_internal\n\u003e absl_cordz_functions\n\u003e absl_cordz_handle\n\u003e absl_cordz_info\n\u003e absl_crc_cord_state\n\u003e absl_crc_cpu_detect\n\u003e absl_crc_internal\n\u003e absl_crc32c\n\u003e absl_debugging_internal\n\u003e absl_demangle_internal\n\u003e absl_exponential_biased\n\u003e absl_graphcycles_internal\n\u003e absl_hash\n\u003e absl_hashtablez_sampler\n4a24\n\u003e absl_kernel_timeout_internal\n5a26,28\n\u003e absl_low_level_hash\n\u003e absl_malloc_internal\n\u003e absl_raw_hash_set\n7a31,32\n\u003e absl_stacktrace\n\u003e absl_str_format_internal\n10a36,37\n\u003e absl_symbolize\n\u003e absl_synchronization\n11a39,40\n\u003e absl_time\n\u003e absl_time_zone\n```\n\nYou can repro by using this snippet before adding the objects to the bundle in `BundleLibraries.cmake`\n\n```\n  message(STATUS \"${output_target} depends on ${number_of_objects} objects\")\n  foreach(object IN LISTS all_objects)\n    set(FILTER_STRING \"${object}\")\n    string(REGEX MATCH \"\\\\$\u003cTARGET_OBJECTS:([^\u003e]+)\u003e\" OBJECT_NAME ${FILTER_STRING})\n    if (CMAKE_MATCH_1)\n      message(STATUS \"${CMAKE_MATCH_1}\")\n    endif()\n  endforeach()\n```",
      "parentUuid": "280a0d4b_e9561b05",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "487600f2_d55d4971",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004846
      },
      "writtenOn": "2024-06-10T19:30:13Z",
      "side": 1,
      "message": "absl_hash ought to be included without traversing INTERFACE_LINK_LIBRARIES, and these other symbols are not required in our library. We don\u0027t want the transitory links in the bundle. This isn\u0027t the right fix for the absl_hash issue sadly.",
      "parentUuid": "452a0434_d65e3282",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32997044_fa96716c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004191
      },
      "writtenOn": "2024-06-10T19:35:09Z",
      "side": 1,
      "message": "makes sense, it does increase the bundle size by 593 KB. Here\u0027s the demangled symbols from `absl::raw_hash_set` that were undefined. Hoping someone knowledgeable about `abseil` knows what\u0027s up.\n\n```\nabsl::hash_internal::MixingHashState::LowLevelHashImpl(unsigned char const*, unsigned long)\nabsl::hash_internal::MixingHashState::CombineLargeContiguousImpl64(unsigned long, unsigned char const*, unsigned long)\nabsl::hash_internal::MixingHashState::kSeed\nabsl::container_internal::kEmptyGroup\nabsl::container_internal::kSooControl\nabsl::container_internal::EraseMetaOnly(absl::container_internal::CommonFields\u0026, unsigned long, unsigned long)\nabsl::container_internal::ClearBackingArray(absl::container_internal::CommonFields\u0026, absl::container_internal::PolicyFunctions const\u0026, bool, bool)\nabsl::container_internal::HashSetResizeHelper::TransferSlotAfterSoo(absl::container_internal::CommonFields\u0026, unsigned long)\nabsl::container_internal::HashSetResizeHelper::InitControlBytesAfterSoo(absl::container_internal::ctrl_t*, absl::container_internal::ctrl_t, unsigned long)\nabsl::container_internal::HashSetResizeHelper::GrowSizeIntoSingleGroupTransferable(absl::container_internal::CommonFields\u0026, unsigned long)\nabsl::container_internal::PrepareInsertAfterSoo(unsigned long, unsigned long, absl::container_internal::CommonFields\u0026)\nabsl::container_internal::DropDeletesWithoutResize(absl::container_internal::CommonFields\u0026, void const*, absl::container_internal::PolicyFunctions const\u0026, void*)\nabsl::container_internal::find_first_non_full_outofline(absl::container_internal::CommonFields const\u0026, unsigned long)\nabsl::container_internal::HashSetResizeHelper::GrowIntoSingleGroupShuffleControlBytes(absl::container_internal::ctrl_t*, unsigned long) const\n```",
      "parentUuid": "487600f2_d55d4971",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5058558_497dbe3d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004846
      },
      "writtenOn": "2024-06-10T19:43:18Z",
      "side": 1,
      "message": "Thanks for your understanding. I did already spend a few days (!) trying to understand this issue and I did try the INTERFACE_LINK_LIBRARIES method but (1) wasn\u0027t convinced it should be needed and (2) noted the increase in the library size (which we are working hard to keep low). Still I couldn\u0027t explain the missing absl symbols, hence my workaround.",
      "parentUuid": "32997044_fa96716c",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1945a331_d00fd3b3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-10T20:40:54Z",
      "side": 1,
      "message": "Would it be possible to have a dump of the graph as BundleLibraries is adding them with both the source and destination of edges (as well as the type of the edge)? We\u0027d get to know why all those additional absl libs are added.\n\nIMHO we could take this for now, just to have a complete lib and keep iterating to reduce the number of libs included. We don\u0027t ship on Android using CMake yet so a temporary 500kb too much is fine.",
      "parentUuid": "d5058558_497dbe3d",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3ba8831_78897e9c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004846
      },
      "writtenOn": "2024-06-10T20:59:29Z",
      "side": 1,
      "message": "I recall analyzing the graph, I can\u0027t remember my findings, I can repeat my experiments.\n\nOne reason to take this patch would be that it looks neat and appears to solve the issue without a hack. However, I believe that (counter-intuitively) it is a disguised way to get the missing dependency into the graph.",
      "parentUuid": "1945a331_d00fd3b3",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aab3c93c_aa2d2c8d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004846
      },
      "writtenOn": "2024-06-10T21:14:25Z",
      "side": 1,
      "message": "OK I found the diagram I built from (if I recall correctly) the LINK_LIBRARIES links.\n\nhttps://drive.google.com/file/d/1giK-1bHnbW0-LKgeI_ASVU1SIDkYLw-k/view?usp\u003ddrive_link\n\nIt\u0027s huge so you might have to download it to view it properly.\n\nIt\u0027s a graph rendered as a tree, where you see a node (in brackets) it means that it has already been represented above it in the tree.",
      "parentUuid": "f3ba8831_78897e9c",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48596094_66de9221",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004191
      },
      "writtenOn": "2024-06-10T21:26:53Z",
      "side": 1,
      "message": "The link shows access denied.\n\nI made my own here -\u003e https://pastebin.com/mrkT11pG\n\nEDGE_TYPE:\n-\u003e LINK_LIBRARY\n\u003d\u003e INTERFACE_LINK_LIBRARY\n\n* prefix means already processed.\n\nI wonder if we ignoring deps from LINK_LIBRARIES of targets that were INTERFACE_LINK_LIBRARIES could help.",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa868c80_e79e9076",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004191
      },
      "writtenOn": "2024-06-10T21:27:31Z",
      "side": 1,
      "message": "`* prefix` implies the target is already processed",
      "parentUuid": "48596094_66de9221",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34b79863_64d12c96",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-11T08:33:28Z",
      "side": 1,
      "message": "Looking at the tree provided, it kind of makes sense, hashmap_default_functions\u0027s interface requires cords, which has a mutex and requires all of synchronization. So the addition of `INTERFACE_LINK_LIBRARIES` is needed for correctness, and if we don\u0027t do this CL, in the future we risk adding an absl dependency (or roll a version) that requires another manual inclusion of an internal target.\n\nUltimately if we don\u0027t end up using the timezone data for example, the linker should be able to remove it at link time. There are compiler options to separate every symbol in its own section `-ffunction-sections -fdata-sections` and then remove unused sections: `--gc-sections`. Does it help mitigate the binary size increase?\n\nIn general let\u0027s do the correct thing first and then optimize (things like binary size) second. If we start adding slightly hacky patches at the start of project we\u0027ll never stop doing it.",
      "parentUuid": "fa868c80_e79e9076",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13a14e82_2aef58d2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004846
      },
      "writtenOn": "2024-06-11T09:42:26Z",
      "side": 1,
      "message": "\u003e ashmap_default_functions\u0027s interface requires cords\n\nDo you know why in this case the dependency is not stated with `LINK_LIBRARIES` rather than being set by `INTERFACE_LINK_LIBRARIES`?\n\nMy current understanding of `INTERFACE_LINK_LIBRARIES` is that it effectively states \u0027a references b but we\u0027re not supplying b, clients should do that themselves\u0027, Which is what adding `absl::raw_hash_set` explicitly does.",
      "parentUuid": "fa868c80_e79e9076",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1871aa2e_3d8c1962",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-11T10:09:19Z",
      "side": 1,
      "message": "In general `INTERFACE_LINK_LIBRARIES` are the libraries needed to use the headers. They mean that the dependency needs to be propagated up the dependency chain for example to find include directories, have the correct defines, etc. They are transitive properties https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#transitive-link-properties\n\nMaybe abseil shouldn\u0027t require linking against absl::cords but just access to its headers (or better use SFINAE to avoid the need to access the headers) but that would be an upstream fix.",
      "parentUuid": "13a14e82_2aef58d2",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f0945c6_d429b392",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1004191
      },
      "writtenOn": "2024-06-11T12:48:32Z",
      "side": 1,
      "message": "Well, now it seems like this CL is a more correct solution that prevents future mishaps. I\u0027ll leave both of my CLs open for discussion, no rush to merge 😊\n\nBtw, we typically use PIMPL to avoid transitory bloat of this kind.",
      "parentUuid": "1871aa2e_3d8c1962",
      "revId": "c35e6b6f090bfd527bbef495d1eb1fb95ef45dca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}