{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "637eba30_6ede6433",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-16T00:18:47Z",
      "side": 1,
      "message": "Passes CQ, but there\u0027s some concurrency questions I want to make sure I understood correctly?",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7619342c_bedba72c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-09-18T15:22:43Z",
      "side": 1,
      "message": "LGTM",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ef5fb2d_bd8cfccc",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-09-18T15:22:43Z",
      "side": 1,
      "message": "u-nit: Maybe we could change these to take an std::span?",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b84f3b2a_5ea9447d",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-18T23:27:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9ef5fb2d_bd8cfccc",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff676b1f_1f292022",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 144,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-09-18T15:22:43Z",
      "side": 1,
      "message": "Maybe detail a bit more that we can \"spontaneously\" trigger events here (is this called regularly? Are there other places where events could be called spontaneously?)",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b9ea12da_19d67fa4",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 144,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-18T23:27:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ff676b1f_1f292022",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a969992_c60878f1",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-16T00:18:47Z",
      "side": 1,
      "message": "This might be contingent on how we want to handle cases where users are either:\n(1) calling `WaitAny` concurrently with the same Future\n(2) calling `WaitAny` concurrently with a `ProcessEvents`\n\nBasically, in those cases, it\u0027s possible that we end up calling `WaitImpl` on the same `AllowProcessEvents` or `AllowSpontaneous` future. Two possible cases highlighted below\n\nCase 1\nt1: `WaitAny(Timeout)` acquires `mTracker` lock and populates `futures` with `e1`\nt2: `WaitAny(Spin)` acquires `mTracker` lock and populates `futures` with `e1`\nt1: `WaitAny(Timeout)` calls `WaitImpl` which `e1` successfully finishes in.\nt2: `WaitAny(Spin)` calls `WaitImpl`... (Does this hang? Naively it looks like `SystemEventReceiver` doesn\u0027t cache anything but it doesn\u0027t reset so I\u0027m not entirely sure I understand what happens here?)\n\nCase 2\nt1: `WaitAny(Spin)` acquires `mTracker` lock and populates `futures` with `e1`\nt2: `ProcessEvents` acquires `mTracker` lock, populates `futures` with `e1`, and finishes it.\nt1: `WaitAny(Spin)` calls `WaitImpl`... ^Same situation as above.",
      "range": {
        "startLine": 199,
        "startChar": 4,
        "endLine": 200,
        "endChar": 96
      },
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a874a51f_d1c2061f",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-09-18T15:22:43Z",
      "side": 1,
      "message": "My understanding is that the underlying FD / HANDLE stays signaled so there is no issue. However the WaitRef being used outside the lock means that two waitref could be created at the same time on the same future. I\u0027m not sure how to avoid this without putting a big lock around all WaitAnyImpl calls.",
      "parentUuid": "4a969992_c60878f1",
      "range": {
        "startLine": 199,
        "startChar": 4,
        "endLine": 200,
        "endChar": 96
      },
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e65e76fd_a74f5a1b",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-18T20:38:16Z",
      "side": 1,
      "message": "Hmm that\u0027s what I assumed also, but when I look at the implementation of `WaitAnyImpl` and `WaitAnySystemEvent` I don\u0027t see how/where they are checking if the signal happened already? Are we assuming / is it common knowledge (that I am not aware of) that the system level FD / HANDLE will always immediately report signaled on a second call, i.e. `poll` on an invalid FD immediately reports signaled?\n\nLooking it up online it seems like `poll` would likely trigger both waiting threads (idk about Windows) if they are already both waiting. Idk what happens if one starts waiting, the `poll` succeeds, then another thread tries to wait on it again though.",
      "parentUuid": "a874a51f_d1c2061f",
      "range": {
        "startLine": 199,
        "startChar": 4,
        "endLine": 200,
        "endChar": 96
      },
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ccfccb5_9d66d28c",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-18T23:27:16Z",
      "side": 1,
      "message": "Assuming what you said though, I (1) added some documentation about the `WaitRef`, and (2) changed `ProcessEvents` to use a specialized lock instead of overloading the `mEvents` lock which I **think** means we shouldn\u0027t have problems with having to deal with stacked timeouts anymore.",
      "parentUuid": "e65e76fd_a74f5a1b",
      "range": {
        "startLine": 199,
        "startChar": 4,
        "endLine": 200,
        "endChar": 96
      },
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9c289c3_2d631c45",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-09-19T12:29:36Z",
      "side": 1,
      "message": "On posix poll will return if any of the FDs has bytes to read but doesn\u0027t read them, so polling multiple times on the same FD should be ok. The FDs should still be valid as they are only destroyed when the events are removed from the map? However there is no such thing as \"invalid FD\" in a multithreaded environment because a race could cause the same FD to be reused for something else. So here my understanding is that we need to make (gathering of the FD + WaitImpl) atomic with respect to the deletion of FDs. Otherwise a race could make an FD reused between the two. I don\u0027t know how to do that without either 1) duping each FD we\u0027re going to poll() on while in a critical section and then doing the poll() or 2) doing the gather + the poll() in a critical section.\n\nTo unblock, could we add a big TODO and see later?",
      "parentUuid": "5ccfccb5_9d66d28c",
      "range": {
        "startLine": 199,
        "startChar": 4,
        "endLine": 200,
        "endChar": 96
      },
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b9ee84ac_f840f01f",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 200,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-19T23:55:26Z",
      "side": 1,
      "message": "Ah, you\u0027re right about the FD\u0027s only becoming invalid when the event is removed from the map.\n\nRegarding duplicated FDs, from here: https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_14 under section 2.14, it seems like they are atomically allocated so maybe overall this is a no-op. Since there\u0027s no immediate issue, I won\u0027t bother with a TODO for now. Will close this thread to unblock and continue progress. Thanks!",
      "parentUuid": "e9c289c3_2d631c45",
      "range": {
        "startLine": 199,
        "startChar": 4,
        "endLine": 200,
        "endChar": 96
      },
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e605d1b_3fe75ab8",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 213,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-09-18T15:22:43Z",
      "side": 1,
      "message": "It\u0027s a bit unfortunate that we need to look up the futures in multiple maps repeatedly. This is to just be to separate the futures that can only be triggered in waitAny from the other ones so why do we need the third map? Also maybe we could just iterate all futures in ProcessPollEvents or alternatively have a map of all futures and a set of the processPollEventable futureIDs (then when we remove them we can also remove the id from the set).",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "507e4d68_d6e1b8a8",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 2
      },
      "lineNbr": 213,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-18T23:27:16Z",
      "side": 1,
      "message": "Hmm, I consolidated it into 1 map. I think iterating it all on `ProcessEvents` didn\u0027t seem too bad.",
      "parentUuid": "1e605d1b_3fe75ab8",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4ac6936_bb60a149",
        "filename": "src/dawn/native/EventManager.h",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-09-18T15:22:43Z",
      "side": 1,
      "message": "nit: used by WaitAny and ProcessEvents",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca52666f_9ae898e0",
        "filename": "src/dawn/native/EventManager.h",
        "patchSetId": 2
      },
      "lineNbr": 75,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-09-18T23:27:16Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "b4ac6936_bb60a149",
      "revId": "66f52fc6f06f1fd19bf908130dbb5bd3be316c47",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}