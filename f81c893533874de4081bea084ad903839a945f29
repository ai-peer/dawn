{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a2d3dab2_54b1255e",
        "filename": "src/dawn/tests/end2end/DepthStencilCopyTests.cpp",
        "patchSetId": 15
      },
      "lineNbr": 686,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-10T20:50:21Z",
      "side": 1,
      "message": "is it necessary to make the size larger?\n\nI think we need to also test the case where the copy touches the last byte in the buffer. This could be a problem because it effectively means the buffer size internally needs to be padded to be padded AND we need to be able to read/write to the padding. Consider the case where you have a 3x3 copy region, so the last texel is inside the buffer, but because we read/write a u32, half of the u32 is actually outside the buffer.",
      "range": {
        "startLine": 686,
        "startChar": 0,
        "endLine": 686,
        "endChar": 80
      },
      "revId": "f81c893533874de4081bea084ad903839a945f29",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2e0f547_e16eddb1",
        "filename": "src/dawn/tests/end2end/DepthStencilCopyTests.cpp",
        "patchSetId": 15
      },
      "lineNbr": 686,
      "author": {
        "id": 1000685
      },
      "writtenOn": "2023-05-10T22:03:36Z",
      "side": 1,
      "message": "Modified the extra size \u003d {0, 4}.\n\nThe `buffer size needs to padded` problem basically needs us to create buffer size that is multiple of 2 byte but not multiple of 4 byte. There\u0027s a lot of restrictions keeping us of getting there.\n- size when mappedAtCreation\u003dtrue (or writeBuffer) for initializing content\n- size for mapAsync (or copyBufferToBuffer) for checking content\n\nWithout checking result, for test case width \u003d 3, height \u003d 1, buffer.size \u003d 6. (we cannot have width\u003d1, height\u003d1, buffer.size\u003d2 as there\u0027s min storage buffer size restrictions) It seems to run fine. Because opengl don\u0027t check buffer bounds?",
      "parentUuid": "a2d3dab2_54b1255e",
      "range": {
        "startLine": 686,
        "startChar": 0,
        "endLine": 686,
        "endChar": 80
      },
      "revId": "f81c893533874de4081bea084ad903839a945f29",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9ae3122_3d276d15",
        "filename": "src/dawn/tests/end2end/DepthStencilCopyTests.cpp",
        "patchSetId": 15
      },
      "lineNbr": 686,
      "author": {
        "id": 1000685
      },
      "writtenOn": "2023-05-10T23:41:38Z",
      "side": 1,
      "message": "Turns out `tintOptions.disable_robustness \u003d true;` for ShaderModuleGL.\n\nWe discussed 2 workaround for the `buffer size needs to be padded` issue offline:\n\n1. make an intermediate buffer that\u0027s aligned for 4-bytes for the corner case, do a buffer to buffer copy afterwards. (Later I realize as it requires copyBufferToBuffer, still the size needs to be multiple of 4 so this won\u0027t work)\n\n2. Make the mAllocationSize for BufferGL to align by 4 bytes. This needs to bindgroup to use the mAllocationSize instead and other changes (I cannot recall completely, can you add some pointers here?\n\n~~But the current tests seem to work fine after the alignment without other changes. I saw mAllocationSize aligns for 4 byte only for vulkan backend for now but don\u0027t see many places referencing it.~~)",
      "parentUuid": "d2e0f547_e16eddb1",
      "range": {
        "startLine": 686,
        "startChar": 0,
        "endLine": 686,
        "endChar": 80
      },
      "revId": "f81c893533874de4081bea084ad903839a945f29",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5feae22f_aea5b9f4",
        "filename": "src/dawn/tests/end2end/DepthStencilCopyTests.cpp",
        "patchSetId": 15
      },
      "lineNbr": 686,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-11T17:21:04Z",
      "side": 1,
      "message": "option (2) would maybe need to somehow use the larger internal size in `ValidateBufferBinding` as well as store the larger internal size in the [buffer binding data](https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:third_party/dawn/src/dawn/native/BindGroup.cpp;l\u003d397;drc\u003d68d2af39d3897338e231b24fb358dce0246c3ff5;bpv\u003d1;bpt\u003d1).\n\nseems a lot harder than option (1) because there\u0027s a lot of places we would need to surface the \"internal size\".\n\noption (1) copyBufferToBuffer requires 4-byte alignment, but I was thinking we could perform a single targeted glCopyBufferSubData which hopefully won\u0027t have the same 4-byte restriction. And, if it does, we can still pad out mAllocationSize and use the larger size in this internal copy.",
      "parentUuid": "e9ae3122_3d276d15",
      "range": {
        "startLine": 686,
        "startChar": 0,
        "endLine": 686,
        "endChar": 80
      },
      "revId": "f81c893533874de4081bea084ad903839a945f29",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}