{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bfafd37c_3781fa04",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-21T23:35:08Z",
      "side": 1,
      "message": "PTAL!",
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5dcea1a_c3f0ce71",
        "filename": "src/dawn_native/ComputePipeline.cpp",
        "patchSetId": 6
      },
      "lineNbr": 45,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-22T05:14:06Z",
      "side": 1,
      "message": "we should have a way to hash on the blueprint, and then pass the blueprint hash into the object creation the obj isn\u0027t found in the cache. That way we don\u0027t need to hash both the blueprint and the real object. That\u0027s an optimization that\u0027s not necessary for this CL though.",
      "range": {
        "startLine": 44,
        "startChar": 8,
        "endLine": 45,
        "endChar": 36
      },
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4fafb05_cacb32e2",
        "filename": "src/dawn_native/FingerprintRecorder.cpp",
        "patchSetId": 6
      },
      "lineNbr": 22,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-22T16:46:45Z",
      "side": 1,
      "message": "[1]",
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9861d63_0da74a00",
        "filename": "src/dawn_native/FingerprintRecorder.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-22T05:06:41Z",
      "side": 1,
      "message": "nit: methods should start with a capital letter.\n\nhigh level, I like the structure of my prototype in https://godbolt.org/z/8q9eW9 better if we can get that to work. It lets you pass in a struct which implements the visitor functionality so it can be customized for different types of traversals.\n\nThere\u0027s a few downsides to the current approach:\n - the equality function now walks the entire object tree - this is suboptimal if it can return early\n - the equality function is now effectively comparing hashes - which means our equality check is wrong if there are hash collisions\n - I don\u0027t immediately see how this is extendable to serialization",
      "range": {
        "startLine": 24,
        "startChar": 5,
        "endLine": 47,
        "endChar": 25
      },
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7e11b05_b6d5684d",
        "filename": "src/dawn_native/FingerprintRecorder.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-22T16:46:45Z",
      "side": 1,
      "message": "\u003e  so it can be customized for different types of traversals.\n\nThanks for the snippet. That approach is good for whole object serialization but not for fast lookup, which I don\u0027t believe requires multiple walks or copies as suggested.\n\n\u003e the equality function now walks the entire object\n\nOnce the hash is recorded, no traversal is needed [1].\n\n\u003e equality check is wrong if there are hash collisions\n\nI use a hash because lookup needs to be fast and collisions are not consequential.\n\n\u003e I don\u0027t immediately see how this is extendable to serialization\n\nThis is for lookup only, so I didn\u0027t see any need for serialization.",
      "parentUuid": "b9861d63_0da74a00",
      "range": {
        "startLine": 24,
        "startChar": 5,
        "endLine": 47,
        "endChar": 25
      },
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "501acd61_9d5ddb0e",
        "filename": "src/dawn_native/FingerprintRecorder.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-22T16:49:20Z",
      "side": 1,
      "message": "Okay we need to support three things: real equality, hashing, and serialization.\n\nYou\u0027re right we should still have the hash for fast lookup, but we need a real infallible equality check as well. std::unordered_* works by first hashing, and if they hash the same, it does an equality check. That\u0027s why we need to support both.\n\nSerialization we will need in the future to pass serialized blobs to the embedder.",
      "parentUuid": "a7e11b05_b6d5684d",
      "range": {
        "startLine": 24,
        "startChar": 5,
        "endLine": 47,
        "endChar": 25
      },
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7480bd00_bdf1440f",
        "filename": "src/dawn_native/FingerprintRecorder.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-22T17:11:33Z",
      "side": 1,
      "message": "\u003e need a real infallible equality\n\nAny collision is not only rare but well defined. Either rendering is wrong or it errors. Even if we have reasons, why not keep the same equal checks or strengthen the real hash without forcing full serialization?\n\n\u003e  pass serialized blobs to the embedder\n\nVK/D3D driver already serializes blobs for you. Don\u0027t think it\u0027s needed unless we roll our own pipeline library.",
      "parentUuid": "501acd61_9d5ddb0e",
      "range": {
        "startLine": 24,
        "startChar": 5,
        "endLine": 47,
        "endChar": 25
      },
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "895f7b03_548c1ca6",
        "filename": "src/dawn_native/FingerprintRecorder.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-22T17:16:43Z",
      "side": 1,
      "message": "\u003e Any collision is not only rare but well defined. Either rendering is wrong or it errors. Even if we have reasons, why not keep the same equal checks or strengthen the real hash without forcing full serialization?\n\nstrongly disagree with this. We use these hash maps for object deduplication. Getting the wrong object and wrong rendering is very, very bad. If I can inject a script into the page which collides with an existing pipeline, provides the same bindings to pass validation, and draws a fullscreen quad that tells the user to send bitcoin to some address - this is bad.\n\nWe do not have to fully serialize to do comparison checks. The visitor returns early once it finds an inequality.\n\n\u003e  pass serialized blobs to the embedder\n\nThis is for the key, not for the value. The embedder will do the crypto hash of the key instead of Dawn.",
      "parentUuid": "7480bd00_bdf1440f",
      "range": {
        "startLine": 24,
        "startChar": 5,
        "endLine": 47,
        "endChar": 25
      },
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2dc1fcc2_6a9be4a6",
        "filename": "src/dawn_native/FingerprintRecorder.h",
        "patchSetId": 6
      },
      "lineNbr": 47,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-22T18:02:49Z",
      "side": 1,
      "message": "Using the example, what stops the injected script from using a new (malicious) pipeline? If so, the strength of the equal check does not matter so this situation makes no sense to me.\n\n\u003e The visitor returns early once it finds an inequality.\n\nYea, can do the same w/o a hash here (via CompareVisitor) - SGTM.\n\n\u003e This is for the key, not for the value\n\nBelieve this assumes we will always be caching individual pipelines (correct me if wrong) which I\u0027m not proposing here (and probably not a good idea).",
      "parentUuid": "895f7b03_548c1ca6",
      "range": {
        "startLine": 24,
        "startChar": 5,
        "endLine": 47,
        "endChar": 25
      },
      "revId": "a8eccdaac7c8aa6c8f7c3eaa6f138f87b4a51968",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}