{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "db3f7b21_4b188407",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-01-07T00:59:53Z",
      "side": 1,
      "message": "This is what I had in mind about scoping keyed mutex acquire/release more tightly.\n\nOne thing that\u0027s not immediately clear is if it\u0027s guaranteed that all external textures (D3D11on12) used in a pass/pipeline will be added to the recording context\u0027s shared texture list. AddToSharedTextureList is called in TrackUsageAndGetResourceBarrierForPass, so I\u0027m guessing that it should be guaranteed?",
      "revId": "8bd2e383bc42f2ce136b0872e67c0f9d14aba5ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ce84190_bbfe9c19",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-01-07T13:01:03Z",
      "side": 1,
      "message": "LGTM, although I think it might be more scalable to go with a solution like CompositeSharedImage that does copies so that we have correctness everywhere. Here the Dawn and GL decoder will have to run in the same thread of have submissions be synchronized somehow to make this mechanism work correctly.",
      "revId": "8bd2e383bc42f2ce136b0872e67c0f9d14aba5ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5efbd8b_80bf345d",
        "filename": "src/dawn_native/d3d12/D3D11on12Util.h",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-01-07T13:01:03Z",
      "side": 1,
      "message": "nit: maybe use a uint64_t so that we\u0027re sure that it will never overflow?",
      "revId": "8bd2e383bc42f2ce136b0872e67c0f9d14aba5ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16812e8b_474648dc",
        "filename": "src/dawn_native/d3d12/D3D11on12Util.h",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-01-07T19:07:37Z",
      "side": 1,
      "message": "In general, we try to avoid unsigned types except when needed for bit-patterns or for interop with external APIs: https://google.github.io/styleguide/cppguide.html#Integer_Types\n\n\"You should not use the unsigned integer types such as uint32_t, unless there is a valid reason such as representing a bit pattern rather than a number, or you need defined overflow modulo 2^N. In particular, do not use unsigned types to say a number will never be negative. Instead, use assertions for this.\"\n\nIn this case making it unsigned would make the ASSERT(mAcquireCount \u003e\u003d 0) in AcquireKeyedMutex() a no-op although that ASSERT is strictly not needed due to the other one in ReleaseKeyedMutex().\n\nLet me know if you meant using a larger signed type instead like int64_t, but even that is a bit dubious since we don\u0027t allow that many textures in the first place, right?",
      "parentUuid": "b5efbd8b_80bf345d",
      "revId": "8bd2e383bc42f2ce136b0872e67c0f9d14aba5ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1e0c70a_c119880b",
        "filename": "src/dawn_native/d3d12/D3D11on12Util.h",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-01-10T08:32:21Z",
      "side": 1,
      "message": "Uh, I guess we completely missed this guideline. Ok for int64_t here if you want, and we\u0027ll have to see for the rest of Dawn.\n\nThe comment was more about using a wider integer type like you guessed because it seems possible to trigger an overflow: the texture is locked once for each time it is transitioned inside the command buffer. For example once per copy it is used it. While unlikely that a texture will be used 2B times, it is possible that a malicious web page might try to do that to causes crashes or other issues.",
      "parentUuid": "16812e8b_474648dc",
      "revId": "8bd2e383bc42f2ce136b0872e67c0f9d14aba5ea",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}