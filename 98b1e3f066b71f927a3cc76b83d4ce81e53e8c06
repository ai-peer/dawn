{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e4d41808_d7188c23",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-20T14:51:48Z",
      "side": 1,
      "message": "I\u0027m not sure I understand why we need to do this: we\u0027ll need WaitableEvent at some point most likely.\n\nFor example we could internally defer all ShaderModule creation and store in the immutable cache a WaitableEvent or a concrete ShaderModule. Then when we need to immediately create a pipeline with the module, we can steal the task if it is not started or wait on it if it is started. Stuff like that.",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6fdd5ff_f2f12fb8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-21T00:24:13Z",
      "side": 1,
      "message": "Here I just want to show you that using std::thread still cannot let us delete the std::thread object inside the async function, which is the core of Austin\u0027s proposal.\n\n\u003e  We\u0027ll need WaitableEvent at some point most likely\nIn Austin\u0027s proposal actually WaitableEvent is useless and it is wrong to call any member functions of WaitableEvent in the main thread because it can be deleted at any time in the sub-thread. However in my proposal WaitableEvent is always valid and we can use it to check the status of the sub-tasks, but it seems both of you don\u0027t like it.",
      "parentUuid": "e4d41808_d7188c23",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64271c33_ef67f9c0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-21T00:31:03Z",
      "side": 1,
      "message": "In my proposal, WaitableEvent is stored inside a refcounted Task object. The task holds a reference to it, and so does the TaskManager. So even if the subthread finishes, it will not be deleted because the TaskManager holds a reference to it.",
      "parentUuid": "c6fdd5ff_f2f12fb8",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a121b70_ce45049c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-20T08:22:07Z",
      "side": 1,
      "message": "Hi Corentin and Austin,\n\nAfter reading  some more code I found we can use thread.detach() to do all the async tasks (like CreatePipelineAsync) without saving any extra objects in the main thread. It seems with thread.detach(), the sub-thread where the function is executed asynchronously will be detached from the original std::thread object, and the sub-thread will be recycled by OS after the async function is completed. In main thread we can just maintain a counter of the total thread count, and wait for the counter to be 0 before shutting down.\n\nPTAL, thanks!",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21a5d6a9_b65e46fa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-20T08:34:17Z",
      "side": 1,
      "message": "I also found according to [1], for the destructor of std::thread, \"if *this has an associated thread (joinable() \u003d\u003d true), std::terminate() is called.\", so before the async function returns, the std::thread object will still be joinable, so we cannot delete the std::thread object inside the async function.\n\nA thread object does not have an associated thread (and is safe to destroy) after\n- it was default-constructed\n- it was moved from\n- join() has been called\n- detach() has been called\n\n[1] https://en.cppreference.com/w/cpp/thread/thread/~thread",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}