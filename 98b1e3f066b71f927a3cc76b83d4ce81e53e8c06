{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e4d41808_d7188c23",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-20T14:51:48Z",
      "side": 1,
      "message": "I\u0027m not sure I understand why we need to do this: we\u0027ll need WaitableEvent at some point most likely.\n\nFor example we could internally defer all ShaderModule creation and store in the immutable cache a WaitableEvent or a concrete ShaderModule. Then when we need to immediately create a pipeline with the module, we can steal the task if it is not started or wait on it if it is started. Stuff like that.",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6fdd5ff_f2f12fb8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-21T00:24:13Z",
      "side": 1,
      "message": "Here I just want to show you that using std::thread still cannot let us delete the std::thread object inside the async function, which is the core of Austin\u0027s proposal.\n\n\u003e  We\u0027ll need WaitableEvent at some point most likely\nIn Austin\u0027s proposal actually WaitableEvent is useless and it is wrong to call any member functions of WaitableEvent in the main thread because it can be deleted at any time in the sub-thread. However in my proposal WaitableEvent is always valid and we can use it to check the status of the sub-tasks, but it seems both of you don\u0027t like it.",
      "parentUuid": "e4d41808_d7188c23",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64271c33_ef67f9c0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-21T00:31:03Z",
      "side": 1,
      "message": "In my proposal, WaitableEvent is stored inside a refcounted Task object. The task holds a reference to it, and so does the TaskManager. So even if the subthread finishes, it will not be deleted because the TaskManager holds a reference to it.",
      "parentUuid": "c6fdd5ff_f2f12fb8",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bdbc4143_4f5153aa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-21T00:37:54Z",
      "side": 1,
      "message": "Oh maybe I am misunderstanding your proposal - don\u0027t you want to completely delete the Task object (and its WaitableEvent) at the end of the async function?\n\nIf so, then it cannot be done with std::thread;\nIf not, when do you clean up the Task object?",
      "parentUuid": "64271c33_ef67f9c0",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "221736b1_d7925f9f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-21T00:47:29Z",
      "side": 1,
      "message": "Maybe we can call to talk about it over video if you are free?\n\nI don\u0027t think we need to delete the Task object immediately at the end of the async function. I mostly want to remove it from the list of in-flight tasks when it completes. If there is another reference to the task, it will not be deleted. If this is the last reference, then yes, it will be deleted.\n\nI see your point about the destructor of std::thread, and my proposal is incorrect because std::thread is a member of AsyncWaitableEvent. We cannot destroy the event inside the async task. However, we can implement it another way with std::condition_variable, and use std::thread.detach() as you\u0027re doing here.",
      "parentUuid": "bdbc4143_4f5153aa",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9a121b70_ce45049c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-20T08:22:07Z",
      "side": 1,
      "message": "Hi Corentin and Austin,\n\nAfter reading  some more code I found we can use thread.detach() to do all the async tasks (like CreatePipelineAsync) without saving any extra objects in the main thread. It seems with thread.detach(), the sub-thread where the function is executed asynchronously will be detached from the original std::thread object, and the sub-thread will be recycled by OS after the async function is completed. In main thread we can just maintain a counter of the total thread count, and wait for the counter to be 0 before shutting down.\n\nPTAL, thanks!",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21a5d6a9_b65e46fa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-05-20T08:34:17Z",
      "side": 1,
      "message": "I also found according to [1], for the destructor of std::thread, \"if *this has an associated thread (joinable() \u003d\u003d true), std::terminate() is called.\", so before the async function returns, the std::thread object will still be joinable, so we cannot delete the std::thread object inside the async function.\n\nA thread object does not have an associated thread (and is safe to destroy) after\n- it was default-constructed\n- it was moved from\n- join() has been called\n- detach() has been called\n\n[1] https://en.cppreference.com/w/cpp/thread/thread/~thread",
      "revId": "98b1e3f066b71f927a3cc76b83d4ce81e53e8c06",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}