{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "517ce7e3_238ab5bd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-15T18:44:32Z",
      "side": 1,
      "message": "Yet another approach to address `device can be destroyed while Instance.APIProcessEvent() is being executed`.",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ab6cc58_582003c3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-16T21:29:15Z",
      "side": 1,
      "message": "I think I like this version best since it avoids the need for weak semantics. A few comments: \n - we should add tests\n - use RefCounted and Ref\u003c\u003e instead of shared_ptr. Similar reasons as to why shared_ptr is banned in Chromium.",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0793106f_08c4d5e9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-16T21:30:28Z",
      "side": 1,
      "message": "overall LGTM",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "77672608_60d3da20",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-17T05:56:49Z",
      "side": 1,
      "message": "What kind of tests do you suggest?\nWe already have a test that:\n- Drop the device\u0027s last external ref.\n- Call MapAsync.\n- Call Instance.ProcessEvents -\u003e the error callback is triggered.\n\nWe also have another test that:\n- Create 2 devices.\n- Instance.ProcessEvents:\n  - Drop 2nd device in 1st device callback.\n\nMultithreading tests are quite tricky to verify, not before we have thread safe API in the next CL. And the easiest way to verify it is having a TSAN bot.",
      "parentUuid": "3ab6cc58_582003c3",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0849b5f2_4dd70a4a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-17T07:31:30Z",
      "side": 1,
      "message": "Done changing shared_ptr to Ref.",
      "parentUuid": "77672608_60d3da20",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27c6ba59_03716dd9",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 337,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-16T22:58:32Z",
      "side": 1,
      "message": "when we replace this pointer, there could be another thread that is doing `GetCallbackTaskManager()-\u003eAddCallbackTask(...)`. That could either race or result in a use-after-free.\n\nwe could return the instance\u0027s manager from GetCallbackTaskManager()? and enforce everything goes though that? If we want to be very strict, you could hide direct access to it.\n\nsomething like?\n```\nclass Holder {\n public:\n  CallbackTaskManager* Get(DeviceBase* device) {\n    if (device-\u003eIsAlive()) {\n      return mManager.Get();\n    } else {\n      return device-\u003eGetAdapter()-\u003eGetInstance()-\u003eGetCallbackTaskManager();\n    }\n  }\n private:\n  Ref\u003cCallbackTaskManager\u003e mManager;\n};\n```",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c32dc69_eda86ef5",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 337,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-17T05:56:49Z",
      "side": 1,
      "message": "This shouldn\u0027t be possible. In the next CL, `WillDropLastExternalRef` is protected by a mutex. Other API objects\u0027 API methods will also be protected by a mutex. Which means there won\u0027t be any race condition between API Objects\u0027 device related methods and Device\u0027s methods itself.\n\nIf we want to be sure, we can insert an ASSERT in GetCallbackTaskManager() to check whether a mutex is held or not.\n\nThe issue that this CL trying to fix is a race condition between Device\u0027s dtor and Instance::ProcessEvents.",
      "parentUuid": "27c6ba59_03716dd9",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c1c5103_05dc76d7",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 337,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-17T06:13:09Z",
      "side": 1,
      "message": "\u003e we could return the instance\u0027s manager from GetCallbackTaskManager()\n\nAlso I tried this approach before. And felt it was too error-prone IMO. It\u0027s easy to make mistake and use `mCallbackTaskManager` directly in DeviceBase\u0027s internal code itself (after it is destroyed).\n\nUsing a `Holder` class with `Get` method you need to make sure `device-\u003eIsAlive` is protected by a mutex otherwise there would be a race condition where device\u0027s alive flag is being changed and some thread didn\u0027t see that the device is being destroyed. While this could work, it\u0027s the same as protecting anything Device\u0027s related by a mutex as mentioned above, so I think there is no additional protection this `Holder` class adds compare to just changing the pointer directly in `WillDropLastExternalRef` while it is already protected by a mutex.",
      "parentUuid": "4c32dc69_eda86ef5",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca9330a0_2ef57ed4",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 337,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-17T23:14:54Z",
      "side": 1,
      "message": "it\u0027s a race between `WillDropLastExternalRef` and Dawn\u0027s internal threads adding to the callback queue. `CreateComputePipelineAsyncTask::Run` will run on a Dawn internal thread, and then call  device-\u003eGetCallbackTaskManager()-\u003eAddCallbackTask.\n\nI guess we could make that acquire the device mutex as well, but IMO we\u0027re risking deadlock territory there. The eventual multithreading plan will be to have each independent service that needs to be thread-safe be individually synchronized. This could be a good place to start on that.\n\nInstead of acquiring the callback manager\u0027s lock inside one its methods, we could instead acquire a lock to even access the callback manager, and automatically acquire it on the `operator-\u003e() and operator*()`?\n\nIt would look something like `Synchronized\u003cRef\u003cCallbackTaskManager\u003e\u003e manager`\nand doing both:\n`*manager \u003d otherManager;`\nand \n`manager-\u003eAddCallbackTask(...)`\n\nwould grab a temporary lock for the duration of the operation.",
      "parentUuid": "0c1c5103_05dc76d7",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d24e5d8_a41f75c7",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 337,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-18T04:08:40Z",
      "side": 1,
      "message": "\u003e it\u0027s a race between WillDropLastExternalRef and Dawn\u0027s internal threads adding to the callback queue. CreateComputePipelineAsyncTask::Run will run on a Dawn internal thread, and then call device-\u003eGetCallbackTaskManager()-\u003eAddCallbackTask.\n\nThat makes sense. But I still think it\u0027s not possible to/shoudn\u0027t happen. Because inside `DeviceBase::Destroy()` we wait for all async tasks to complete before proceeding.\n\nAfterwards, any methods that would create async tasks, would have returned a `DeviceLost` error instead. The methods that create async tasks should be originated from public APIs which are synchronized with Device\u0027s methods?\n\nAre there any other cases that async tasks could still be run after the device is destroyed? If there is, I think that would be considered a bug instead of adding overhead just to defend against that. But maybe I miss something.\n\nMaybe I should add some tests to verify async tasks shouldn\u0027t be run after the device is destroyed?",
      "parentUuid": "ca9330a0_2ef57ed4",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0148232c_8a8821d7",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 337,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-18T05:00:54Z",
      "side": 1,
      "message": "\u003e Instead of acquiring the callback manager\u0027s lock inside one its methods, we could instead acquire a lock to even access the callback manager\n\nbtw, I don\u0027t think we could remove the callback manager\u0027s internal lock entirely.\nFor separate device\u0027s callback manager, it is fine to have an external lock owned by the device (or the wrapper class `Synchronized` owned by the device) to protect the queue.\n\nBut once the device is destroyed, it has to use instance\u0027s callback manager which is shared between multiple devices. The external lock owned by the device is no longer enough. Unless we share the instance\u0027s queue\u0027s lock with every device from the beginning which somewhat increase callbacks\u0027 contentions between them. Or create \"another lock to protect the lock\".\n\nIf the plan is eventually forwarding all callbacks to instance, and only instance\u0027s processEvents can trigger the callbacks. These approaches seem too convoluted as a near term plan.",
      "parentUuid": "3d24e5d8_a41f75c7",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bda88e09_aad40470",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 337,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-20T15:29:48Z",
      "side": 1,
      "message": "got it - I missed that we also wait for completion of all async tasks in WillDropLastExternalRef. So for now, this should be fine and not race.\nIn the future, I still think we\u0027re going to add some kind of synchronization here since it\u0027s not safe to rely on the invariant that async tasks always work this way.\n \nyes, we should add tests, or double-check tests exist for async pipeline creation, then dropping the last device ref.",
      "parentUuid": "0148232c_8a8821d7",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a63b2a68_9490d016",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 337,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-21T21:06:34Z",
      "side": 1,
      "message": "Done.\n\nThere are already existing tests for async pipeline creation, then dropping the last device ref (in `DeviceLifetimeTests`).\n\nHowever, since those async tasks might be too fast to verify that they won\u0027t extend to post device\u0027s dropping time, I have created new unittests that simulate long running async tasks and verify that dropping device should wait for them to finish.",
      "parentUuid": "bda88e09_aad40470",
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af405785_e6631075",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1816,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-16T21:30:28Z",
      "side": 1,
      "message": "nit: we don\u0027t need this now, and we can replace all uses with `mCallbackTaskManager-\u003eFlush();` (they are all in DeviceBase)",
      "range": {
        "startLine": 1816,
        "startChar": 5,
        "endLine": 1816,
        "endChar": 39
      },
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8ea69596_50cbf428",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1816,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-17T07:31:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "af405785_e6631075",
      "range": {
        "startLine": 1816,
        "startChar": 5,
        "endLine": 1816,
        "endChar": 39
      },
      "revId": "53a93fde228f416afbb55cf199b2bae2ca7b4bc2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}