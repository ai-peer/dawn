{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "90d1140e_b251065e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-07-08T19:15:29Z",
      "side": 1,
      "message": "PTAL",
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c45a8bf6_4283ee1f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-07-08T19:27:09Z",
      "side": 1,
      "message": "could you CC me (or us) on crbug.com/1338470 ?",
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e8a44b64_ee14e0ad",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-07-08T19:39:38Z",
      "side": 1,
      "message": "The D3D12 fence and resource passed into ExternalImageDXGI::Create are created by Chromium, right? So Dawn shouldn\u0027t be destroying them.\n\nWhich objects are owned by Dawn\u0027s d3d12::Device that are getting destroyed are touched by ExternalImageDXGI? is it D3D11on12ResourceCacheEntry::mDXGIKeyedMutex and D3D11on12ResourceCacheEntry::mD3D11on12Device ? ",
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "13e2f59c_6aba7ea2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-07-08T21:26:47Z",
      "side": 1,
      "message": "Done - cwallez@ was already on it",
      "parentUuid": "c45a8bf6_4283ee1f",
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "246f876d_4a044c7c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-07-08T21:26:47Z",
      "side": 1,
      "message": "\u003e The D3D12 fence and resource passed into ExternalImageDXGI::Create are created by Chromium, right? So Dawn shouldn\u0027t be destroying them.\n\nThe D3D12 fence and resource are created inside Dawn from shared handles passed from Chromium. Chromium doesn\u0027t know or care about these - the underlying resources are alive until the shared handle is kept alive by Chromium which this CL doesn\u0027t affect.\n\n\u003e Which objects are owned by Dawn\u0027s d3d12::Device that are getting destroyed are touched by ExternalImageDXGI? is it D3D11on12ResourceCacheEntry::mDXGIKeyedMutex and D3D11on12ResourceCacheEntry::mD3D11on12Device ?\n\nIn crbug.com/1338470, the crash is in D3D12Core!CLayeredObject\u003cCBackingCommandAllocator\u003e::CContainedObject::Release. It\u0027s unclear why we would trigger any code related to the command allocator - maybe it\u0027s a code deduplicated symbol?\n\nFor the fence CL that\u0027s blocked by this, I haven\u0027t been able to determine what\u0027s crashing despite debugging on the failing bot directly - the test crashes without a crash dump or error messages - the debug layer is also unhelpful since the bots run an older Win10 version and don\u0027t have the necessary optional packages installed. See example failure: https://chromium-swarm.appspot.com/task?id\u003d5bd51866dc31f711\n\nOn that same CL, there\u0027s another crash in a webcodecs test that implicates chrome!Microsoft::WRL::ComPtr\u003cID3D12Fence\u003e::InternalRelease: https://chromium-swarm.appspot.com/task?id\u003d5bd51d16022bc311\n\nFWIW I tried making the ExternalImageDXGI take a ref on the D3D12 backend Device, but that didn\u0027t fix this crash (from my CL) either - I suspect something in Device::DestroyImpl releases resources that are needed when releasing the D3D12 fence or resource later in ~ExternalImageDXGI - maybe the command list? This CL fixes the crash however.",
      "parentUuid": "e8a44b64_ee14e0ad",
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "49598b4d_1f62c709",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-07-08T21:34:29Z",
      "side": 1,
      "message": "It seems test failures are because we\u0027re reusing the same ExternalImageDXGI across multiple WGPUDevice instances - trying to confirm that.",
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f64f764_5ae0ce1e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-07-08T22:29:08Z",
      "side": 1,
      "message": "As you mentioned in the other comment, we need to make sure it still works with multiple WGPUDevices. Perhaps what we need is for Chromium to store a map of WGPUDevice -\u003e ExternalImageDXGI. We would lose any performance benefit from not re-opening share handles for multiple WGPUDevices that are backed by the same D3D12 adapter, but I don\u0027t think that was the intent of this cache. The intent was more to improve multiple consecutive ProduceTexture on the same WGPUDevice.\n\nAlternatively, we could structure it so we get back multi-WGPUDevice performance in the future. Chromium has a map of WGPUAdapter -\u003e ExternalImageDXGI, and we continue passing WGPUDevice to ProduceTexture(...).\nRight now we still have multiple WGPUAdapters in the GPU process, but there\u0027s a plan to eventually have one WGPUAdapter per real hardware adapter which are shared across all WebGPU contexts.",
      "parentUuid": "246f876d_4a044c7c",
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "005142dd_7d1ced43",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-07-08T22:56:00Z",
      "side": 1,
      "message": "\u003e As you mentioned in the other comment, we need to make sure it still works with multiple WGPUDevices. Perhaps what we need is for Chromium to store a map of WGPUDevice -\u003e ExternalImageDXGI. We would lose any performance benefit from not re-opening share handles for multiple WGPUDevices that are backed by the same D3D12 adapter, but I don\u0027t think that was the intent of this cache. The intent was more to improve multiple consecutive ProduceTexture on the same WGPUDevice.\n\nAgreed, I\u0027m pretty sure this only works accidentally today because we create all webgpu devices from the same D3D device (from ANGLE). Fixing this will require a Chromium side change first to use map\u003cWGPUDevice,ExternalImageDXGI\u003e before landing this CL.\n\n\u003e Alternatively, we could structure it so we get back multi-WGPUDevice performance in the future. Chromium has a map of WGPUAdapter -\u003e ExternalImageDXGI, and we continue passing WGPUDevice to ProduceTexture(...).\nRight now we still have multiple WGPUAdapters in the GPU process, but there\u0027s a plan to eventually have one WGPUAdapter per real hardware adapter which are shared across all WebGPU contexts.\n\nThis will require keeping a ref on ExternalImageDXGI (or its Contents/Resources) for each WGPUDevice that uses it via ProduceTexture?  Given that we don\u0027t understand the nature of these implicit dependencies, maybe it\u0027s best to bind ExternalImageDXGI to one WGPUDevice only?",
      "parentUuid": "8f64f764_5ae0ce1e",
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e9f7d28_33d6aaf8",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.h",
        "patchSetId": 2
      },
      "lineNbr": 278,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-07-08T22:29:08Z",
      "side": 1,
      "message": "using raw pointers here doesn\u0027t seem super safe.\n\nwhat if instead we have a vector\u003cRef\u003cExternalImageDXGIContents\u003e\u003e\nand ExternalImageDXGI also owns a Ref\u003cExternalImageDXGIContents\u003e.\n\nWe would move all the contents of ExternalImageDXGI into ExternalImageDXGIContents and give it a Destroy() method to release all the resources.\n\nLastly, instead of adding to the list inside the ExternalImageDXGI constructor, we should probably move ExternalImageDXGI::Create such that it\u0027s defined on the Device. So the Device becomes a factory for ExternalImageDXGI. (or, if we do the suggestion in the other thread, the Adapter becomes a factory for ExternalImageDXGI)",
      "range": {
        "startLine": 278,
        "startChar": 0,
        "endLine": 278,
        "endChar": 52
      },
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00f0ccce_0a8f9dd2",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.h",
        "patchSetId": 2
      },
      "lineNbr": 278,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-07-08T22:56:00Z",
      "side": 1,
      "message": "AFAICT ExternalImageDXGI can unfortunately not expose Ref\u003c\u003e in its header (D3D12Backend.h) because RefBase/RefCounted.h is a Dawn internal API so we would end up having to put a raw pointer to ExternalImageDXGIContents and making Reference/Release calls manually which makes it similarly unsafe to the Add/RemoveExternalImageDXGI implementation in the current CL.\n\nbikeshed: I\u0027d prefer naming it ExternalImageDXGIResources instead of ExternalImageDXGIContents.",
      "parentUuid": "2e9f7d28_33d6aaf8",
      "range": {
        "startLine": 278,
        "startChar": 0,
        "endLine": 278,
        "endChar": 52
      },
      "revId": "1304a463aa1187064e8694cc7378327c53fe943e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}