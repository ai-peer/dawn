{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "297b53e3_bea7ae07",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-17T00:27:12Z",
      "side": 1,
      "message": "PTAL this alternative approach. It turns out the other one was actually hitting a hang. This one is more complex but more conservative about when we send heartbeats.",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "587c995e_9b277909",
        "filename": "webgpu-cts/test_runner.js",
        "patchSetId": 4
      },
      "lineNbr": 112,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-08-18T01:11:59Z",
      "side": 1,
      "message": "I don\u0027t think this sends a heartbeat after any code awaiting the promise. Pretty sure both heartbeats will happen before.\n\nAFAIK you can\u0027t really hook code that happens after the promise unless you override the implementation of `then` which I\u0027m not sure is compatible with `await` anyway.\n\nHow about sending a heartbeat before `old.call` instead? That way you\u0027ll get a heartbeat while waiting e.g. for a map to complete.",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56586a1f_1baaf421",
        "filename": "webgpu-cts/test_runner.js",
        "patchSetId": 4
      },
      "lineNbr": 112,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T02:32:19Z",
      "side": 1,
      "message": "you can\n\n```\nconst outer \u003d new Promise(resolve \u003d\u003e {\n  const inner \u003d new Promise(innerResolve \u003d\u003e setTimeout(innerResolve, 5));\n  inner.then(() \u003d\u003e {\n    console.log(\u0027before\u0027);\n    resolve();\n  }).finally(() \u003d\u003e console.log(\u0027after\u0027));\n});\n\nouter.then(() \u003d\u003e {\n  console.log(\u0027could be really long running, like checking texture contents\u0027);\n});\n```\n\nwill log:\n```\nbefore\ncould be really long running, like checking texture contents\nafter\n```",
      "parentUuid": "587c995e_9b277909",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3cb07ebf_84a3af69",
        "filename": "webgpu-cts/test_runner.js",
        "patchSetId": 4
      },
      "lineNbr": 112,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-08-18T03:49:52Z",
      "side": 1,
      "message": "I see, I guess the microtask queue ordering is different than I realized. Seems fine then.",
      "parentUuid": "56586a1f_1baaf421",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "651eedc8_405c1665",
        "filename": "webgpu-cts/test_runner.js",
        "patchSetId": 4
      },
      "lineNbr": 119,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-08-18T01:11:59Z",
      "side": 1,
      "message": "nit: I think you could just\n\n```\nconst p \u003d old.call(this, ...args);\np.finally(sendHeartbeat);\nreturn p;\n```\n\nSince the finally is registered before anything the application does with the promise, I think it\u0027s supposed to get called first.\n\nOnly difference would be I think it would suppress unhandledrejection events.",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40a1a31f_f25bf814",
        "filename": "webgpu-cts/test_runner.js",
        "patchSetId": 4
      },
      "lineNbr": 119,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T02:32:19Z",
      "side": 1,
      "message": "this will spew with unhandledrejection events. Consider:\n\n```\nconst p \u003d new Promise((resolve, reject) \u003d\u003e reject(new Error(\u0027err\u0027)));\n\np.finally(() \u003d\u003e console.log(\u0027finally\u0027));\n\n(async () \u003d\u003e {\n    try {\n        await p;\n        console.log(\u0027not reached\u0027);\n    } catch (e) {\n        console.log(\u0027catch\u0027, e);\n    }\n})();\n```\n\n\n`p` throws and we get the log `catch Error: err`, as expected.\nbut, we also get uncaught errors\n\n```\nUncaught (in promise) Error: err\n    at \u003canonymous\u003e:1:51\n    at new Promise (\u003canonymous\u003e)\n    at \u003canonymous\u003e:1:11\n```\n\nwhy? because `p.finally` returned a **new** promise, and that one was not caught\n\nto suppress this, we need to install a do-nothing catch handler:\n```\np.finally(() \u003d\u003e console.log(\u0027finally\u0027))\n  .catch(() \u003d\u003e {}); // do nothing\n```\n\nbut I\u0027d rather not do it this way since it seems confusing.",
      "parentUuid": "651eedc8_405c1665",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ecf8ef28_3f8dfa62",
        "filename": "webgpu-cts/test_runner.js",
        "patchSetId": 4
      },
      "lineNbr": 119,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-08-18T03:49:52Z",
      "side": 1,
      "message": "isn\u0027t\n```\nconst p \u003d new Promise((resolve, reject) \u003d\u003e reject(new Error(\u0027err\u0027)));\n```\ngoing to cause an unhandledrejection event anyway?\n\nbut regardless, keeping as is seems fine",
      "parentUuid": "40a1a31f_f25bf814",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6eb7ad46_2e75da2e",
        "filename": "webgpu-cts/test_runner.js",
        "patchSetId": 4
      },
      "lineNbr": 139,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-08-18T01:11:59Z",
      "side": 1,
      "message": "nit: IMO clearer if you just pass `target, prop, receiver` explicitly. The magic `arguments` keyword is hard to read.",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fad79297_810160d1",
        "filename": "webgpu-cts/test_runner.js",
        "patchSetId": 4
      },
      "lineNbr": 139,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T21:51:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6eb7ad46_2e75da2e",
      "revId": "935d5a78b0d219f3e2a7dc02a95a7427d6c74d5b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}