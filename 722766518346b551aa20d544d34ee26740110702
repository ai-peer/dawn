{
  "comments": [
    {
      "key": {
        "uuid": "95bad959_0975ab82",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 91,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-18T23:23:35Z",
      "side": 1,
      "message": "nit: pass in \u0026mBoundHeapsChanged as a pointer into this function to make it clear that ApplyBindGroup may mutate it. It can probably be a local variable, and not a member.",
      "range": {
        "startLine": 89,
        "startChar": 40,
        "endLine": 91,
        "endChar": 45
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85b3e28c_ba93995b",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 100,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-18T23:23:35Z",
      "side": 1,
      "message": "If reapplyBindGroups \u003d\u003d true, we still need to add the bind group to the set of allocated bind group -- we just need to do it after the reallocation happens.",
      "range": {
        "startLine": 100,
        "startChar": 16,
        "endLine": 100,
        "endChar": 25
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99ec2703_aed85df4",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 100,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-11-20T00:35:36Z",
      "side": 1,
      "message": "Which group? The current (and remaining) should already be allocated on the new heap - only the previous ones need to be re-applied - if my understanding is correct.",
      "parentUuid": "85b3e28c_ba93995b",
      "range": {
        "startLine": 100,
        "startChar": 16,
        "endLine": 100,
        "endChar": 25
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3e4ed709_16013e4a",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 100,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-20T01:14:29Z",
      "side": 1,
      "message": "The current and remaining will be allocated on the new heap, but we still need to put them in the vector (or bitset as I recommended elsewhere).\n\n1: allocating bind groups: [ A, B, C ] \u003d\u003e just allocate and it\u0027s fine.\n   \u003d\u003e A, B, C are in mBindGroupsAllocated\n2. allocating more: [D, E] \u003d\u003e causes reapply to happen\n   \u003d\u003e A, B, C are re-allocated, D and E never get added to mBindGroupsAllocated\n3. allocate more: [F, G] \u003d\u003e causes ANOTHER reapply to happen\n   \u003d\u003e D and E were never added to the vector. They are never reallocated",
      "parentUuid": "99ec2703_aed85df4",
      "range": {
        "startLine": 100,
        "startChar": 16,
        "endLine": 100,
        "endChar": 25
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0379d5e_7e2e3337",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 100,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-11-20T19:20:00Z",
      "side": 1,
      "message": "Ah, Thanks for clarifying.",
      "parentUuid": "3e4ed709_16013e4a",
      "range": {
        "startLine": 100,
        "startChar": 16,
        "endLine": 100,
        "endChar": 25
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a5745bd_8456428f",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 110,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-18T23:23:35Z",
      "side": 1,
      "message": "I\u0027m concerned that this will reallocate ALL bind groups used in this submit. This is much more than we need. We only need to reallocate the bind groups that were in the old heap, but used in this draw call. Consider:\n\nSetBindGroup(0, A)\nSetBindGroup(1, B)\nDraw()\n\nSetBindGroup(0, C)  // reallocation happens here which reallocates A and B\nSetBindGroup(1, D)\nDraw()              // A and B are never used\n\nCurrent bind groups are already stored in |std::array\u003cBindGroupBase*, kMaxBindGroups\u003e mBindGroups| from the base class. This tracker can keep a std::bitset\u003ckMaxBindGroups\u003e mBindGroupsAllocated bitmask, then iterate (mBindGroupsAllocated \u0026 mBindGroupLayoutsMask) and only reallocate those.",
      "range": {
        "startLine": 110,
        "startChar": 21,
        "endLine": 110,
        "endChar": 68
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "64301a2d_a5cf172d",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-18T23:23:35Z",
      "side": 1,
      "message": "I\u0027m uneasy with having AllocateDescriptors change the current heaps from underneath the tracker and discovering this when we call SetDescriptorHeaps.\n\nWe should have a separate allocator so we can do allocator-\u003eAllocateBindGroup(...) and internally it allocates the DescriptorHeapHandles, etc. The logic in BindGroup::AllocateDescriptors would probably move into this allocator.\n\nThis would be more organized and enable some additional follow-up optimizations:\n - Using ID3D12Device::CopyDescriptors instead of re-encoding descriptors\n - Having a sort-of LRU so that we don\u0027t re-allocate descriptors that are already in the \"current\" descriptor heap. i.e. consecutive queue.submits that use the same descriptors should be able to just point to them and set the descriptor heap instead of reallocating.",
      "range": {
        "startLine": 194,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc814dc6_b1c79cdc",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-18T23:23:35Z",
      "side": 1,
      "message": "ASSERT that if requiresAllocation \u003d\u003d true, mBoundHeapsChanged \u003d\u003d false.\nIt should be impossible to change heaps in the middle of a reallocation.\n\nIf this can indeed happen (I don\u0027t think it can), then we could return an OOM error.",
      "range": {
        "startLine": 197,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0fdb7466_b049a221",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-11-20T00:35:36Z",
      "side": 1,
      "message": "We don\u0027t want to ASSERT on the first re-allocation - a tracking bit would be needed for that check. Still worth doing?",
      "parentUuid": "fc814dc6_b1c79cdc",
      "range": {
        "startLine": 197,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d83499c6_708a958b",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-11-20T00:35:36Z",
      "side": 1,
      "message": "\u003e I\u0027m uneasy with having AllocateDescriptors change the current heaps from underneath the tracker and discovering this when we call SetDescriptorHeaps.\n\nWe could move SetDescriptorHeaps to BindGroupLayout::Allocate. So that BindGroup::AllocateDescriptors \u003d\u003e CreateDescriptors using the allocations (similar to Vulkan). Thoughts?\n\nAlternatively, revert + OOM. Even before this change, I think MAX_SAMPLER + 1 case still overflows.\n\n\u003eenable some additional follow-up optimizations\n\nIdeas welcomed. But are these needed for removing the pre-pass? If not, noted to revisit.",
      "parentUuid": "64301a2d_a5cf172d",
      "range": {
        "startLine": 194,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14ec5f9c_c5e796d5",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-20T01:14:29Z",
      "side": 1,
      "message": "\u003e We could move SetDescriptorHeaps to BindGroupLayout::Allocate. So that BindGroup::AllocateDescriptors \u003d\u003e CreateDescriptors using the allocations (similar to Vulkan). Thoughts?\n\u003e Alternatively, revert + OOM. Even before this change, I think MAX_SAMPLER + 1 case still overflows.\n\nI don\u0027t think we should follow the Vulkan backend here. The Vulkan backend does descriptor set allocation statically on creation -- not during recording time (and it\u0027s very bad and needs to be further optimized). In the D3D12 backend, the BindGroupLayout should not itself be an allocator. There should be a separate construct which allocates descriptors for the BindGroupLayout. D3D12 demands a dynamically allocating solution because of this overflow problem.\n\nIn the current patch, d3d12::BindGroup modifies Device-global data and then we respond to it reactively, which is sort of backward. It will be better if an allocator object knows how big the current DescriptorHeapAllocation is and can explicitly allocate inside of that based on how much space there is. If there is insufficient space, it creates a new DescriptorHeap and copies (or re-records if that\u0027s easier for now) used descriptors from the old heap.\n\n\u003e Ideas welcomed. But are these needed for removing the pre-pass? If not, noted to revisit.\n\nNot needed now, but we should keep it in mind when we design this so we don\u0027t churn too much.",
      "parentUuid": "d83499c6_708a958b",
      "range": {
        "startLine": 194,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe75b628_d8d4abb3",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-20T01:14:29Z",
      "side": 1,
      "message": "I don\u0027t think there\u0027s any extra tracking involved, but I may not fully understand what you mean.\n\nIIUC, requiresAllocation \u003d\u003d true when BindGroup::AllocateDescriptors causes the descriptor heaps to change. When this happens, we iterate through the previously allocated descriptors and re-allocate them in the new heap. During this re-allocation we shouldn\u0027t incur ANOTHER change in descriptor heaps because the new descriptor heap should be big enough for the old descriptors + the new ones.\n\nNote: This tracking complication isn\u0027t an issue if we move BindGroup::AllocateDescriptors into an explicit allocator which explicitly knows which descriptor heap it\u0027s using.",
      "parentUuid": "0fdb7466_b049a221",
      "range": {
        "startLine": 197,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bebeb85a_0b6367ee",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-11-20T19:20:00Z",
      "side": 1,
      "message": "\u003e the BindGroupLayout should not itself be an allocator\n\nI wasn\u0027t thinking to have the BGL be an allocator itself but only deal with switching heaps on overflow (but before being re-applied). Or move that into DynamicBindGroup allocator, must it exist [1].\n\n\u003e D3D12 demands a dynamically allocating solution because of this overflow problem.\n\nThis can also be reversed. Dynamically allocating causes overflow. Statically allocating does not. Had we statically staged them (ie. CPU descriptors + CopyDescriptors), then I don\u0027t see how overflow could occur [1]. Note: static descriptors are native to D3D.\n\n\u003e Not needed now, but we should keep it in mind when we design this so we don\u0027t churn too much.\n\nAh, thanks. I was hoping to avoid dealing with overflow for this CL. However, I don\u0027t mind tackling the refactor now but it will certainly require more revs.",
      "parentUuid": "14ec5f9c_c5e796d5",
      "range": {
        "startLine": 194,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2a5d04a_20cea011",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-11-20T19:20:00Z",
      "side": 1,
      "message": "\u003e I don\u0027t think there\u0027s any extra tracking involved, but I may not fully understand what you mean.\n\nUnless I\u0027m missing something, we would need to to disambiguate the first group vs a middle group being re-applied. ASSERT(requiresAllocation \u003d\u003d true \u0026\u0026 mBoundHeapsChanged \u003d\u003d false) fails on the first re-applied group. It requires reallocation and changes the bounded heaps.",
      "parentUuid": "fe75b628_d8d4abb3",
      "range": {
        "startLine": 197,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "20fdd92e_dd280d2e",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-20T19:32:55Z",
      "side": 1,
      "message": "I meant requiresAllocation is true implies mBoundHeapsChanged must be false.\n\nif (requiresAllocation) ASSERT(!mBoundHeapsChanged);\n\nWhich is the same as ASSERT(!requiresAllocation || !mBoundHeapsChanged) \nor more simply ASSERT(!(requiresAllocation \u0026\u0026 mBoundHeapsChanged))",
      "parentUuid": "f2a5d04a_20cea011",
      "range": {
        "startLine": 197,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1039ede2_d1e64ecb",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 199,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-20T19:32:55Z",
      "side": 1,
      "message": "Would be happy for the BGL to be a CPU allocator. But wouldn\u0027t we still need to CopyDescriptors into a dynamically allocated GPU descriptor heap?",
      "parentUuid": "bebeb85a_0b6367ee",
      "range": {
        "startLine": 194,
        "startChar": 12,
        "endLine": 199,
        "endChar": 65
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47ce1669_bc53b499",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 11
      },
      "lineNbr": 254,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-18T23:23:35Z",
      "side": 1,
      "message": "\u0026\u0026 !requiresAllocation ?\nIf it was reallocated, then the D3D12_GPU_DESCRIPTOR_HANDLE will be different.",
      "range": {
        "startLine": 254,
        "startChar": 16,
        "endLine": 254,
        "endChar": 40
      },
      "revId": "722766518346b551aa20d544d34ee26740110702",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}