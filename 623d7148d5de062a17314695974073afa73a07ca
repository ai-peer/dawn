{
  "comments": [
    {
      "key": {
        "uuid": "1fddeead_851cc165",
        "filename": "src/common/Math.cpp",
        "patchSetId": 8
      },
      "lineNbr": 78,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-02-07T02:28:01Z",
      "side": 1,
      "message": "The semantic of NextPowerOfTwo is that it returns a power of two, so it is breaking the contract by returning a non-power of two. How about adding an ASSERT and special handling in the callers? Also this check is wrong because the issue will happen as soon as n \u003e (1ull \u003c\u003c 63ull)",
      "revId": "623d7148d5de062a17314695974073afa73a07ca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc0e8308_4a113e9d",
        "filename": "src/common/Math.cpp",
        "patchSetId": 8
      },
      "lineNbr": 78,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-02-10T17:57:40Z",
      "side": 1,
      "message": "A large N is not so much the issue as it will OOM before calling NextPowerOfTwo (but I agree, it\u0027s semantically wrong). \n\nThe issue is when buffer.size \u003d 0, what does the special handing do? It is not well-defined.\n\nCan you please provide clarification on such input?",
      "parentUuid": "1fddeead_851cc165",
      "revId": "623d7148d5de062a17314695974073afa73a07ca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8fcc11fd_2d83120c",
        "filename": "src/common/Math.cpp",
        "patchSetId": 8
      },
      "lineNbr": 78,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-02-10T18:25:39Z",
      "side": 1,
      "message": "\u003e A large N is not so much the issue as it will OOM before calling NextPowerOfTwo (but I agree, it\u0027s semantically wrong).\n\nI\u0027m not sure I understand. If that\u0027s the case why does we need this CL that fixes the case where N is UINT64_MAX?\n\n\u003e The issue is when buffer.size \u003d 0, what does the special handing do? It is not well-defined.\n\nThat seems like a different issue discussions in the gpuweb issue you opened seem to lean towards saying it is ok to have 0-size buffers (and just emulate them in the backend).",
      "parentUuid": "cc0e8308_4a113e9d",
      "revId": "623d7148d5de062a17314695974073afa73a07ca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e298d470_4aefaabb",
        "filename": "src/common/Math.cpp",
        "patchSetId": 8
      },
      "lineNbr": 78,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-02-10T21:32:50Z",
      "side": 1,
      "message": "\u003e If that\u0027s the case why does we need this CL that fixes the case where N is UINT64_MAX?\n\nIt\u0027s because D3D12 treats buffer.size \u003d 0 as UINT64_MAX to denote failure (invalid). Either it must be handled in the backend (eg. return OOM?) or NextPowerOfTwo. I couldn\u0027t get an answer to the latter so I went with the former.\n\n\u003e That seems like a different issue discussions in the gpuweb issue you opened \n\nThey\u0027re related. If we permit zero-sized buffers (via creating a dummy non-zero buffer) then this bug is no more.",
      "parentUuid": "8fcc11fd_2d83120c",
      "revId": "623d7148d5de062a17314695974073afa73a07ca",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}