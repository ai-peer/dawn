{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0d17e561_8eee16ac",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-03-28T20:14:32Z",
      "side": 1,
      "message": "I believe all feedback has been addressed. Lmk if more is needed. Would prefer addressing any significant changes in a follow up CL.",
      "revId": "74888b1d23d3780873824bc726e0ad62ac237a21",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06546bc6_10a4d084",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-03-28T23:09:31Z",
      "side": 1,
      "message": "I\u0027m running into a D3D12 Debug Layer error on one of my new tests. It turns out to use a shared buffer with CreateConstantBufferView (i.e. wgpu::BufferUsage::Uniform) , then then size must be 256-aligned [1].\n\nIt seems like allowing BufferUsage::Uniform would be desirable. I was thinking we could keep things as they are and only add BufferUsage::Uniform on creation to the WebGPU buffer if the ID3D12Resource does have the correct size alignment. WDYT?\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d12/BindGroupD3D12.cpp;l\u003d92",
      "revId": "74888b1d23d3780873824bc726e0ad62ac237a21",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a7fa755_f739dd45",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-03-28T23:25:57Z",
      "side": 1,
      "message": "hm, I think that would be kind of unfortunate because whether or not it supports uniform usage would be really surprising from call-to-call.\n\nWhat if we align-down the size to the required alignment? Would be interesting if you pass small buffer - because then you can get a size 0 buffer. But then it would always support uniform usage, assuming it is nonzero in size.\n\nValidate and require the alignment on creation?",
      "parentUuid": "06546bc6_10a4d084",
      "revId": "74888b1d23d3780873824bc726e0ad62ac237a21",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f52ab99c_5f54ca2a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-03-29T00:04:17Z",
      "side": 1,
      "message": "The align-down thing isn\u0027t going to work because the actual D3D12 error I\u0027m getting is about an out of range access. We get an error if we access outside [resourceAddress + size - 1], so aligning the size down will always result in the error.\n\nSeems a bit heavy-handed to disallow all non-aligned buffers just for this one case though, but it would work.\n\nThe allowed usages are decided on ImportSharedBufferMemory. Unfortunately the earliest the developer will find that wgpu::BufferUsage::Uniform isn\u0027t allowed on a non-aligned buffer is on CreateBuffer after ImportSharedBufferMemory. We could have specific error message if they try to include the Uniform usage on a non-aligned buffer during CreateBuffer. This is my preference, but it might be confusing to a developer who doesn\u0027t provide a BufferDescriptor and opts for the default descriptor.",
      "parentUuid": "0a7fa755_f739dd45",
      "revId": "74888b1d23d3780873824bc726e0ad62ac237a21",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e851c96c_7669f378",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-03-29T00:16:48Z",
      "side": 1,
      "message": "Align-down meaning if you get a 452-byte buffer, we tell you that it is only 256-bytes big.\n\nThus, it\u0027s invalid to bind the buffer to a uniform buffer binding that is 257-bytes or larger.\n\nSo the buffer you get appears to be smaller and the rest of Dawn\u0027s validation treats it as smaller.",
      "parentUuid": "f52ab99c_5f54ca2a",
      "revId": "74888b1d23d3780873824bc726e0ad62ac237a21",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef7b9c7b_13a6d284",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-03-29T00:30:52Z",
      "side": 1,
      "message": "But doesn\u0027t that leave the developer unable access a portion of their buffer? I\u0027d end up creating a D3D12_CONSTANT_BUFFER_VIEW_DESC with SizeInBytes less than the actual size, which sounds like it would have undefined behavior on OOB access. Dawn validation isn\u0027t a problem here, it\u0027s the D3D12 debug layer.",
      "parentUuid": "e851c96c_7669f378",
      "revId": "74888b1d23d3780873824bc726e0ad62ac237a21",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c17da562_34cda949",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-03-29T16:32:52Z",
      "side": 1,
      "message": "maybe I\u0027m not understanding - but yea, the idea would be you can\u0027t access the end of the buffer. We make the buffer appear smaller, and limit the portion of it you can bind. The size accessed in the shader is validated against what is bound - so I think it wouldn\u0027t be possible to OOB access. It would be as-if the buffer were simpler smaller than it really is.\n\nBut this isn\u0027t so ideal either. I\u0027m not sure what is best. I\u0027m thinking either we disallow Uniform usage (most applications will be using STORAGE or COPY, I think..?) Or we require the size to be a multiple of 256 when importing an ID3D12Resource.",
      "parentUuid": "ef7b9c7b_13a6d284",
      "revId": "74888b1d23d3780873824bc726e0ad62ac237a21",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}