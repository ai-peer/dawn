{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1315c571_9dede1a5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000505
      },
      "writtenOn": "2021-04-12T20:10:35Z",
      "side": 1,
      "message": "Hm, so I have mixed feelings about these helpers. We don\u0027t really have much use for them right now in Dawn since we don\u0027t have real \"chains\" yet (there can only be a single surface descriptor, a single shader module descriptor, etc). I\u0027m happy to polish up this CL and write some tests, but I wonder if we should just hold off until there\u0027s actually a use case for chains of length \u003e 1. The helpers don\u0027t really make any of the existing sType code blocks more readable.",
      "revId": "2fe49126477717e1ea1b3fcaa65f92f5ec26bcb1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "625b850c_2e281d49",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-04-13T01:57:23Z",
      "side": 1,
      "message": "Maybe we don\u0027t need the ForEachChain macro, but FindInChain could be helpful if it did the casting as well. That gives us some type safety. And, I do think it would be valuable to be able to write code that didn\u0027t assume the chain length is 1. That way we don\u0027t need to find all the places to fix as soon as we have longer chains.\n\nWhat about having an autogenerated helper that determines the correct sType based on the pointer type? \n\nso for now, just a bunch of:\n void FindInChain(const ChainedStruct* chain, PrimitiveDepthClampingState** out);\n void FindInChain(const ChainedStruct* chain, ShaderModuleSPIRVDescriptor** out);\n void FindInChain(const ChainedStruct* chain, ShaderModuleWGSLDescriptor** out);\n\nwould avoid manual sType checking and casting.\n\nFor bonus points though, we could eventually make it varadic so you can extract multiple structs at once. (though really not necessary now though)\n\ntemplate \u003ctypename... OutStructs\u003e\nvoid FindInChain(const ChainedStruct* chain, OutStructs... **out) {\n  for (; chain; chain \u003d chain-\u003enextInChain) {\n    switch (chain-\u003esType) {\n      // autogenerate cases for all known sTypes\n      case SType::A:\n      case SType::B:\n      ...\n      case SType::X: {\n        // some template magic to get the matching\n        // OutStruct of type X and write |chain| to it.       \n      }\n      default:\n        break;\n    }\n  }\n};",
      "parentUuid": "1315c571_9dede1a5",
      "revId": "2fe49126477717e1ea1b3fcaa65f92f5ec26bcb1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ce4973e1_630bf1a5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-04-13T10:15:41Z",
      "side": 1,
      "message": "In webgpu_cpp.h we could add a static consexpr member to chained structures that gives the sType, so you can do T::SType when working with templates over chained structs.\n\n+1 on trying to do the correct chain handling now even if it seems overkill. In the future we\u0027re very likely going to have a lot of extensions. However contrary to Mesa we should have a way to validate that all the things in the chain are known things. (Vulkan puts the onus on the application for that)\n\nMaybe what Austin suggested with a variadic macro, but that also returns a boolean saying if it saw something extra, or a MaybeError",
      "parentUuid": "625b850c_2e281d49",
      "revId": "2fe49126477717e1ea1b3fcaa65f92f5ec26bcb1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "642b80aa_eba4bdca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000505
      },
      "writtenOn": "2021-04-14T21:56:40Z",
      "side": 1,
      "message": "The singular FindInChain seems useful, but I\u0027m not convinced that the variadic version is more concise or ergonomic than a switch statement like the one used for processing surface descriptors. If we\u0027re likely to have a lot of extensions, I don\u0027t think it\u0027s particularly pleasant to write:\n\n```\nDescA a \u003d nullptr;\nDescB b \u003d nullptr;\n...\nDescZ z \u003d nullptr;\nFindInChain(chain, a, b..., z);\nif (a) {\n}\nif (b) {\n}\n...\nif (z) {\n}\n```\n\nwhen a simple switch statement gets us most of the way there without any template magic behind the scenes. Also, this won\u0027t work if we decide it\u0027s valid to have two structs in a chain with the same sType.\n\nAs for validation, I think it\u0027d be useful to have a function that looks like:\n\n```\nbool ValidateChainSTypes(std::vector\u003cstd::vector\u003cSType\u003e\u003e validSTypes);\n```\n\nwhere validStypes contains all of the possible sTypes for the chain and each vector inside validSTypes is a oneof constraint. To illustrate:\n\n```\nValidateChainSTypes(chain, {{ShaderModuleSPIRV, ShaderModuleWGSL}});\nValidateChainSTypes(chain, {{DepthClampingState}, {SomeOtherPrimitiveStruct}});\n```",
      "parentUuid": "ce4973e1_630bf1a5",
      "revId": "2fe49126477717e1ea1b3fcaa65f92f5ec26bcb1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "087e8246_976a6c40",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-04-14T22:01:44Z",
      "side": 1,
      "message": "+1 to Validate. Agree that singular FindInChain is sufficient for now. We can see if a varadic one is useful in the future when there are more extensions.",
      "parentUuid": "642b80aa_eba4bdca",
      "revId": "2fe49126477717e1ea1b3fcaa65f92f5ec26bcb1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}