{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4701d975_07a82557",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2021-06-25T06:58:17Z",
      "side": 1,
      "message": "PTAL. Fix 3 issues reported by ClusterFuzz.",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6cbe94a_49aa5644",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 846,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-06-25T16:45:50Z",
      "side": 1,
      "message": "hm.. alternatively we should probably have MakeError return a ref instead of a raw pointer.",
      "range": {
        "startLine": 846,
        "startChar": 21,
        "endLine": 846,
        "endChar": 67
      },
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f6736ef3_0780a825",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 846,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2021-07-15T06:46:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c6cbe94a_49aa5644",
      "range": {
        "startLine": 846,
        "startChar": 21,
        "endLine": 846,
        "endChar": 67
      },
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e375c182_e8c42e06",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-25T12:25:20Z",
      "side": 1,
      "message": "I\u0027m not sure that this is the behavior we want: logging should be called for the callback that\u0027s during the operation that does the log.\n\nInstead of this fix, what do you think of registering all dummy callbacks in Server::ClearDeviceCallbacks, and maybe also do a wait for idle there to flush all previous callbacks? Similarly to WaitForAllOperations in ValidationTests.cpp or what happens at the end of the fuzzers?",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73d2f90c_82dc3702",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2021-06-25T13:29:19Z",
      "side": 1,
      "message": "I see, but I am not sure if one may register a complex callback (which use some external resource that may be disposed later), do some logging, and somehow unregister the callback (and dispose the external resource) before the callback tasks are scheduled. I wonder if there is a sound method to keep such complex callback valid.\nIn fact, the fuzzbot catch a very case, in which the registered callback use the dawn_wire (to post the logging string to client), and before callback tasks triggered, the dawn wire shutdown, and dispose the resource. In this case, the callback function held in the callback task will try to access the disposed dawn_wire resource, causing the use-after-release.\nIf we just stick to the callback available at the very moment of triggering callback task, we may prevent such uncertainty, because anyone who register the callback should de-register it before disposing anything it relied on. (Actually the dawn_wire server do so.) And such disposing may be just a part of a big operation, which we may probably not always want to be blacked by a callback task.",
      "parentUuid": "e375c182_e8c42e06",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3064a5ff_4503e921",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-25T15:21:47Z",
      "side": 1,
      "message": "Yeah I\u0027m not sure what\u0027s best here, we are going to have similar issues with other callbacks that we want to put on the callback queue. Maybe we should have a way to drain the callback queue without waiting for idle.",
      "parentUuid": "73d2f90c_82dc3702",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb7e9a5b_6ca37d37",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-06-25T16:45:50Z",
      "side": 1,
      "message": "\u003e we are going to have similar issues with other callbacks that we want to put on the callback queue\n\nI think this problem is mostly due to the fact that callbacks need to be invalidated after the server is destroyed. all other wire callbacks (buffer map async, etc.) right now have a weak_ptr to ensure we don\u0027t try to call the callback after server destruction. So maybe a better solution might be to restructure the way we do the userdata for the device-level callbacks.",
      "parentUuid": "3064a5ff_4503e921",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c89b70c4_b129e257",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-28T16:54:09Z",
      "side": 1,
      "message": "That would work. Zhaoming, please see the various calls to MakeUserdata in the server code.",
      "parentUuid": "fb7e9a5b_6ca37d37",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec1744cb_397f8ca5",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2021-07-15T06:46:12Z",
      "side": 1,
      "message": "I have looked into the details of MakeUserdata and ForwardToServer. As I understood, the key of MakeUserdata is to make a wrapped object which contains a weak pointer to dawn_wire server (mIsAlive), and ForwardToServer to wrap the callback function, check the weak_ptr to ensure the server is alive before calling server function or otherwise early return, and delete the wrapped object created by MakeUserdata.\nRather than using the MakeUserdata-ForwardToServer routine, I use the shared pointers for device-level callbacks descriptor in DeviceBase and weak pointer in callback task, as in Patchset 5. Here are the reasons:\n  1. It works as well as the MakeUserdata-ForwardToServer routine. The expected callback task behavior is calling the callback with the userdata registered at the time of creating the task if available, or do nothing otherwise. The MakeUserdata-ForwardToServer routine do so by checking if dawn_wire server is alive. In our case, it\u0027s promised that server destructor will reset the device-level callbacks in all its devices before releasing other known objects. Under current design, resetting device-level callbacks will make all weak pointers in relating callback tasks expire, and thus early return when tasks triggered afterwards.\n  2. It is complex to follow the MakeUserdata-ForwardToServer routine for userdata in device-level callbacks. \n    a) Live cycle management. All other callbacks, like BufferMapAsyncCallback, will call callback with a given userdata object only once, and then consumes the userdata. As a result, the userdata object is constructed by MakeUserdata as a unique_ptr managed object, then released as an unowned pointer and post to native device, and finally consumed and deleted by ForwardToServer-wrapped callback function. As long as the callback function will be called once and only once, the memory of userdata object is managed properly. However, for device-level callbacks, we do something different. The registered userdata will be used one or more time, or never used at all, depending on native device. Therefore, dawn_wire server have to take care of its life cycle, recording userdata objects for each device (likely in deviceInfo), and delete them when shutting down. I have tried, and met some tricky technical problem. \n    b) Generalized design of DeviceBase and CallbackTask. Since we can\u0027t assume the type of userdata registered in DeviceBase, it can only be void*, rather than some fancy shared pointer or weak pointer. So if we just register a void* pointing to the dawn_wire server managed userdata object, callback tasks still face the problem of checking if this object is already released by server. In current patchset, we bypass this problem by making sure that device-level callbacks descriptor is not expired, which means callbacks is not reset, which means server is still alive.",
      "parentUuid": "c89b70c4_b129e257",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa81b991_b417454e",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-07-15T16:23:04Z",
      "side": 1,
      "message": "Oh sorry we didn\u0027t realize MakeUserdata wouldn\u0027t work here. The solution here looks like it would work but is very complicated (though merging userdata and callback together is a good idea).\n\nPreviously I said:\n\n\u003e Yeah I\u0027m not sure what\u0027s best here, we are going to have similar issues with other callbacks that we want to put on the callback queue. Maybe we should have a way to drain the callback queue without waiting for idle.\n\nI should have been more clear: I think calling Tick() is sufficient because the last thing that Tick() does is clear all the callback tasks. This means that if we only add a Tick+comment at the end of ClearDeviceCallbacks, it should be sufficient to fix the issue.\n\nIf that works, then it is much simpler (and should work with the long-term solutions of using WebGPU in native, even if Tick disappears, their will be a wgpu::Instance::ProcessEvents or equivalent function). Sorry you went into a rabbit hole with the MakeUserdata path.",
      "parentUuid": "ec1744cb_397f8ca5",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d6cd88c2_067289fb",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1006,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2021-07-20T05:28:59Z",
      "side": 1,
      "message": "In this CL I use a simple way to make things work. Every time the registered callback function is going to change, we first trigger all deferred callback tasks, so that they will see the unchanged callback and userdata. On the other hand, callback tasks doesn\u0027t store callback function and userdata pointers anymore, they just go to DeviceBase and use the (unchanged yet) callback function and userdata. In this way we can ensure that all tasks will be triggered and run correctly. Also, dawn_wire server will call the callback setting API in DeviceBase directly (through mProcs table), which will not return until all deferred callback tasks are done. In this way, dawn_wire shutting down can be block until all related callback tasks are done, since it must clear the registered callback in native device before shutting down.",
      "parentUuid": "fa81b991_b417454e",
      "revId": "5b3c96fb58a0af11de6879cbf801972a92dfdba5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}