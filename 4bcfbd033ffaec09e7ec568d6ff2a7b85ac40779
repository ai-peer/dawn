{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "28ca1574_2a732d93",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 8
      },
      "lineNbr": 18,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-14T06:04:32Z",
      "side": 1,
      "message": "is \u003cfunctional\u003e used in this class?",
      "range": {
        "startLine": 18,
        "startChar": 0,
        "endLine": 18,
        "endChar": 21
      },
      "revId": "4bcfbd033ffaec09e7ec568d6ff2a7b85ac40779",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "244362a3_7d28727c",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 8
      },
      "lineNbr": 76,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-06-14T13:38:19Z",
      "side": 1,
      "message": "nit: Maybe we should erase that entry if TryGetRef fails.",
      "revId": "4bcfbd033ffaec09e7ec568d6ff2a7b85ac40779",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d6b38026_b805678d",
        "filename": "src/dawn/common/RefCounted.cpp",
        "patchSetId": 8
      },
      "lineNbr": 67,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-06-14T13:38:19Z",
      "side": 1,
      "message": "Can we have short descriptions of why the relaxed memory orders are enough?",
      "range": {
        "startLine": 67,
        "startChar": 55,
        "endLine": 67,
        "endChar": 75
      },
      "revId": "4bcfbd033ffaec09e7ec568d6ff2a7b85ac40779",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c839ef69_5d190531",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 8
      },
      "lineNbr": 65,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-06-14T13:38:19Z",
      "side": 1,
      "message": "optional nit: This assert could potentially be in ContentLessObjectCache\u0027s destructor.\n\nTurns out that\u0027s already the case so this can be removed!",
      "revId": "4bcfbd033ffaec09e7ec568d6ff2a7b85ac40779",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0143746e_87146587",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 8
      },
      "lineNbr": 1000,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-06-14T13:38:19Z",
      "side": 1,
      "message": "In the future we could have a CachedContentLessObject class that all CocntentLessCaches expect and that holds the WeakRef. Then we could move result-\u003eSetContentHash into the ContentLessCache logic since it\u0027s always done.",
      "revId": "4bcfbd033ffaec09e7ec568d6ff2a7b85ac40779",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbd8ef93_1ac2bde2",
        "filename": "src/dawn/native/Device.h",
        "patchSetId": 8
      },
      "lineNbr": 235,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-14T06:04:32Z",
      "side": 1,
      "message": "Device.h is included everywhere so we should try to keep it smaller if possible.\n\n\nYou *might* be able to only declare something like this in the header:\n\n```\ntemplate \u003ctypename RefCountedT, typename BlueprintT, typename CreateFn\u003e\ndecltype(std::declval\u003cCreateFn\u003e()())\nGetOrCreate(ContentLessObjectCache\u003cRefCountedT, BlueprintT\u003e\u0026 cache,\n            BlueprintT* blueprint,\n            CreateFn createFn);\n```\n\nand then define it in the cpp\n\n```\ntemplate \u003ctypename RefCountedT, typename BlueprintT, typename CreateFn\u003e\ndecltype(std::declval\u003cCreateFn\u003e()())\nDeviceBase::GetOrCreate(ContentLessObjectCache\u003cRefCountedT, BlueprintT\u003e\u0026 cache,\n                        BlueprintT* blueprint,\n                        CreateFn createFn) {\n   ...\n}\n```\n\nAlso, I think this function can be private, not public",
      "range": {
        "startLine": 232,
        "startChar": 4,
        "endLine": 235,
        "endChar": 40
      },
      "revId": "4bcfbd033ffaec09e7ec568d6ff2a7b85ac40779",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58730bf3_257f60bc",
        "filename": "src/dawn/native/Device.h",
        "patchSetId": 8
      },
      "lineNbr": 265,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-14T06:04:32Z",
      "side": 1,
      "message": "nit: this ASSERT should probably be done before other calls to result.Get()",
      "range": {
        "startLine": 265,
        "startChar": 8,
        "endLine": 265,
        "endChar": 40
      },
      "revId": "4bcfbd033ffaec09e7ec568d6ff2a7b85ac40779",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96d1bbd7_48a74d64",
        "filename": "src/dawn/tests/unittests/ContentLessObjectCacheTests.cpp",
        "patchSetId": 8
      },
      "lineNbr": 239,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-14T06:04:32Z",
      "side": 1,
      "message": "also, insert+insert\n\nand insert+find\n\nMay not need locking - like for insert+insert you can have N threads all create different objects with the same hash and insert them.\n\nThen you should be able to observe they all got the same result after the Insert - the same one that succeeded the Insert",
      "revId": "4bcfbd033ffaec09e7ec568d6ff2a7b85ac40779",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}