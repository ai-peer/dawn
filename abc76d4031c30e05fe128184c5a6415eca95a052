{
  "comments": [
    {
      "key": {
        "uuid": "a417bf07_e97745dd",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 40,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-14T01:38:32Z",
      "side": 1,
      "message": "BuddyResourceHeapAllocator allocator(128, 128, client);\n\nallocator.Allocate(64, 4, 0);\nallocator.Allocate(64, 4, 3);\n\nWon\u0027t these allocate in the same heapAllocation created at [1] even though they have different memory flags?",
      "range": {
        "startLine": 40,
        "startChar": 12,
        "endLine": 40,
        "endChar": 23
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4808b963_fcd1ee7b",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-16T16:27:15Z",
      "side": 1,
      "message": "The device will guarantee the allocation has matching (or compatible) memory/heap flags. Does that address your concern?",
      "parentUuid": "a417bf07_e97745dd",
      "range": {
        "startLine": 40,
        "startChar": 12,
        "endLine": 40,
        "endChar": 23
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c0a0f576_5c6caade",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 40,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-16T18:13:55Z",
      "side": 1,
      "message": "I figured this was the case. It looks like we don\u0027t store enough bits to track and ASSERT this is true, so I think we should add a comment here or in the header that the Device must guarantee this.",
      "parentUuid": "4808b963_fcd1ee7b",
      "range": {
        "startLine": 40,
        "startChar": 12,
        "endLine": 40,
        "endChar": 23
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fe33c23b_7efb47ee",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 40,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-17T01:41:31Z",
      "side": 1,
      "message": "As mentioned in previous CLs, why isn\u0027t the memoryType stored in the client itself to prevent this type of mistake? Having a double indirection from this to mClient to some HeapServiceAndResidencyManagement doesn\u0027t seem too bad.",
      "parentUuid": "c0a0f576_5c6caade",
      "range": {
        "startLine": 40,
        "startChar": 12,
        "endLine": 40,
        "endChar": 23
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ab50f87_0093ad51",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "If referring to memoryFlags (not memoryType) -  \n\nFlags are determined at allocation-time but could be cached in Buffer/Texture in a later CL.\n\nCurrently, only NONE is used.\n\nWe could cache heapFlags in the Heap objects in the next CL. However, it\u0027s not required for placed resource(s) + heap. CreateResource will fail when flags are not compatible.",
      "parentUuid": "fe33c23b_7efb47ee",
      "range": {
        "startLine": 40,
        "startChar": 12,
        "endLine": 40,
        "endChar": 23
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ed310968_1260a84d",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 58,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-14T01:38:32Z",
      "side": 1,
      "message": "[1]",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "249ce0ee_cbdd52c4",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 58,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "ed310968_1260a84d",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "25be2a84_af221554",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 74,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-14T01:38:32Z",
      "side": 1,
      "message": "nit: Usually we pass mutable objects by pointer. Although, in this function, it looks like it can be const\u0026 ?",
      "range": {
        "startLine": 74,
        "startChar": 48,
        "endLine": 74,
        "endChar": 84
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e9eeb0da_ffdcbb6e",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.cpp",
        "patchSetId": 5
      },
      "lineNbr": 74,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "25be2a84_af221554",
      "range": {
        "startLine": 74,
        "startChar": 48,
        "endLine": 74,
        "endChar": 84
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c9fb6053_13a93dd6",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.h",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-14T01:38:32Z",
      "side": 1,
      "message": "nit: in",
      "range": {
        "startLine": 36,
        "startChar": 7,
        "endLine": 36,
        "endChar": 11
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09ccc96c_d3f5d166",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.h",
        "patchSetId": 5
      },
      "lineNbr": 36,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c9fb6053_13a93dd6",
      "range": {
        "startLine": 36,
        "startChar": 7,
        "endLine": 36,
        "endChar": 11
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10733842_b9b0c737",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.h",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-17T01:41:31Z",
      "side": 1,
      "message": "Can we have a comment here saying that the ownership of mClient is transferred? Even better the constructor could take a unique_ptr.",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c829c48c_f659b0f8",
        "filename": "src/dawn_native/BuddyResourceHeapAllocator.h",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "10733842_b9b0c737",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "905b7025_deefe069",
        "filename": "src/dawn_native/Resource.h",
        "patchSetId": 5
      },
      "lineNbr": 22,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-13T20:21:36Z",
      "side": 1,
      "message": "I\u0027m still not 100% sure why we need this in the frontend: the BuddyResourceAllocator doesn\u0027t set the mResource member of ResourceMemoryAllocation. And nothing in the frontend calls GetResource. The design you did with the BuddyAllocator as a helper class is great as it allows using it as a utility in the backends such that the frontend never needs to know about the allocation shenanigans we are doing.\n\nOr do you plan to use ResourceBase and HeapBase in the frontend at some point?\n\nSorry to keep asking questions and restructurations like this. Landing the design little by little helps with review but we lost the big picture since we diverged from the design docs.",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "81bcc3e6_dcd4eb43",
        "filename": "src/dawn_native/Resource.h",
        "patchSetId": 5
      },
      "lineNbr": 22,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-16T16:27:15Z",
      "side": 1,
      "message": "I did plan to use ResourceMemoryAllocation::mResourceBase in the front-end. See the other comment.",
      "parentUuid": "905b7025_deefe069",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "00e09b3f_64ca5b9d",
        "filename": "src/dawn_native/Resource.h",
        "patchSetId": 5
      },
      "lineNbr": 22,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "81bcc3e6_dcd4eb43",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d3ee8c3_3364cec9",
        "filename": "src/dawn_native/ResourceMemoryAllocation.cpp",
        "patchSetId": 5
      },
      "lineNbr": 26,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-14T01:38:32Z",
      "side": 1,
      "message": "nit: const\u0026",
      "range": {
        "startLine": 26,
        "startChar": 55,
        "endLine": 26,
        "endChar": 70
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2253e860_e9eba32e",
        "filename": "src/dawn_native/ResourceMemoryAllocation.cpp",
        "patchSetId": 5
      },
      "lineNbr": 26,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "6d3ee8c3_3364cec9",
      "range": {
        "startLine": 26,
        "startChar": 55,
        "endLine": 26,
        "endChar": 70
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f896de2f_732b4ade",
        "filename": "src/dawn_native/ResourceMemoryAllocation.h",
        "patchSetId": 5
      },
      "lineNbr": 65,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-13T20:21:36Z",
      "side": 1,
      "message": "Please describe what the difference is between this mOffset and the mBlockOffset",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b8b848f_90fa549a",
        "filename": "src/dawn_native/ResourceMemoryAllocation.h",
        "patchSetId": 5
      },
      "lineNbr": 65,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f896de2f_732b4ade",
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4f38e98d_475292df",
        "filename": "src/dawn_native/ResourceMemoryAllocator.h",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-13T20:21:36Z",
      "side": 1,
      "message": "HeapAllocator now that it deals with Heaps ?",
      "range": {
        "startLine": 23,
        "startChar": 10,
        "endLine": 23,
        "endChar": 33
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff4b1e4d_fd9d6919",
        "filename": "src/dawn_native/ResourceMemoryAllocator.h",
        "patchSetId": 5
      },
      "lineNbr": 23,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Ack.",
      "parentUuid": "4f38e98d_475292df",
      "range": {
        "startLine": 23,
        "startChar": 10,
        "endLine": 23,
        "endChar": 33
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6819d774_50c57e18",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-13T20:21:36Z",
      "side": 1,
      "message": "Wouldn\u0027t this corrspond to HeapBase instead? It encapsulates a VkMemory which is exactly like an ID3D12Heap",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "767870ea_2c190bb2",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-14T01:38:32Z",
      "side": 1,
      "message": "+1\n\nI think the separation between Resource and Heap is messy right now because the backend doesn\u0027t handle actual suballocation yet. This class really should be a Heap even though we use it as if it\u0027s a Resource everywhere else. I think the distinction will clear up in later patches.",
      "parentUuid": "6819d774_50c57e18",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b4ded47e_3594f693",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-16T16:27:15Z",
      "side": 1,
      "message": "It needs to have the same memory type used by ResourceMemoryAllocation. \n\nIf we used HeapBase, the resource allocation would be unusable by the D3D API. For Vulkan, it wouldn\u0027t matter.\n\nVkDeviceMemory is not the same as ID3D12Heap. VkDeviceMemory can represent virtual and physical addresses. ID3D12Heap represents only physical (but not virtual) addresses. I think D3D12\u0027s equivalent of vkDeviceMemory is more ID3D12Pagable.\n\nWe could either: 1) move BuddyResourceHeapAllocator to the D3D12 back-end (requires separate Resource and Heap types) OR rather than combine them, we 2) keep the BuddyResourceHeapAllocator in the front-end by adding a Vulkan-like \"device memory\" type which both ResourceBase and HeapBase inherit from (ie. MemoryBase).\n\nI\u0027m in favor of the latter. WDYT?",
      "parentUuid": "6819d774_50c57e18",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5017782a_097870b4",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-17T01:41:31Z",
      "side": 1,
      "message": "I don\u0027t understand your comment, why would this make the allocation unusable for D3D12? I\u0027m suggesting wrapping VkDeviceMemory handles in HeapBase like we wrap ID3D12Heaps.\n\nVkDeviceMemory is an allocation of physical pages just like D3D12. VkBuffer or VkTexture are the allocations of virtual memory. You can see this in the fact that you can create sparse VkBuffer/VkTexture but not VkDeviceMemory.",
      "parentUuid": "b4ded47e_3594f693",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ee20997_481b59e4",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-18T01:14:13Z",
      "side": 1,
      "message": "ResourceMemoryAllocation expects a ResourceBase and if we use HeapBase instead (assuming HeapBase contains ID3D12Heap), then [Committed|Placed]ResourceAllocator returns a ResourceMemoryAllocation with the wrong back-end memory type on D3D. :(\n\nSince BuddyResourceHeapAllocator could work either by 1) offset into CommittedResource/VKDeviceMemory OR 2) PlacedResource + Heap. \n\nI think we\u0027ll benefit from a new MemoryBase type.\n\nMemoryBase could either contain a committed resource or heap (for D3D12) and a vkDeviceMemory (for Vulkan). Then we have ResourceMemoryAllocation[Vk|D3D] which uses the memory type expected by their API - Vk uses vkDeviceMemory and D3D uses ID3D12Resource.\n\nWDYT?",
      "parentUuid": "5017782a_097870b4",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d63bff08_e33d1938",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-09-18T02:02:57Z",
      "side": 1,
      "message": "One confusing aspect for me is that the classes that are supposed to be generic across all backends have names like \"heap\" which is a specific D3D datatype. Even in the D3D backend, a \u0027heap\u0027 can be implemented as a committed resource with one allocation, which is even more confusing.\n\nTo me, seems like we should have two class hierarchies. MemoryBlocks and Allocations. MemoryBlocks contain one or more allocations within a memory block. If you have better name than \"memory block\" feel free to suggest. \n\nIn the D3D backend, there are two subclasses of MemoryBlocks: HeapMemoryBlocks and CommittedResourceMemoryBlocks. A HeapMemoryBlock contains a pointer to an ID3D12Heap.  A CommittedResourceMemoryBlock contains a pointer to a ID3D12Resource, which is created as a committed resource. There would only be one kind of Allocation, a ResourceAllocation which contains a pointer to a D3D12Resource. The resource can either be a placed resource or a pointer to the same committed resource in the CommittedResourceMemoryBlock.  \n\nIn the Vulkan backend, the one subclass of MemoryBlock is DeviceMemoryBlock, which contains a VkDeviceMemory handle. On the allocation side, there would simply be DeviceMemoryAllocation which just contains an offset into the VkDeviceMemory owned by the DeviceMemoryBlock class.  \n\nThoughts?",
      "parentUuid": "5ee20997_481b59e4",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5078cf31_e0b009f1",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-19T03:11:29Z",
      "side": 1,
      "message": "Hold on, this is much more complicated than it needs to be no?\n\nA HeapBase is something that is suballocated from, either ID3D12Heap or VkDeviceMemory. The ResourceMemoryAllocator should be renamed to HeapAllocator and hand out HeapBase objects to the BuddyResourceAllocator.\n\nThe BuddyResourceAllocator returns a ResourceMemoryAllocation which is the combination of a HeapBase, an offset in that HeapBase and whatever metadata the BuddyResourceAllocator needs to track state. Basically the following:\n\n struct ResourceMemoryAllocation {\n   HeapBase* heap;\n   uint64_t offsetInHeap;\n   BuddyResourceAllocatorMetadata metadata; // (contains the offset in the large buddy system)\n }\n\nThe backends call BuddyResourceAllocator, create a backend specific resource using the HeapBase and offset, then store it in backend::Buffer / backend::Texture. The frontend never gets to see ID3D12Resource or VkImage / VkBuffer and ResourceBase is removed.",
      "parentUuid": "d63bff08_e33d1938",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aea6d1ca_fa5fb0df",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-20T17:01:24Z",
      "side": 1,
      "message": "@CW\n\n1. How does backend::[Buffer|Texture] get at the ID3D12Resource when BuddyResourceAllocator returns a ResourceMemoryAllocation that\u0027s only backed by a ID3D12Heap?\n\n2. Likewise, what does CommittedResourceAllocator now return? A heap?!?\n\nSo far, we either call Resource a Heap (confusing), merge them together (still confusing), or separate memory/allocation per backend (more complicated).\n\nThe latter approach seems reasonable to me.",
      "parentUuid": "5078cf31_e0b009f1",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50c0e822_d17e73bb",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-20T17:18:37Z",
      "side": 1,
      "message": "1) Buffer / Texture creates its resource internally using the memory allocation (or the Device does, but not the memory allocator). The allocator doesn\u0027t need to know about the ID3D12Resource objects because their job is to hand out memory blocks, not fully created resources.\n\n2) I thought on the review for CommittedResourceAllocator we discussed it would be better to just create a heap and createPlacedResource on it so all the code paths are unified for now. So either we change it to do that, or we change CommittedResourceAllocator to return both an ID3D12Resource and a ResourceMemoryAllocation.\n\n2 again) what could happen is the following, Buffer when initialized calls Device::CreateResource (very pseudo-codish)\n\n  using D3D12ResourceAllocation \u003d std::pair\u003cResourceMemoryAllocation, ComPtr\u003cID3D12Resource\u003e;\n\n  ResultOrError\u003cD3D12ResourceAllocation\u003e Device::CreateResource(const RESOURCE_DESCRIPTOR* desc) {\n    // Of course there would be more error handling\n    if (ResourceWouldBeBig(desc)) {\n      resource \u003d CreateCommittedResource\n      return {InvalidAllocation, resource};\n    } else {\n      allocation \u003d mBuddyAllocator.allocate(descriptor.size);\n      resource \u003d CreatePlacedResource\n      return {allocation, resource}\n    }\n}",
      "parentUuid": "aea6d1ca_fa5fb0df",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19bc57c1_c9cf9b43",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T18:28:52Z",
      "side": 1,
      "message": "Thanks for clarifying. Looks very similar to the other suggestions. I do plan on (2).\n\nI\u0027ve revised the CL with separate allocation types and replaced ResourceHeap with MemoryBase to be consistent.",
      "parentUuid": "50c0e822_d17e73bb",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ae3d68ac_73cf083e",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-23T22:08:34Z",
      "side": 1,
      "message": "Patchset 7 still is still confusing where ResourceMemoryAllocation in D3D12 contains an ID3D12Resource while in Vulkan it contains a VkDeviceMemory. These are not the same concepts in their respective APIs.\n\nThe end state we want is the \"2 again)\" above. In that end state, there is only the frontend ResourceMemoryAllocation, MemoryBase and its backend classes (imho Memory is a bit generic because it could also be CPU memory to malloc into, but we can deal with that later), and there is no need to have backend classes for ResourceMemoryAllocation since it\u0027s just a pair. (a backend allocation has-a frontend allocation info, but not is-a frontend allocation info, it will help save some awkwardness when implementing buddy allocation in the backends).",
      "parentUuid": "19bc57c1_c9cf9b43",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "654aaa0e_7d1a404f",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-23T22:52:30Z",
      "side": 1,
      "message": "If the only issue is preferring to return a (resource, allocation) tuple where allocation wraps a MemoryBase* then I think we\u0027re in good shape.",
      "parentUuid": "ae3d68ac_73cf083e",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de7d183f_1e40445a",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-23T23:07:29Z",
      "side": 1,
      "message": "That\u0027s a minor issue. The bigger ones noted above is that:\n 1 - MemoryBase should map to ID3D12Heap and VkDeviceMemory while ResourceMemoryAllocation should map to ID3D12Resource or VkBuffer/VkImage.\n 2 - This patch has multiple orthogonal changes and should be split.",
      "parentUuid": "654aaa0e_7d1a404f",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cde2191a_10b2eb30",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-24T23:15:51Z",
      "side": 1,
      "message": "\u003e Patchset 7 still is still confusing where ResourceMemoryAllocation in D3D12 contains an ID3D12Resource while in Vulkan it contains a VkDeviceMemory\n\nID3D12Resource can behave the same as vkDeviceMemory.\n\n\u003e VkDeviceMemory while ResourceMemoryAllocation should map to ID3D12Resource or VkBuffer/VkImage\n\nLooking at the pseudo-code, shouldn\u0027t this be?\n\n\u003e using VkResourceAllocation \u003d std::pair\u003cResourceMemoryAllocation, vkDeviceMemory\u003e;\n\nAlso, it might not be obvious what allocation.first means (or allocation.GetMemory) vs D3D12Allocation.GetResource().",
      "parentUuid": "de7d183f_1e40445a",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "42bde981_164c3d7a",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-09-25T22:51:45Z",
      "side": 1,
      "message": "\u003e \u003e Patchset 7 still is still confusing where ResourceMemoryAllocation in D3D12 contains an ID3D12Resource while in Vulkan it contains a VkDeviceMemory\n\u003e \n\u003e ID3D12Resource can behave the same as vkDeviceMemory.\n\u003e \nIn what respect? (that they are the unit of mapping isn\u0027t really useful)\n\n\u003e \u003e VkDeviceMemory while ResourceMemoryAllocation should map to ID3D12Resource or VkBuffer/VkImage\n\u003e \n\u003e Looking at the pseudo-code, shouldn\u0027t this be?\n\u003e \nThe ResourceMemoryAllocation contains a HeapBase* so no?\n\n\u003e \u003e using VkResourceAllocation \u003d std::pair\u003cResourceMemoryAllocation, vkDeviceMemory\u003e;\n\u003e \n\u003e Also, it might not be obvious what allocation.first means (or allocation.GetMemory) vs D3D12Allocation.GetResource().\n\nGood point, let\u0027s make it a struct!",
      "parentUuid": "cde2191a_10b2eb30",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d940dd1b_ca3d8de0",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-26T00:49:32Z",
      "side": 1,
      "message": "\u003e In what respect? (that they are the unit of mapping isn\u0027t really useful)\n\nThey both represent memory/heap referenced by a handle (ie. ResourceMemoryAllocation).\n\nFor example, UploadHandle \u003d\u003e ID3D12Resource and DeviceMemoryAllocation \u003d\u003e vkDeviceMemory.\n\nThe former is only modified to be generic where it uses a ID3D12Resource directly and the latter (DeviceMemoryAllocation) already exists (in MemoryAllocator.h) where it also has the same definition as vulkan::ResourceMemoryAllocation.\n\n\u003eGood point, let\u0027s make it a struct!\n\nRather than making more handle types, I propose we reuse the existing ones. Thoughts?",
      "parentUuid": "42bde981_164c3d7a",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9961b7b4_a3b6199a",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-30T04:17:50Z",
      "side": 1,
      "message": "\u003e \u003e In what respect? (that they are the unit of mapping isn\u0027t really useful)\n\u003e They both represent memory/heap referenced by a handle (ie. ResourceMemoryAllocation).\n\nI think it would be most accurate to say that ID3D12Heap and VkDeviceMemory are the memory/heap concepts. And Vulkan doesn\u0027t have an analogous ID3D12Resource.\n\nI think we should have ResourceMemoryAllocation only contain the offsets and ID3D12Heap/VkDeviceMemory.\n\nThen, we move the creation of D3D12Resource out of the allocators so that only the D3D12 backend needs to handle it. We don\u0027t need a ResourceBase.\n\nThe allocators return ResourceMemoryAllocation which is just the heap and an offset. Then, the individual backends unpack that to either create a D3D12Resource or vkBindBufferMemory. \n\n(Casting and stuff omitted).\n\nResourceMemoryAllocation {\n  AllocationInfo mInfo;\n  uint64_t mOffset;\n  HeapBase* mHeap;\n  uint8_t* mMappedPointer;\n};\n\nd3d12::Buffer::Initialize\nResourceMemoryAllocation* allocation \u003d AllocateMemory(...);\nmResource \u003d CreatePlacedResource(allocation-\u003emHeap, allocation-\u003emOffset, ...);\n// We can have some some metadata in AllocationInfo to tag when to use a committed resource instead.\n\nvulkan::Buffer::Initialize\nResourceMemoryAllocation* allocation \u003d AllocateMemory(...);\nvkBindBufferMemory(..., allocation-\u003emHeap, allocation-\u003emOffset, ...);",
      "parentUuid": "d940dd1b_ca3d8de0",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40bfdfdb_4b16daf8",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-30T18:03:19Z",
      "side": 1,
      "message": "\u003e I think it would be most accurate to say that ID3D12Heap and VkDeviceMemory are the memory/heap concepts. And Vulkan doesn\u0027t have an analogous ID3D12Resource.\n\nWhat is the rational to omit ID3D12Resource? ID3D12Resource is also memory/heap. Per MSDN,\n\n\u003e ID3D12Resource interface. Encapsulates a generalized ability of the CPU and GPU to read and write to physical memory, or heaps [1].\n\n[1] https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nn-d3d12-id3d12resource\n\nDawn\u0027s resource memory type, ResourceHeap \u003d\u003e [Memory|Heap]Base, should reflect the fact ID3D12Resource OR ID3D12Heap is memory/heap.\n\nThe other suggestions SGTM or no strong preference.",
      "parentUuid": "9961b7b4_a3b6199a",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e8ef229_6d5adeca",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-30T18:17:09Z",
      "side": 1,
      "message": "\u003e What is the rational to omit ID3D12Resource?\n\nBecause Vulkan doesn\u0027t have a similar concept, so it doesn\u0027t fit at this level of abstraction. ID3D12Resource either wraps an implicit heap or is created to explicitly wrap a slice of a heap. It\u0027s strictly additive and we can use the \"Resource\" concept only on the D3D12 side.",
      "parentUuid": "40bfdfdb_4b16daf8",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d232cbbc_1cf3cac3",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-09-30T19:16:15Z",
      "side": 1,
      "message": "\u003e Because Vulkan doesn\u0027t have a similar concept, so it doesn\u0027t fit at this level of abstraction\n\nI\u0027m confused. I thought the level of abstraction is memory/heap. Both vkDeviceMemory and ID3D12Resource are memory/heap, respectively. If not, could you please explain?\n\n\u003e ID3D12Resource either wraps an implicit heap or is created to explicitly wrap a slice of a heap.\n\nThe details _how_ physical pages were mapped are irrelevant to the handle. Only the memory type needs to be coherent across back-ends.",
      "parentUuid": "3e8ef229_6d5adeca",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edc0cd60_fe368656",
        "filename": "src/dawn_native/vulkan/ResourceMemoryVk.h",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-09-30T22:07:29Z",
      "side": 1,
      "message": "\u003e I thought the level of abstraction is memory/heap. Both vkDeviceMemory and ID3D12Resource are memory/heap, respectively. \n\nSorry, I\u0027m not completely sure what you mean by this.\n\n---\n\nID3D12Heap[1] and VkDeviceMemory[2] are the actual memory allocations.\n\n[1] https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nn-d3d12-id3d12heap\n\u003e A heap is an abstraction of contiguous memory allocation, used to manage physical memory.\n\n[2] https://vulkan.lunarg.com/doc/view/1.0.26.0/linux/vkspec.chunked/ch10s02.html\n\u003e Device memory is memory that is visible to the device, for example the contents of opaque images that can be natively used by the device, or uniform buffer objects that reside in on-device memory.\n\n[3] https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource\n\u003e Creates both a resource and an implicit heap\n\n[4] https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource\n\u003e Creates a resource that is placed in a specific heap.\n\n[5] https://vulkan.lunarg.com/doc/view/1.0.26.0/linux/vkspec.chunked/ch11s06.html\n\u003e Device memory is allocated separately (see Section 10.2, “Device Memory”) and then associated with the resource.\n\n[3] and [4] indicate as well that the ID3D12Resource is not the heap. One of the functions has an implicit heap, where as one is given an explicit heap. An ID3D12Resource \"encapsulates a generalized ability of the CPU and GPU to read and write to physical memory, or heaps\" -- so it is the ability to write to a heap, but it is not the heap itself.\n\nIn Vulkan, memory is first allocated, and then a region is associated with some resource[5] using vkBindBufferMemory. This is analogous to how an ID3D12Resource provides the ability to read/write the physical memory.\n\nI think a good abstraction is the following:\n\n  Dawn Heap \u003d VkDeviceMemory | ID3D12Heap\n  Dawn Buffer \u003d VkBuffer | ID3D12Resource\n  Dawn Texture \u003d VkTexture | ID3D12Resource",
      "parentUuid": "d232cbbc_1cf3cac3",
      "range": {
        "startLine": 24,
        "startChar": 10,
        "endLine": 24,
        "endChar": 24
      },
      "revId": "abc76d4031c30e05fe128184c5a6415eca95a052",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}