{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c4618a6a_a2c6e193",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 146,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-08T21:56:07Z",
      "side": 1,
      "message": "nit: delete this and the ValidationUsage function",
      "range": {
        "startLine": 146,
        "startChar": 0,
        "endLine": 146,
        "endChar": 45
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "59464329_f31a4572",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 146,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-05-08T22:28:53Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c4618a6a_a2c6e193",
      "range": {
        "startLine": 146,
        "startChar": 0,
        "endLine": 146,
        "endChar": 45
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "533a0e38_f87e5044",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-08T21:56:07Z",
      "side": 1,
      "message": "could this be something like:\n\n```\nif (needsConstantBuffer \u0026\u0026 onlyNeedsConstantBuffer) {\n  mD3d11Buffer \u003d ...-\u003eCreateBuffer(GetUsage());\n  mD3D11ConstantBuffer \u003d mD3D11Buffer;\n} else {\n  mD3d11Buffer \u003d ...-\u003eCreateBuffer(GetUsage() \u0026 ~Uniform);\n  if (needsConstantBuffer) {\n    mD3D11ConstantBuffer \u003d ...-\u003eCreateBuffer(Uniform | CopyDst);\n  }\n}\n```\n\nthat way, mD3D11Buffer always points to the buffer; it\u0027s never null\nand mD3D11ConstantBuffer always points to the constant buffer if one is needed\n\nThen mD3D11Buffer is the one that receives all the mutations, and with the other comments, mD3D11ConstantBuffer gets updated when it needs to at the start of a SyncScope",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb01f35c_618c7834",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-05-08T22:28:53Z",
      "side": 1,
      "message": "With your suggestion, we will always copy whole buffer to the mD3d11ConstBuffer. However if user only modify some bytes of the buffer, copy whole range will be kind of waste. To avoiding tracking modified ranges, and make code simpler, so I just copy the modified part of the buffer to constant buffer in Buffer::Write() and Buffer::Copy() immediately.  And only do whole buffer copy, if the buffer is accessed as UAV.\n\nBTW, I think using a buffer with both uniform and other usages is not a common use case. And updating a buffer multiple times, and then using it for uniform, it should be very rare case. So I think it is not worth to the complexity to optimize the performance for this case.",
      "parentUuid": "533a0e38_f87e5044",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d7ad2c1_bd967d3e",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-08T22:46:26Z",
      "side": 1,
      "message": "ok it\u0027s fine to do Write and Copy immediately then, but I\u0027d still like to do the SyncScope-related changes for Storage+Uniform usage. it will be better to perform the copies at the beginning of the render pass instead of in the middle.\n\nI also think it\u0027s still preferable to have mD3D11Buffer be never-null, and then additional;y have mD3d11ConstantBuffer updated when necessary when it is non-null.",
      "parentUuid": "eb01f35c_618c7834",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a64c9a33_b7f5cd6f",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-05-08T23:57:08Z",
      "side": 1,
      "message": "User can switch pipelines and bind groups in one render pass or compute pass. A buffer can be modified and read in the same pass with two draw or dispatch calls. So we cannot do the copy at beginning of a render pass or compute pass.\n\nIf we mD3d11Buffer is always non-null, we have to check mD3d11Buffer \u003d\u003d mD3d11ConstantBuffer to see if they are same, and then decide if copy is needed. I feel it is little bit weird. I changed the mD3d11Buffer to mD3d11NonConstantBuffer and add more comment to make the code more readable.",
      "parentUuid": "9d7ad2c1_bd967d3e",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2d0cc8c_e56d5e1e",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-09T00:03:20Z",
      "side": 1,
      "message": "you would do it with the sync scope which is per-dispatch in a compute pass.\n\nin webgpu, it\u0027s not valid to use a buffer as both storage usage and uniform usage in a single render pass. That\u0027s a read/write usage conflict.\nsee https://gpuweb.github.io/gpuweb/#ref-for-usage-scope-validation",
      "parentUuid": "a64c9a33_b7f5cd6f",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "665e4cce_7ea468d4",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-05-09T00:11:44Z",
      "side": 1,
      "message": "See ComputeStorageBufferBarrierTests.UniformToStorageAddPingPongInOnePass [1],\nit just has one pass, and switches bind groups for each DispatchWorkgroups() calls. Right now. we update constant buffer, just before bind constant buffer to slot. It much easier. We just need to iterator resources once in BindGroupTracker::ApplyGroup(). It is not necessary to iterator resource twice for each draw calls or dispatch calls.\n\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/tests/end2end/ComputeStorageBufferBarrierTests.cpp;l\u003d331?q\u003dUniformToStorageAddPingPongInOnePass\u0026ss\u003dchromium",
      "parentUuid": "c2d0cc8c_e56d5e1e",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7b4f47f_2bc57e31",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-09T00:42:52Z",
      "side": 1,
      "message": "sorry I replied in the wrong thread.\n\n\u003e can you mark the state dirty in another function then? it\u0027s not right to perform a state mutation like this in a getter",
      "parentUuid": "665e4cce_7ea468d4",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c184296_18a98f01",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-05-09T12:40:55Z",
      "side": 1,
      "message": "The synchronization scope in compute passes are per dispatch. If you look at other backends, you\u0027ll see that they handle SyncScopes per dispatch, and per render pass. +1 on separating the EnsureUsageUpToDate(usage) or similar. Marking as dirty in bindgroup creation will only potentially help for the first usage but not if the bind group is reused.",
      "parentUuid": "d7b4f47f_2bc57e31",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e31c0fd1_7bd2c8e4",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 195,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-05-09T16:51:55Z",
      "side": 1,
      "message": "D3D11 doesn\u0027t allow a buffer being bound to UAV and other slots at same time. so we always unbound resources when a bind group is replaced. It will guarantee a resource will never be reused if resource is bound as UVA in between. So I think call `MarkMutated()` before binding it to UAV slot, and call `EnsureConstantBufferIsUpdated()` before binding it to constant slots should be sufficient.",
      "parentUuid": "7c184296_18a98f01",
      "range": {
        "startLine": 158,
        "startChar": 4,
        "endLine": 195,
        "endChar": 5
      },
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8ae577c_d7550af5",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 387,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-08T21:56:07Z",
      "side": 1,
      "message": "instead of mutable access here when creating the view, I suggest an alternative:\n\nIn CommandBufferD3D11,\n\nlook at the current compute dispatch or render pass\n\nGetResourceUsages().computePasses[computePassIndex].dispatchUsages[dispatchIndex]\nGetResourceUsages().renderPasses[renderPassIndex]\n\nYou can iterate through the buffers and see which ones are used with a mutable resource usage. Then you can mark it like buffer-\u003eWasMutated(commandContext) or something. Same thing for CopyXtoBuffer commands. This increments a serial internal to the buffer - perhaps called MutationSerial.\nThe same loop iteration checks buffers that are used with Uniform usage and does buffer-\u003eEnsureConstantBufferUpdated(commandContext);\n\nThis way, we batch all the mutation and copies at the start of render passes and tie it to the existing SyncScope concept.",
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c343b2ed_91355803",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 387,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-05-09T00:30:13Z",
      "side": 1,
      "message": "can you mark the state dirty in another function then? it\u0027s not right to perform a state mutation like this in a getter",
      "parentUuid": "c8ae577c_d7550af5",
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3e9807dd_3baad53a",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 387,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-05-09T16:51:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c343b2ed_91355803",
      "revId": "8ba6efed08391b4311284f43670f0c688e24184a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}