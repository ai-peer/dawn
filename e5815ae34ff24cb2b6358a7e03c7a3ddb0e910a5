{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3e7e34e3_d820851e",
        "filename": "src/dawn/tests/DawnTest.cpp",
        "patchSetId": 46
      },
      "lineNbr": 1481,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-05T21:10:35Z",
      "side": 1,
      "message": "do we need an atomic bool?\nisn\u0027t the bool set to true by only a single thread? WaitABit should invoke the callback on the calling thread.\n\nEdit: nevermind. I\u0027ve realized that if two threads are waiting, which thread invokes the callback is a race. could you comment explaining why we have the atomic?",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "138adf50_87ea37b6",
        "filename": "src/dawn/tests/DawnTest.cpp",
        "patchSetId": 46
      },
      "lineNbr": 1530,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-05T21:10:35Z",
      "side": 1,
      "message": "MapSlotsSynchronously occurs on test suite TearDown.\nperhaps it doesn\u0027t need a lock? instead we can make mNumPendingMapOperations atomic",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9295f759_5a9d35c6",
        "filename": "src/dawn/tests/DawnTest.cpp",
        "patchSetId": 46
      },
      "lineNbr": 1530,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-06T13:11:55Z",
      "side": 1,
      "message": "`mNumPendingMapOperations` is modified inside `SlotMapCallback` alongside other test\u0027s states. There is already a mutex used in that method to protect `mNumPendingMapOperations` and other states, hence I think it\u0027s overkill to use additional atomic wrapper for that variable.\n\nWe could use relaxed memory order and mutex\u0027s locking scope in `SlotMapCallback` and check if the atomic\u0027s value is zero in `MapSlotsSynchronously`. However, I think it is not safe, since the order is not guaranteed .i.e. even if `mNumPendingMapOperations` is zero, it doesn\u0027t mean all pending works have finished (it is only guaranteed if we use the same mutex in `MapSlotsSynchronously`). Unless we use strong memory order and it\u0027s basically an overkill (with mutex + strong ordered atomic, why not just use mutex anw).",
      "parentUuid": "138adf50_87ea37b6",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "516df569_90938c44",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 1,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-05T21:10:35Z",
      "side": 1,
      "message": "the tests here seem quite valuable. what\u0027s the rationale for giving the other single-threaded tests a parameterization to enable the synchronization?\n\ndoes that provide coverage not already included here?",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3330a5f_160d7e53",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 1,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-06T10:01:35Z",
      "side": 1,
      "message": "My intention was that enabling locking won\u0027t make normal operations (tested by various single threaded tests) deadlock. It\u0027s possible we miss some cases that could cause deadlock. Hence testing the single threaded tests both with and without the implicit synchronization.\n\nWe could add tests to the `MultithreadTests.cpp`. But doing so duplicating too many tests, it\u0027s infeasible to replicate every single threaded test, enabling implicit synchronization and add them to `MultithreadTests.cpp`.\n\nBtw, is there an easy way to tell every single threaded test to both test with \u0026 without implicit synchronization? Right now I only choose a subset of them and manually enabling synchronization via a parameter.",
      "parentUuid": "516df569_90938c44",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "282912ae_633974f8",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 1,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-06T11:06:17Z",
      "side": 1,
      "message": "nvm. Created another CL to enable implicit sync via command line, in preparing for a CI config. https://dawn-review.googlesource.com/c/dawn/+/126580",
      "parentUuid": "d3330a5f_160d7e53",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2dce7eeb_90fafc05",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 190,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-05T21:10:35Z",
      "side": 1,
      "message": "the data can be prepared once for all threads",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "370523cf_6a30ba92",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 234,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-05T21:10:35Z",
      "side": 1,
      "message": "unit: capitalize the lambda name. same below",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02c3751f_4af1ef44",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 248,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-05T21:10:35Z",
      "side": 1,
      "message": "why guarded?\nthere shouldn\u0027t be a race to read it because the callback should be called strictly once.\nthere shouldn\u0027t be a race to write it because we spin waiting for isCompleted. because we wait to see isCompleted written, then the compute pipeline must also be written",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25f701ef_93c63f54",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 248,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-06T10:01:35Z",
      "side": 1,
      "message": "Because out of order execution could let `pipeline` be written after `isCompleted` is written from the waiting thread\u0027s point of view. The atomic is to guarantee that that re-ordering won\u0027t happen.\n\n`WaitABit()` calls `Instance.ProcessEvents`. Hence the callback can happen on any thread that unrelated to the calling thread\u0027s device.",
      "parentUuid": "02c3751f_4af1ef44",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "041240ef_de986603",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 333,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-05T21:10:35Z",
      "side": 1,
      "message": "ditto - why guarded?",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5fe974b_7e014170",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 333,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-06T13:33:34Z",
      "side": 1,
      "message": "Same as above.",
      "parentUuid": "041240ef_de986603",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a61f565b_cf968a84",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 46
      },
      "lineNbr": 424,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-05T21:10:35Z",
      "side": 1,
      "message": "why tick?",
      "revId": "e5815ae34ff24cb2b6358a7e03c7a3ddb0e910a5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}