{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "73e54188_92905ef9",
        "filename": "src/dawn_native/Buffer.h",
        "patchSetId": 12
      },
      "lineNbr": 63,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "This could be landed separately to de-risk the CL and start landing chunks of it.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "560a7e32_a0848c03",
        "filename": "src/dawn_native/Buffer.h",
        "patchSetId": 12
      },
      "lineNbr": 146,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "nits: we should write the coding style somewhere. In general we avoid putting implementation in the .h even for simpler getters, assuming LTCG will inline them.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "626ab6b5_93924bf7",
        "filename": "src/dawn_native/CommandAllocator.cpp",
        "patchSetId": 12
      },
      "lineNbr": 61,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "u-nit: ditto coding style, but in general we spell out simple types instead of using auto (I think that\u0027s the case in Chromium too?)",
      "range": {
        "startLine": 61,
        "startChar": 13,
        "endLine": 61,
        "endChar": 18
      },
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e812582d_c53d9c29",
        "filename": "src/dawn_native/CommandAllocator.h",
        "patchSetId": 12
      },
      "lineNbr": 79,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "Nice changes, probably worth landing separately with a tiny test for AcquireCommandBlocks.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38609181_cba3d12b",
        "filename": "src/dawn_native/CommandEncoder.cpp",
        "patchSetId": 12
      },
      "lineNbr": 985,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "FYI, optional given the larger comments. There\u0027s facility for using the CommandAllocator for inline data. It might help with locality slightly for this command.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af1d1631_92fe797d",
        "filename": "src/dawn_native/EncodingContext.cpp",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "note: I have some concerns about the amount of magic that happens in the render encoder with the pending commands switching etc. It seems that this file has the potential to become more magic over time and difficult to modify without breaking the flow of state for other aspects of its operation.\n\nAlso with the current approach the backends can\u0027t schedule the validation commands in the past to optimize the number of GPU stalls due to memory barriers.\n\nI\u0027m not sure what to do about this though.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40ad0f71_eb094676",
        "filename": "src/dawn_native/EncodingContext.cpp",
        "patchSetId": 12
      },
      "lineNbr": 102,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "For D3D12 emulation of first_instance we\u0027ll need to do this unconditionally.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9da6344_7e46f850",
        "filename": "src/dawn_native/EncodingContext.h",
        "patchSetId": 12
      },
      "lineNbr": 85,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "Nice, the overloads were a bit too smart for their own good.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6986ff8c_b4b197e8",
        "filename": "src/dawn_native/InternalPipelineStore.h",
        "patchSetId": 12
      },
      "lineNbr": 43,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "It\u0027s interesting that the internal pipeline store is gaining more stuff. Could be an InternalObjectStore. We have a couple other ones on the device already.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3120d2a_8e16f22d",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 12
      },
      "lineNbr": 41,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "Note: in a follow up or as a longer term TODO we should have some kind of reporting if some validation was hit so that we can warn developers. Otherwise it will be difficult for them to figure out what happened when a draw gets silently dropped.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efa1be7d_55b3bd57",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 12
      },
      "lineNbr": 56,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "FYI the workgroup size should be at least 64 to fully take advantage of desktop GPUs (AMD is 64 or 64/32 for newer generations, Nvidia is 32).",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1959fdb8_da4831a9",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 12
      },
      "lineNbr": 58,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "If the number of draws isn\u0027t a multiple of the workgroup_size.x then we\u0027ll access buffer out of bounds and risk being incorrect. We could pass the number of draws as an argument in a uniform buffer to early-out when this is the case.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea1392db_c450620b",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 12
      },
      "lineNbr": 66,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "I don\u0027t know if the WebGPU spec allows clamping here. But at least for first_instance validation, the draw should be nooped if it isn\u0027t 0.\n\n\u003e If it is not zero the drawIndexedIndirect() call will be treated as a no-op.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30d026e5_6683d7b3",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 12
      },
      "lineNbr": 163,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "Note, but might not matter. We have limits for the maxStorageBufferBindingSize and maxDispatchDimensions for x so for REALLY LARGE amounts of drawIndexedIndirect (128MB / size of per drawcall data, or 64 * 64k) we might have to chunk.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "047d142e_160babac",
        "filename": "src/dawn_native/RenderValidationMetadata.cpp",
        "patchSetId": 12
      },
      "lineNbr": 37,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "Kind of a nit, but CommandBufferStateTracker is supposed to be private-ish to the encoders. Maybe we can just pass the index buffer size and format as argument instead of the whole state tracker.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87c31b40_510a2933",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 12
      },
      "lineNbr": 909,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "WriteBuffer is supposed to happen immediately in the queue: it gets some staging allocation, copies the data into it then records the buffer-to-buffer copy in the \"pending command list\". However it\u0027s not clear what the pending command list is here. It might happen to work but it\u0027s very non-obvious so imho it we should directly get staging and copy the logic from the CopyBufferToBuffer here as well. Alternatively we can change the RenderPassValidationEncoder to use a CopyBufferToBuffer instead. You can allocate a buffer mapped, write to it, unmap then schedule copies from it.",
      "revId": "fc84ff3083322091ab03e48eb70f5db9eb7344d2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}