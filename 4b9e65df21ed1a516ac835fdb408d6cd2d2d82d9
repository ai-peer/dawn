{
  "comments": [
    {
      "key": {
        "uuid": "4f69ada2_e51a9762",
        "filename": "src/dawn_native/vulkan/CommandBufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 377,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-10-09T19:27:15Z",
      "side": 1,
      "message": "Note: This is getting a little scary. Recording command buffers has side effects, like marking stuff as cleared. If it turns out we never execute the recordingContext-\u003ecommandBuffer because of an error, it better be a DEVICE_LOST error so everything stops immediately.\n\nSome initial thoughts:\n\n1) We could try to \"undo\" marking resources as initialized, and any other assumptions based on successful command buffer execution\n2) We could store pending side-effects-to-apply on the CommandRecordingContext and then apply them on successful submission.\n3) We could make sure all errors are fatal. (This is currently true)\n\nWhat do you think?",
      "range": {
        "startLine": 377,
        "startChar": 20,
        "endLine": 377,
        "endChar": 64
      },
      "revId": "4b9e65df21ed1a516ac835fdb408d6cd2d2d82d9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5809162b_9d4f5ab3",
        "filename": "src/dawn_native/vulkan/CommandBufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 377,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-10-10T13:53:12Z",
      "side": 1,
      "message": "I definitely think that we should be in the 3) case. There are three types of errors: validation (that happens before the backend or as a first step in a backend, for example for GLES 3 compat), out of memory for, only for resource creation, and everything else is unexpected and a device loss.\n\n1) is akin to exception safety and would be hugely complex and difficult to implement (and ensure doesn\u0027t break in the future).\n2) could actually make sense for optimizations, I don\u0027t see us using it for error handling.",
      "parentUuid": "4f69ada2_e51a9762",
      "range": {
        "startLine": 377,
        "startChar": 20,
        "endLine": 377,
        "endChar": 64
      },
      "revId": "4b9e65df21ed1a516ac835fdb408d6cd2d2d82d9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "153caa93_49c72c4b",
        "filename": "src/dawn_native/vulkan/CommandBufferVk.cpp",
        "patchSetId": 3
      },
      "lineNbr": 377,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-10-10T23:57:49Z",
      "side": 1,
      "message": "Okay, (3) sounds good to me. Maybe we can have Device::FatalConsumedError which will \"rethrow\" (rename) errors as DEVICE_LOST if they\u0027re not. My main concern is that we have to make sure that we never have other types of errors, which may be hard as things get more complex. Catching and rethrowing as device lost is safer.\n\nThen we can do device-\u003eFatalConsumedError(SubmitImpl(...))\n\nAlso: Right now EnsureSubresourceContentInitialized can have an OOM error if it can\u0027t allocate a big enough staging buffer to clear with.",
      "parentUuid": "5809162b_9d4f5ab3",
      "range": {
        "startLine": 377,
        "startChar": 20,
        "endLine": 377,
        "endChar": 64
      },
      "revId": "4b9e65df21ed1a516ac835fdb408d6cd2d2d82d9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}