{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a88a7fb5_bcb56f52",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-23T06:45:37Z",
      "side": 1,
      "message": "PTAL\nThe perf data remains basically same regarding this CL.",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "935b30a0_e152c04d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-24T09:18:11Z",
      "side": 1,
      "message": "My speculation of perf difference is essentially all about: a) `Map` + `CopySubResource` VS b)`UpdateSubResource`.\nCurrently we are using a) in Dawn, however it may not always be the best choice of UMA GPUs. This CL tries to reduce `Map` wait. Probably `CopySubResource` also weighs considerably.\n\nLikely we can write a tiny WebGPU benchmark to compare them on various GPUs.\nThe case could be simply to draw as many same triangles as possible. The position of triangle could be stored in a uniform buffer. We can update the uniform buffer respectively by:\na) mapping a staging buffer, and then copying to the uniform buffer.\nb) directly calling WriteBuffer on the uniform buffer with full-size data.",
      "parentUuid": "a88a7fb5_bcb56f52",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97208aa1_44e4905c",
        "filename": "src/dawn/native/Buffer.h",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-23T14:14:09Z",
      "side": 1,
      "message": "maybe we can always call MapAsyncImpl() when the last use serial is passed, so this new method is not necessary.",
      "range": {
        "startLine": 95,
        "startChar": 37,
        "endLine": 95,
        "endChar": 53
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d641415e_1cc9843a",
        "filename": "src/dawn/native/Buffer.h",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-23T14:48:34Z",
      "side": 1,
      "message": "nit: this could be next to MapAsyncImpl and called \"FinalizeMapAsync\". Implementation can be in the .cpp. It Could use a MaybeError.\n\nAlso can we have a TODO to use it in the GL backend as well?",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24e35b8c_033fa718",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 312,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-23T14:48:34Z",
      "side": 1,
      "message": "The content of the error is dropped on the floor and will be leaked I believe.",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3f8f6ca_cb7458ee",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-23T06:45:37Z",
      "side": 1,
      "message": "This assert was triggered during the dry-run on the Nvdia bots only. So it looks even when the fence serial has passed, mapping the buffer may still run into DXGI_ERROR_WAS_STILL_DRAWING.",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5d21a16_6df1eb70",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-23T14:14:09Z",
      "side": 1,
      "message": "Yeah. I tried it locally. This CL break many tests with NVidia GPU. I debugged one really small test which verifies a buffer\u0027s content by using CopyBufferToBuffer to copy data from an uniform buffer to a staging buffer, and then use MapAsync() to map the staging buffer for readback. However the Map() call returns still drawing error.\n\nI tried workaround the problem by not using the `DXGI_ERROR_WAS_STILL_DRAWING` flag in `OnPreMapCallback()`, and run motionmark, and motionmark doesn\u0027t have any improvement. Looks like there is some issues with NVidia driver.",
      "parentUuid": "d3f8f6ca_cb7458ee",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3fe4e5ef_57257d44",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-23T14:48:34Z",
      "side": 1,
      "message": "What was the last usage of that buffer? Does it trigger a SetAccess() (or whatever the name is?) Can we fall back by doing a wait in this case, and eventually debug what tracking is missing?\n\nThis would allow making this method return a MaybeError instead of Unknown map statuses, which streamlines the error handling. By losing the device in FinishImpl() if there is an error (using if (device-\u003eConsumedError(...)) {status \u003d unknown})",
      "parentUuid": "d3f8f6ca_cb7458ee",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdf076c8_5d5fb1a3",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-23T15:14:30Z",
      "side": 1,
      "message": "The last usage of the staging buffer is for a B2B copy as the dst buffer. It sets the last usage serial correctly at [1]. \n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/CommandBufferD3D11.cpp;l\u003d315?q\u003dCommandBufferD3D11.cpp\u0026ss\u003dchromium",
      "parentUuid": "3fe4e5ef_57257d44",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "324c5ed5_e3beb472",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-23T15:51:50Z",
      "side": 1,
      "message": "BTW, the test I debugged is [1]. It creates a buffer with data, and checks the buffer content with `EXPECT_BUFFER_U32_RANGE_EQ(myData.data(), buffer, 0, kDataSize)`, and the `EXPECT_BUFFER_U32_RANGE_EQ()` uses MapAsync() and trigger the still draw problem.\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/third_party/dawn/src/dawn/tests/end2end/BufferTests.cpp;l\u003d959?q\u003dMapWriteUsageLarg\u0026ss\u003dchromium",
      "parentUuid": "cdf076c8_5d5fb1a3",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79c92816_400a2f88",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-24T06:50:56Z",
      "side": 1,
      "message": "Thanks, Peng!\nSo it seems that the passed fence serial can\u0027t ensure the buffer is ready to be mapped without wait on Nvidia. We\u0027d better figure out this issue first before moving forward with this CL.",
      "parentUuid": "324c5ed5_e3beb472",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e989eae1_5e53b4e1",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 357,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-23T06:45:37Z",
      "side": 1,
      "message": "We could get rid of this wait by using compute shader CopyBufferToTexture.",
      "range": {
        "startLine": 357,
        "startChar": 90,
        "endLine": 357,
        "endChar": 95
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5645a542_6d33602e",
        "filename": "src/dawn/native/d3d11/DeviceD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 532,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-23T14:48:34Z",
      "side": 1,
      "message": "Instead of reimplementing this kind of logic, can\u0027t we use the DynamicUploader?",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}