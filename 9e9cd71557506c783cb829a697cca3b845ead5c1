{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a88a7fb5_bcb56f52",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-23T06:45:37Z",
      "side": 1,
      "message": "PTAL\nThe perf data remains basically same regarding this CL.",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "935b30a0_e152c04d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-24T09:18:11Z",
      "side": 1,
      "message": "My speculation of perf difference is essentially all about: a) `Map` + `CopySubResource` VS b)`UpdateSubResource`.\nCurrently we are using a) in Dawn, however it may not always be the best choice of UMA GPUs. This CL tries to reduce `Map` wait. Probably `CopySubResource` also weighs considerably.\n\nLikely we can write a tiny WebGPU benchmark to compare them on various GPUs.\nThe case could be simply to draw as many same triangles as possible. The position of triangle could be stored in a uniform buffer. We can update the uniform buffer respectively by:\na) mapping a staging buffer, and then copying to the uniform buffer.\nb) directly calling WriteBuffer on the uniform buffer with full-size data.",
      "parentUuid": "a88a7fb5_bcb56f52",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ffbb1300_a8babd4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-25T05:53:12Z",
      "side": 1,
      "message": "for UMA GPUs, to do a fair comparison, shouldn\u0027t we be mapping the uniform buffer directly? Peng added an extension to do this. See /dawn/docs/dawn/features/buffer_map_extended_usages.md\n\nit is only implemented on Metal now but we could do it for d3d11 as well",
      "parentUuid": "935b30a0_e152c04d",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97208aa1_44e4905c",
        "filename": "src/dawn/native/Buffer.h",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-23T14:14:09Z",
      "side": 1,
      "message": "maybe we can always call MapAsyncImpl() when the last use serial is passed, so this new method is not necessary.",
      "range": {
        "startLine": 95,
        "startChar": 37,
        "endLine": 95,
        "endChar": 53
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d641415e_1cc9843a",
        "filename": "src/dawn/native/Buffer.h",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-23T14:48:34Z",
      "side": 1,
      "message": "nit: this could be next to MapAsyncImpl and called \"FinalizeMapAsync\". Implementation can be in the .cpp. It Could use a MaybeError.\n\nAlso can we have a TODO to use it in the GL backend as well?",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24e35b8c_033fa718",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 312,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-23T14:48:34Z",
      "side": 1,
      "message": "The content of the error is dropped on the floor and will be leaked I believe.",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3f8f6ca_cb7458ee",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-23T06:45:37Z",
      "side": 1,
      "message": "This assert was triggered during the dry-run on the Nvdia bots only. So it looks even when the fence serial has passed, mapping the buffer may still run into DXGI_ERROR_WAS_STILL_DRAWING.",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5d21a16_6df1eb70",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-23T14:14:09Z",
      "side": 1,
      "message": "Yeah. I tried it locally. This CL break many tests with NVidia GPU. I debugged one really small test which verifies a buffer\u0027s content by using CopyBufferToBuffer to copy data from an uniform buffer to a staging buffer, and then use MapAsync() to map the staging buffer for readback. However the Map() call returns still drawing error.\n\nI tried workaround the problem by not using the `DXGI_ERROR_WAS_STILL_DRAWING` flag in `OnPreMapCallback()`, and run motionmark, and motionmark doesn\u0027t have any improvement. Looks like there is some issues with NVidia driver.",
      "parentUuid": "d3f8f6ca_cb7458ee",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3fe4e5ef_57257d44",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-23T14:48:34Z",
      "side": 1,
      "message": "What was the last usage of that buffer? Does it trigger a SetAccess() (or whatever the name is?) Can we fall back by doing a wait in this case, and eventually debug what tracking is missing?\n\nThis would allow making this method return a MaybeError instead of Unknown map statuses, which streamlines the error handling. By losing the device in FinishImpl() if there is an error (using if (device-\u003eConsumedError(...)) {status \u003d unknown})",
      "parentUuid": "d3f8f6ca_cb7458ee",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdf076c8_5d5fb1a3",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-23T15:14:30Z",
      "side": 1,
      "message": "The last usage of the staging buffer is for a B2B copy as the dst buffer. It sets the last usage serial correctly at [1]. \n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/CommandBufferD3D11.cpp;l\u003d315?q\u003dCommandBufferD3D11.cpp\u0026ss\u003dchromium",
      "parentUuid": "3fe4e5ef_57257d44",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "324c5ed5_e3beb472",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-23T15:51:50Z",
      "side": 1,
      "message": "BTW, the test I debugged is [1]. It creates a buffer with data, and checks the buffer content with `EXPECT_BUFFER_U32_RANGE_EQ(myData.data(), buffer, 0, kDataSize)`, and the `EXPECT_BUFFER_U32_RANGE_EQ()` uses MapAsync() and trigger the still draw problem.\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/angle/third_party/dawn/src/dawn/tests/end2end/BufferTests.cpp;l\u003d959?q\u003dMapWriteUsageLarg\u0026ss\u003dchromium",
      "parentUuid": "cdf076c8_5d5fb1a3",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79c92816_400a2f88",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-24T06:50:56Z",
      "side": 1,
      "message": "Thanks, Peng!\nSo it seems that the passed fence serial can\u0027t ensure the buffer is ready to be mapped without wait on Nvidia. We\u0027d better figure out this issue first before moving forward with this CL.",
      "parentUuid": "324c5ed5_e3beb472",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b25c5e29_2a9cb1e7",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-25T05:53:12Z",
      "side": 1,
      "message": "some ideas. what if only on NVIDIA GPUs we try some or all of:\n - do ID3D11DeviceContext::Flush before or after the ID3D11DeviceContext4::Signal\n - ID3D11DeviceContext4::Wait before Map - with the fence and value that we expect it to be completed (the idea is to force the driver flush any bits saying that the fence value has passed).",
      "parentUuid": "79c92816_400a2f88",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "945af829_9c3912f1",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1003451
      },
      "writtenOn": "2024-01-25T16:23:34Z",
      "side": 1,
      "message": "I have a workstation with NVidia GPU, I can try it. However this no wait staging buffer solution doesn\u0027t improve MotionMark scores at all. Seems it is not worth to continue pursuing it. I searched online, I cannot find articles about how to using d3d11 staging buffer efficiently. But I found [1] about how to update constant buffer efficiently. `Map(MAP_WRITE_DISCARD)` constant buffers and `UpdateSubresource()` with dx10 and dx11 (Nvidia driver uses `Map(MAP_WRITE_DISCARD)` internally); and `UpdateSubresource1(D3D11_COPY_NO_OVERWRITE)` with dx11.1 are recommended.\n\n[1] https://developer.nvidia.com/content/constant-buffers-without-constant-pain-0",
      "parentUuid": "b25c5e29_2a9cb1e7",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1367485_0ffa52d0",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-30T12:33:11Z",
      "side": 1,
      "message": "Good for reading! We always use `D3D11_MAP_READ_WRITE` instead of `D3D11_MAP_DISCARD`. That might be the problem.",
      "parentUuid": "945af829_9c3912f1",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "717df543_c6d06cd8",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 315,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-30T17:48:43Z",
      "side": 1,
      "message": "`D3D11_MAP_DISCARD` tells the driver that it can do versioning, essentially it does a new allocation of uniforms in its ringbuffer and repoints the uniform buffer to point to that. We should be able to do the same ourselves which was what the whole discussion on the other CL with Rafael was about. If we end up absolutely needing to use `D3D11_MAP_DISCARD` that\u0027s ok but let\u0027s try to figure out why our approach is slower.\n\nAlso IMHO given how much we have been spending discussing this, we should have dedicated performance tests in Dawn.",
      "parentUuid": "f1367485_0ffa52d0",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 315,
        "endChar": 40
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e989eae1_5e53b4e1",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 357,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-23T06:45:37Z",
      "side": 1,
      "message": "We could get rid of this wait by using compute shader CopyBufferToTexture.",
      "range": {
        "startLine": 357,
        "startChar": 90,
        "endLine": 357,
        "endChar": 95
      },
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5645a542_6d33602e",
        "filename": "src/dawn/native/d3d11/DeviceD3D11.cpp",
        "patchSetId": 4
      },
      "lineNbr": 532,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-23T14:48:34Z",
      "side": 1,
      "message": "Instead of reimplementing this kind of logic, can\u0027t we use the DynamicUploader?",
      "revId": "9e9cd71557506c783cb829a697cca3b845ead5c1",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}