{
  "comments": [
    {
      "key": {
        "uuid": "9b09c133_f10966c2",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 202,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-01-22T06:11:25Z",
      "side": 1,
      "message": "I think here, we should check that the Device is still alive.\n\nCan we test when you map a buffer, then lose the device immediately after, the callback returns with DeviceLost? Right now, we only test when you first lose the device, then map the buffer.",
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58a0fa4c_81455a2d",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 202,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9b09c133_f10966c2",
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "46ab9c38_92e88eb7",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 217,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-01-22T06:11:25Z",
      "side": 1,
      "message": "ditto",
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "add57354_d7df8910",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 217,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "46ab9c38_92e88eb7",
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "31d16958_3a6f5a7d",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 415,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T19:16:22Z",
      "side": 1,
      "message": "Since WGPUBufferMapAsyncStatus is already an error code, consider using it as the return value and have callers check whether the function returns WGPUBufferMapAsyncStatus_Error.",
      "range": {
        "startLine": 414,
        "startChar": 4,
        "endLine": 415,
        "endChar": 86
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f40b032_015dd60e",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 415,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "31d16958_3a6f5a7d",
      "range": {
        "startLine": 414,
        "startChar": 4,
        "endLine": 415,
        "endChar": 86
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eff9e419_fa632ca3",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 484,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-01-22T06:11:25Z",
      "side": 1,
      "message": "nit: could just do ValidateIsAlive() instead of buffer-\u003eGetDevice()-\u003e...",
      "range": {
        "startLine": 484,
        "startChar": 25,
        "endLine": 484,
        "endChar": 63
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31c08d9c_22b84597",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 484,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T19:16:22Z",
      "side": 1,
      "message": "Since you already set status to WGPUBufferMapAsyncStatus_Error, you\u0027re wasting CPU cycles checking for additional errors and stomping on the status variable. \n\n@Kai, do we need to send a separate callback for each error encountered or is sending only one callback for the first error good enough?",
      "range": {
        "startLine": 481,
        "startChar": 0,
        "endLine": 484,
        "endChar": 0
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "29990e87_0066fd06",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 484,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "eff9e419_fa632ca3",
      "range": {
        "startLine": 484,
        "startChar": 25,
        "endLine": 484,
        "endChar": 63
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bffc59e9_db03363e",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 484,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2020-01-22T21:34:32Z",
      "side": 1,
      "message": "The callback should be called exactly once per Map call.\n\nOne way to think of it: You should be able to malloc() before a Map call and free() inside of it, with no fear of leaks.",
      "parentUuid": "31c08d9c_22b84597",
      "range": {
        "startLine": 481,
        "startChar": 0,
        "endLine": 484,
        "endChar": 0
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f2cf6a83_4b9137f3",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 484,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2020-01-22T21:35:40Z",
      "side": 1,
      "message": "inside *its callback*, with no fear of leaks *or double-frees*",
      "parentUuid": "bffc59e9_db03363e",
      "range": {
        "startLine": 481,
        "startChar": 0,
        "endLine": 484,
        "endChar": 0
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ced30c93_c40f468f",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T19:16:22Z",
      "side": 1,
      "message": "I think VERIFY_EQ is a better macro to use here, especially if we\u0027re going to verify more than one parameter of the callback.",
      "range": {
        "startLine": 60,
        "startChar": 8,
        "endLine": 60,
        "endChar": 17
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89ba5e63_8ee59bb1",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T19:16:22Z",
      "side": 1,
      "message": "Good that we\u0027re verifying the status is what we expect.  \n\nWe should verify the other parameters are also what we expect.",
      "range": {
        "startLine": 60,
        "startChar": 1,
        "endLine": 60,
        "endChar": 63
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3c21820_d41d7526",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "That may require more callbacks since different tests will expect different data (some are null, and some have data). But I can assert userdata is nullptr.",
      "parentUuid": "89ba5e63_8ee59bb1",
      "range": {
        "startLine": 60,
        "startChar": 1,
        "endLine": 60,
        "endChar": 63
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0535b4d_4a9e16a3",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "I dont see dawn use verify_eq? is it called something else maybe?",
      "parentUuid": "ced30c93_c40f468f",
      "range": {
        "startLine": 60,
        "startChar": 8,
        "endLine": 60,
        "endChar": 17
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "787a1b36_98e591d4",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T21:17:56Z",
      "side": 1,
      "message": "Apologies, I meant EXPECT_EQ.\n\nThe difference between EXPECT_X and ASSERT_X is that ASSERT_X will completely halt the test if the condition is false.  Use ASSERT_X for instances where the test cannot continue if the condition is false: resource allocation, test environment setup, etc. \n\nWith EXPECT_X, on the other hand, the test continues to run but registers a failure at the end. EXPECT_X is good for verifying state that doesn\u0027t impact the runability of the test. \n\nShould your test get into a flaky state where errors only happen in the lab, having EXPECT_X is ideal because it you\u0027ll receive much more information in the logs about what is wrong. With ASSERT_X, you\u0027ll only get told about the first failure and that\u0027s it.",
      "parentUuid": "c0535b4d_4a9e16a3",
      "range": {
        "startLine": 60,
        "startChar": 8,
        "endLine": 60,
        "endChar": 17
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13babe7b_66444359",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T21:50:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "787a1b36_98e591d4",
      "range": {
        "startLine": 60,
        "startChar": 8,
        "endLine": 60,
        "endChar": 17
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "500ee635_b291acca",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2020-01-22T22:24:08Z",
      "side": 1,
      "message": "These always expect DeviceLost. If there\u0027s an error mapping, data should be nullptr and size should be 0.",
      "parentUuid": "c3c21820_d41d7526",
      "range": {
        "startLine": 60,
        "startChar": 1,
        "endLine": 60,
        "endChar": 63
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c30a3d2_29e71dca",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T22:52:48Z",
      "side": 1,
      "message": "but not if device loss happens after the mapping already.",
      "parentUuid": "500ee635_b291acca",
      "range": {
        "startLine": 60,
        "startChar": 1,
        "endLine": 60,
        "endChar": 63
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "54439dc9_260224a7",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2020-01-22T23:43:51Z",
      "side": 1,
      "message": "I think there should be an invariant that if the status is Success, then you get non-null and need to unmap, and if it\u0027s not, then you get null and don\u0027t need to unmap. We should bucket the different possible failure modes into as few possible buckets, so there are fewer situations for the API user to handle.",
      "parentUuid": "8c30a3d2_29e71dca",
      "range": {
        "startLine": 60,
        "startChar": 1,
        "endLine": 60,
        "endChar": 63
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ccf29f7_99aca8b1",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-24T00:14:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "54439dc9_260224a7",
      "range": {
        "startLine": 60,
        "startChar": 1,
        "endLine": 60,
        "endChar": 63
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "859f7649_7b1418b7",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 69,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T19:16:22Z",
      "side": 1,
      "message": "Since the map read and write callbacks have the same function signature, we should be able to get away with having one callback.",
      "range": {
        "startLine": 63,
        "startChar": 0,
        "endLine": 69,
        "endChar": 0
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7eedd8da_8c476c7e",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 69,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "theyre not exactly the same, read has const data while write does not.",
      "parentUuid": "859f7649_7b1418b7",
      "range": {
        "startLine": 63,
        "startChar": 0,
        "endLine": 69,
        "endChar": 0
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ffcf514_19fb77f3",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 69,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T21:17:56Z",
      "side": 1,
      "message": "Good point. I missed that.",
      "parentUuid": "7eedd8da_8c476c7e",
      "range": {
        "startLine": 63,
        "startChar": 0,
        "endLine": 69,
        "endChar": 0
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "15825a5f_efdf9113",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 69,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2020-01-22T22:24:08Z",
      "side": 1,
      "message": "I think\n\n template\u003ctypename DataT\u003e\n static void MapFailCallback(..., T* data, ...) {\n   static_assert(std::is_same\u003cconst T, const void\u003e(), \"...\");\n }\n\nshould work in both slots. (It should be able to infer `T \u003d void` or `T \u003d const void`.)\n\nhttps://godbolt.org/z/XJCLFF",
      "parentUuid": "9ffcf514_19fb77f3",
      "range": {
        "startLine": 63,
        "startChar": 0,
        "endLine": 69,
        "endChar": 0
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62f81d6a_05137c4e",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 287,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T19:16:22Z",
      "side": 1,
      "message": "Since userdata is typed to be void*, you should be able to use the weaker static_cast\u003c\u003e instead of reinterpret_cast\u003c\u003e.",
      "range": {
        "startLine": 287,
        "startChar": 31,
        "endLine": 287,
        "endChar": 60
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71c0931e_11cce575",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 287,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "62f81d6a_05137c4e",
      "range": {
        "startLine": 287,
        "startChar": 31,
        "endLine": 287,
        "endChar": 60
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "de9f1ed6_4cfd203b",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 311,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T19:16:22Z",
      "side": 1,
      "message": "If you\u0027re just going to have an array with one element, prefer std::array to avoid the memory allocation.",
      "range": {
        "startLine": 311,
        "startChar": 4,
        "endLine": 311,
        "endChar": 38
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48ecc5bc_27bafefd",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 311,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T19:16:22Z",
      "side": 1,
      "message": "The rest of the code assumes the array is of floats but here you are declaring it to be of uint32_t. I know that sizeof(float) \u003d\u003d sizeof(uint32_t) and the contents don\u0027t matter for the purposes of the test but we should keep things consistent so it doesn\u0027t look like there is a bug.",
      "range": {
        "startLine": 311,
        "startChar": 16,
        "endLine": 311,
        "endChar": 24
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15d2ac14_01d46f34",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 311,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "oops, thanks for the catch.",
      "parentUuid": "48ecc5bc_27bafefd",
      "range": {
        "startLine": 311,
        "startChar": 16,
        "endLine": 311,
        "endChar": 24
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3126b7b_c7b3b01c",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 311,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-22T20:26:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "de9f1ed6_4cfd203b",
      "range": {
        "startLine": 311,
        "startChar": 4,
        "endLine": 311,
        "endChar": 38
      },
      "revId": "5daf1a3a34c1d7174cc2b25e46054e3cf879cd14",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    }
  ]
}