{
  "comments": [
    {
      "key": {
        "uuid": "624cd6f6_e1b6b3f9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-08-31T10:50:30Z",
      "side": 1,
      "message": "Do we have WebGPU spec text for this? As discussed in our last meeting, we might choose to resolve unused queries t o0 instead of just disallowing it.",
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8093108_0e453f2e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2020-09-02T08:46:19Z",
      "side": 1,
      "message": "OK, I\u0027ve submitted the spec changes: https://github.com/gpuweb/gpuweb/pull/1042.\nIf we want to resolve unused queries to 0, we need find all unused query indexes, calculate the range of used queries, then call resolve method for many times if users skip many indexes when writing values. \n\nAnother reason is that a query set can only store one type of query values, we cannot reserve space to write other data. And timestamps are also the values that need to be compared in order, so I think it\u0027s meaningless to write to the queries discontinuously, it wastes the resources.",
      "parentUuid": "624cd6f6_e1b6b3f9",
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2c31542f_c6df823d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2020-09-07T08:39:46Z",
      "side": 1,
      "message": "At the beginning, I wanted to make the implementaion simpler on Vulkan, so I planed to disallow resolve unused queries. If we don\u0027t need this validation, it\u0027s a bit complicated and more effort will be needed.\n\nFirst, we need record the used indexes (std::map(QuerySet*, std::vector\u003cbool\u003e)) when encoding the commands, and calculate the interval of the used queries in vulkan backend, then call call resolve command for each interval. \nExample: \n```\nencoder.WriteTimestamp(querySet, 0); // Set mUsedQuerIndex[0] \u003d 1\nencoder.WriteTimestamp(querySet, 2); // Set mUsedQuerIndex[2] \u003d 1\nencoder.ResolveQuerySet(querySet, 0, 3, destination, 0);\n\n// The mUsedQuerIndex (1-used, 0-unused): {1, 0, 1}\n// Vulkan implementation for resolving:\nvkCmdCopyQueryPoolResults(cmd, querySet, 0 /*firstIndex*/, 1 /*queryCount*/, dstBuffer, ....);\nvkCmdCopyQueryPoolResults(cmd, querySet, 2 /*firstIndex*/, 1 /*queryCount*/, dstBuffer, ....);\n// Wirte the index 1 of destination buffer with 0.\n```\n\nSecondï¼ŒVulkan requires each queries must be reset via vkCmdResetQueryPool between uses, and this command must be called outside render/compute pass. Currently I reset the queries based on the recorded indexes when the command buffer is created.\n\nBut if we write timestamps to a same query index in both command encoder and render encoder, we also need to reset it again before beginning render pass, so we need other two vectors to record the used index in render pass and compute pass.\n\nExample:\n```\n// Need reset queryset[0, 2] when creating command buffer following mUsedQuerIndexAtTop\nencoder.WriteTimestamp(querySet, 0); // Set mUsedQuerIndexAtTop[0] \u003d 1\nencoder.WriteTimestamp(querySet, 2); // Set mUsedQuerIndexAtTop[2] \u003d 1\n\n// Need reset queryset[2] when beginning compute pass following mUsedQuerIndexComputePass\nwgpu::ComputePassEncoder pass \u003d encoder.BeginComputePass();\npass.WriteTimestamp(querySet, 1); // Set mUsedQuerIndexComputePass[1] \u003d 1\npass.WriteTimestamp(querySet, 2); // Set mUsedQuerIndexComputePass[2] \u003d 1\npass.EndPass();\n\n// Need to combine the records of mUsedQuerIndexAtTop and mUsedQuerIndexComputePass\nencoder.ResolveQuerySet(querySet, 0, 3, destination, 0);\n```\n\nOn D3D12 and Metal, they have no such limits, on Vulkan, it need more effort to record and parse these data for these two cases, maybe there are more use cases I haven\u0027t thought of. \n\nImplementaion steps on Vulkan:\n1. Create three index recorders for command encoder, render encoder, compute encoder in PassResourceUsageTracker\n2. Record the index when encoding commands\n3. In Vulkan backend, parse the data of the index recoders to get the intervals of used indexes in CommandBufferVk.\n4. When creating command buffer and begin render/compute pass, we need to reset the queries in the intervals.\n5. When resolving the queries, call resolve commands for each interval, first query is the first query index in each interval, query count is the number of the queries in each interval. For the left memory in destination buffer which not written values, write with 0.\n\n@Corentin, I\u0027m not sure if we want to do these.",
      "parentUuid": "f8093108_0e453f2e",
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f82d8ce_9b816222",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-09-08T14:17:09Z",
      "side": 1,
      "message": "The two vectors you mentioned for vkCmdResetQueryPool are required in all cases, it\u0027s a bit annoying but we do this kind of tracking for other things already. Implementation of it can come as a follow-up step if it is too much at once.\n\nFor the sparse resolve, the group hasn\u0027t decided 100% on it yet, so we could implement the simple solution now (no validation, no defaulting to 0, just invalid Vulkan code), then revisit when the group has decided on the path forward.\n\nHopefully breaking things down this way makes the task more manageable?",
      "parentUuid": "2c31542f_c6df823d",
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "722f2fd2_3fccb120",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2020-09-09T06:18:34Z",
      "side": 1,
      "message": "Yes, it will be simpler. I will do the reset queries firstly, it seems that the index record and analysis are essential part if we allow to write same query index twice in same command encoder.",
      "parentUuid": "8f82d8ce_9b816222",
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8c14d8e6_b72c8ac8",
        "filename": "src/dawn_native/CommandEncoder.cpp",
        "patchSetId": 4
      },
      "lineNbr": 473,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2020-08-31T05:17:57Z",
      "side": 1,
      "message": "To make the validation tests simple, I move this validation to the back of other checkpoints, otherwise all tests will be need to write values to every queries, even if the tests have nothing to do with the checkout of query index , especially for the test at [1] in https://dawn-review.googlesource.com/c/dawn/+/27561/4/src/tests/unittests/validation/QuerySetValidationTests.cpp, we need write a large amount of queries which will make the test hang a long time in recording the commands.",
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e48fbf3e_d143f84f",
        "filename": "src/dawn_native/CommandEncoder.cpp",
        "patchSetId": 4
      },
      "lineNbr": 481,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-08-31T16:55:41Z",
      "side": 1,
      "message": "queryIndexes should be a const reference,\nand then this could probably be\n\nstd::all_of(queryIndexes.begin() + first, queryIndexes.begin() + first + count, ...);\n\nthat way we don\u0027t need to make any new allocations.",
      "range": {
        "startLine": 474,
        "startChar": 12,
        "endLine": 481,
        "endChar": 13
      },
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f418f876_474d9cd6",
        "filename": "src/dawn_native/CommandEncoder.cpp",
        "patchSetId": 4
      },
      "lineNbr": 481,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2020-09-02T08:46:19Z",
      "side": 1,
      "message": "Thanks, this\u0027s a better way.",
      "parentUuid": "e48fbf3e_d143f84f",
      "range": {
        "startLine": 474,
        "startChar": 12,
        "endLine": 481,
        "endChar": 13
      },
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dca9489a_1fe2f822",
        "filename": "src/dawn_native/QuerySet.cpp",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-08-31T16:55:41Z",
      "side": 1,
      "message": "mm, I don\u0027t think these methods should be on the QuerySet. There can be multiple command encoders recorded simultaneously, and then submitted later, so they should not use tracking state on the query set. Each encoder needs to have its own local state for tracking which query set indices are used.",
      "range": {
        "startLine": 137,
        "startChar": 4,
        "endLine": 147,
        "endChar": 5
      },
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4de83d75_597bf7a2",
        "filename": "src/dawn_native/QuerySet.cpp",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2020-09-02T08:46:19Z",
      "side": 1,
      "message": "Yes, it\u0027s a problem, I will fix it.",
      "parentUuid": "dca9489a_1fe2f822",
      "range": {
        "startLine": 137,
        "startChar": 4,
        "endLine": 147,
        "endChar": 5
      },
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f50962bb_f6d2caa5",
        "filename": "src/tests/unittests/validation/QuerySetValidationTests.cpp",
        "patchSetId": 4
      },
      "lineNbr": 486,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2020-08-31T05:17:57Z",
      "side": 1,
      "message": "[1]",
      "revId": "8b99d6faaf8c302a95f6adbdea9a2eb03795e286",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}