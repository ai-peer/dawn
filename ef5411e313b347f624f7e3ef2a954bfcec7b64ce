{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e67c9431_00f3a8d5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-25T08:54:20Z",
      "side": 1,
      "message": "PTAL, thanks!",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21f18b0a_11970022",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-10-25T12:20:12Z",
      "side": 1,
      "message": "I have concerns about making GetMappedRange virtual just so we can fake the mapped ranges on OOM for mappedAtCreation. Kai what\u0027s the behavior in the spec if the mappedAtCreation backing OOMs? Shouldn\u0027t we allow the page to get a nullptr / OperationError etc?",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2fadd52b_848bdd1f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-26T00:25:41Z",
      "side": 1,
      "message": "Hi Kai, could you take a look at this CL?",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "437d19ba_04e5c3b9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-26T00:51:15Z",
      "side": 1,
      "message": "I am also not sure if I understand the SPEC correctly.\n\nIn SPEC (https://gpuweb.github.io/gpuweb/#dom-gpubuffer-getmappedrange), \"it is always valid to get mapped ranges of a GPUBuffer that is mappedAtCreation, even if it is invalid,\", so calling getMappedRange() on an error GPUBuffer with mappedAtCreation \u003d\u003d true should be valid as long as we can successfully create the ArrayBuffer with required size (mentioned in Step 4).\n\nThe behaviors of getMappedRange() on ErrorBuffer are different as ErrorBuffer has neither size nor mapped size, so we will meet 4 situations when calling getMappedRange() on an ErrorBuffer.\n\n1. size \u003d\u003d 0\n   Dawn should return a fake pointer (like 0xCAFED00D in current Dawn), and in \nBlink the allocation of ArrayBuffer should fail.\n   \n2. size \u003d\u003d WGPU_WHOLE_MAP_SIZE\n   Dawn should return a fake pointer or nullptr as ErrorBuffer has no size?\n\n3. size is a very large number that will cause OOM\n   Dawn should return a nullptr as Dawn is not able to allocate so much memory.\n\n4. size is a relatively small number that won\u0027t cause OOM\n   Dawn should allocate a piece of CPU memory and return the pointer that points to that piece of memory.",
      "parentUuid": "21f18b0a_11970022",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2864bb11_838a4869",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-10-26T11:39:52Z",
      "side": 1,
      "message": "First the behavior of dawn::native doesn\u0027t matter much for fixing the WebGPU behavior because all of the processing for that step happens synchronously in Blink, so there\u0027s only Blink code and dawn::wire::client code. The dawn::wire::client can\u0027t know if the buffer creation errored so it should try to keep things working as if the buffer was valid. However I don\u0027t think it is reasonable for the spec to ask that getBufferMappedRange(4) on a giant buffer should work, as we strongly want to allocate all the memory during the buffer creation (or the mapAsync call). So in 4) it should be valid to return nullptr (the spec doesn\u0027t exactly allow it, but IMHO should be changed).",
      "parentUuid": "437d19ba_04e5c3b9",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6b41267_7e49bbbc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-27T00:16:31Z",
      "side": 1,
      "message": "\u003e  However I don\u0027t think it is reasonable for the spec to ask that getBufferMappedRange(4) on a giant buffer should work, as we strongly want to allocate all the memory during the buffer creation (or the mapAsync call). So in 4) it should be valid to return nullptr (the spec doesn\u0027t exactly allow it, but IMHO should be changed).\n\nThe SPEC says \"it is always valid to get mapped ranges of a GPUBuffer that is mappedAtCreation, even if it is invalid\", which implies calling a small range of getMappedRange() on an OOM buffer is allowed. \n\nThere is a WebGPU CTS test that shows \"calling it on a small range of the buffer successfully returns an ArrayBuffer\" (https://github.com/gpuweb/cts/blob/main/src/webgpu/api/operation/buffers/map_oom.spec.ts#L116), which fails on Chromium right now.\n\nIf we agree on your suggestion here, we should first fix that test and the statements in SPEC.",
      "parentUuid": "2864bb11_838a4869",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "258fb2bf_dbef80bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-27T00:32:52Z",
      "side": 1,
      "message": "\u003e However I don\u0027t think it is reasonable for the spec to ask that getBufferMappedRange(4) on a giant buffer should work\n\nAnother question is the ErrorBuffer doesn\u0027t have \u0027size\u0027 (in GetSize() we have ASSERT(!IsError(), https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/Buffer.cpp;l\u003d203), so it seems error buffers are neither \u0027giant\u0027 or \u0027small\u0027.",
      "parentUuid": "e6b41267_7e49bbbc",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e27f120e_bfaedbd2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-10-28T13:14:01Z",
      "side": 1,
      "message": "We could remove that assert TBH.\n\nPut also please see with Kai, or even the wider group about what to do in this OOM case. Having to fake getMappedRange working would be very onerous as you\u0027ve found.",
      "parentUuid": "258fb2bf_dbef80bb",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78daab38_c85a7405",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-10-28T16:52:42Z",
      "side": 1,
      "message": "The spec changed a while back and I think the tests are outdated. Please see:\nhttps://github.com/gpuweb/gpuweb/pull/3351\n\nThe reason for \"it is always valid to get mapped ranges of a GPUBuffer that is mappedAtCreation, even if it is invalid\" is we can\u0027t have server-side validation block the client-side `getMappedRange` operation. It\u0027s not intended (anymore) that implementations have to hide OOM in `mappedAtCreation`. `createBuffer` will throw an exception if the mapping for `mappedAtCreation` fails, so there\u0027s no `GPUBuffer` object to call `getMappedRange` *on*:\nhttps://gpuweb.github.io/gpuweb/#abstract-opdef-initialize-an-active-buffer-mapping\n\nIn the C API, it\u0027s not possible to throw an exception, so it probably makes sense to return an error buffer and generate a Dawn validation error.",
      "parentUuid": "e27f120e_bfaedbd2",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70bbe2ec_be7c6282",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-31T01:44:03Z",
      "side": 1,
      "message": "Hi Kai, thanks for your explanation.\n\nSo when creating a buffer with mappedAtCreation \u003d\u003d true, invalid usage and a very large size that will OOM on the client side:\n1. With dawn_wire we should throw a RangeError and generate an error buffer at client side.\n2. Without dawn_wire we should generate a validation error and return an error buffer.\n\nAnd the tests in Dawn should also follow below rules (have different expectations with and without dawn_wire).",
      "parentUuid": "78daab38_c85a7405",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6912d1e0_2eaf9387",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-31T01:56:20Z",
      "side": 1,
      "message": "Hi Corentin,\n\nThe problem is that now the OOM happens at the server side instead of the client side, so we cannot allocate mFakeMappedData for the error buffer when creating it.\n\nNow there is a call of getMappedRange() on that error buffer with a small range, and the client passes the validation, but on the server side mFakeMappedData is pointing to a nullptr.\n\nIn this case I think we have to allocate mFakeMappedData at the call of getMappedRange(). What do you think?",
      "parentUuid": "70bbe2ec_be7c6282",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f44ea9b_b150d035",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-01T02:07:06Z",
      "side": 1,
      "message": "Catching up on this thread. From what I gather:\n 1. we don\u0027t want to unnecessarily add virtual method calls to support error cases\n 2. OOM is not intended to be hidden in mappedAtCreation\n 3. but there\u0027s still a problem that the service could OOM without the client knowing - so mappedAtCreation OOMs and getMappedRange succeeds\n 4. ideally, it we want native/wire to have as close as possible behavior\n\nThis CL intends to make (4) match the behavior in the spec.\n\n(4) *should* already be the case right now though? [here](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/Buffer.cpp;l\u003d64;bpv\u003d1;bpt\u003d1?q\u003df:dawn%20Errorbuffer) error buffers allocate fake mapped data, specifically for mappedAtCreation buffers.\nTesting locally, I can\u0027t pass the tests despite that existing code.\nLooks like it\u0027s because the allocation size is SO large that AllocNoThrow\u003c\u003e(size) returns nullptr.\n\nI feel like for the WebGPU C API, we can differ slightly from the JS API and say that this might return nullptr. We shouldn\u0027t regularly actually get such large allocations.",
      "parentUuid": "6912d1e0_2eaf9387",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e911c51c_6148ac20",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-01T22:36:09Z",
      "side": 1,
      "message": "Shouldn\u0027t mFakeMappedData only be used if not using dawn_wire? With dawn_wire, the fake mapped data needs to be immediately available on the client side. Seems to me the service shouldn\u0027t need fake mapped data at all.\n\nTangentially:\n\n\u003e In the C API, it\u0027s not possible to throw an exception, so it probably makes sense to return an error buffer and generate a Dawn validation error.\n\nOn second thought, this thing I said might not make sense. The options I see are:\n\n- It returns nullptr as a C alternative to `RangeError`, and maybe injects an error so we can provide an error message.\n- It returns an invalid buffer that is NOT mapped and cannot have GetMappedRange called on it.\n\nSince we want to be able to implement the C API on top of the JS API, the nullptr probably makes more sense.",
      "parentUuid": "7f44ea9b_b150d035",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c0a485f_c40f84ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-11-03T11:57:45Z",
      "side": 1,
      "message": "What I don\u0027t understand is that the spec specifically seems to mention that the OOM should be done when creating the buffer, such that future getMappedRange return null no? [here](https://gpuweb.github.io/gpuweb/#dom-gpubuffer-getmappedrange:~:text\u003dNote%3A%20A%20RangeError%20may%20not%20be%20thrown%20here%2C%20because%20the%20data%20has%20already%20been%20allocated%20during%20mapAsync()%20or%20createBuffer().)\n\n\u003e Note: A RangeError may not be thrown here, because the data has already been allocated during mapAsync() or createBuffer().\n\nSo shouldn\u0027t we return nullptr from dawn_wire in case of a getMappedRange on an OOM buffer then catch it in Blink and throw an OperationError?",
      "parentUuid": "e911c51c_6148ac20",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "367f95da_0f61c57c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-04T01:21:44Z",
      "side": 1,
      "message": "In the JS spec, if there\u0027s a mapping OOM in createBuffer, then createBuffer throws a RangeError, so you don\u0027t get a GPUBuffer object in the first place that you can call getMappedRange on.\n\nI think the C API should return nullptr from createBuffer in this case. I was originally thinking it should return an error WGPUBuffer (that\u0027s not mapped, and therefore fails in GetMappedRange), but decided this makes less sense.",
      "parentUuid": "2c0a485f_c40f84ab",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ed78675_71b9ca30",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-11-04T09:30:08Z",
      "side": 1,
      "message": "\u003e In the JS spec, if there\u0027s a mapping OOM in createBuffer, then createBuffer throws a RangeError, so you don\u0027t get a GPUBuffer object in the first place that you can call getMappedRange on.\n\nThat works for the content timeline, but what about the device timeline? If there\u0027s an OOM in the device timeline, the content timeline won\u0027t know early enough to raise an exception synchronously.\n\n\u003e In the JS spec, if there\u0027s a mapping OOM in createBuffer, then createBuffer throws a RangeError, so you don\u0027t get a GPUBuffer object in the first place that you can call getMappedRange on.\n\nThe C API returning a nullptr buffer is a bit problematic because the wire client side doesn\u0027t know that the buffer ended up being a nullptr on the server side.\n\nThat\u0027s why returning an error buffer that gives nullptr on getMappedRange makes more sense to me: you can still use the buffer in all regular operations (e.g. SetVertexBuffer) without having to check for null.",
      "parentUuid": "367f95da_0f61c57c",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ceacc5d8_d1b77ece",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-05T01:55:00Z",
      "side": 1,
      "message": "If there\u0027s a device timeline OOM on a buffer that\u0027s mappedAtCreation then getMappedRange is supposed to still work. The data won\u0027t go anywhere, but createBuffer is supposed to have already allocated memory that can be returned by getMappedRange, and freed on unmap/destroy.\n\n\u003e The C API returning a nullptr buffer is a bit problematic because the wire client side doesn\u0027t know that the buffer ended up being a nullptr on the server side.\n\nMaybe I\u0027m thinking about this too abstractly because I\u0027m not that familiar with the implementation, but here\u0027s what I\u0027m thinking. This scenario can only happen if the server side attempts to make a CPU allocation in createBuffer and fails. But the CPU allocation is for the caller to use, so why would the server need one? If it\u0027s IPC or in-process, the client can allocate it and send the handle to the server.\n\nThe other reason I think it should return nullptr is so when there is a RangeError from createBuffer, Emscripten doesn\u0027t have to conjure up a fake GPUBuffer object handle and somehow pretend it can be used up until it\u0027s used on a queue. This isn\u0027t a huge deal though because we could always have different OOM behavior on Emscripten if we need to.",
      "parentUuid": "8ed78675_71b9ca30",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "415e61ff_b0d1c361",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-11-21T12:19:12Z",
      "side": 1,
      "message": "I believe this needs a rework after the change to make OOM failures return an error in the wire right?",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}