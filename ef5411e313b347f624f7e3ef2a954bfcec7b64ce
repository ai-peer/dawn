{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e67c9431_00f3a8d5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-25T08:54:20Z",
      "side": 1,
      "message": "PTAL, thanks!",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "21f18b0a_11970022",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-10-25T12:20:12Z",
      "side": 1,
      "message": "I have concerns about making GetMappedRange virtual just so we can fake the mapped ranges on OOM for mappedAtCreation. Kai what\u0027s the behavior in the spec if the mappedAtCreation backing OOMs? Shouldn\u0027t we allow the page to get a nullptr / OperationError etc?",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2fadd52b_848bdd1f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-26T00:25:41Z",
      "side": 1,
      "message": "Hi Kai, could you take a look at this CL?",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "437d19ba_04e5c3b9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-26T00:51:15Z",
      "side": 1,
      "message": "I am also not sure if I understand the SPEC correctly.\n\nIn SPEC (https://gpuweb.github.io/gpuweb/#dom-gpubuffer-getmappedrange), \"it is always valid to get mapped ranges of a GPUBuffer that is mappedAtCreation, even if it is invalid,\", so calling getMappedRange() on an error GPUBuffer with mappedAtCreation \u003d\u003d true should be valid as long as we can successfully create the ArrayBuffer with required size (mentioned in Step 4).\n\nThe behaviors of getMappedRange() on ErrorBuffer are different as ErrorBuffer has neither size nor mapped size, so we will meet 4 situations when calling getMappedRange() on an ErrorBuffer.\n\n1. size \u003d\u003d 0\n   Dawn should return a fake pointer (like 0xCAFED00D in current Dawn), and in \nBlink the allocation of ArrayBuffer should fail.\n   \n2. size \u003d\u003d WGPU_WHOLE_MAP_SIZE\n   Dawn should return a fake pointer or nullptr as ErrorBuffer has no size?\n\n3. size is a very large number that will cause OOM\n   Dawn should return a nullptr as Dawn is not able to allocate so much memory.\n\n4. size is a relatively small number that won\u0027t cause OOM\n   Dawn should allocate a piece of CPU memory and return the pointer that points to that piece of memory.",
      "parentUuid": "21f18b0a_11970022",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2864bb11_838a4869",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-10-26T11:39:52Z",
      "side": 1,
      "message": "First the behavior of dawn::native doesn\u0027t matter much for fixing the WebGPU behavior because all of the processing for that step happens synchronously in Blink, so there\u0027s only Blink code and dawn::wire::client code. The dawn::wire::client can\u0027t know if the buffer creation errored so it should try to keep things working as if the buffer was valid. However I don\u0027t think it is reasonable for the spec to ask that getBufferMappedRange(4) on a giant buffer should work, as we strongly want to allocate all the memory during the buffer creation (or the mapAsync call). So in 4) it should be valid to return nullptr (the spec doesn\u0027t exactly allow it, but IMHO should be changed).",
      "parentUuid": "437d19ba_04e5c3b9",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6b41267_7e49bbbc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-27T00:16:31Z",
      "side": 1,
      "message": "\u003e  However I don\u0027t think it is reasonable for the spec to ask that getBufferMappedRange(4) on a giant buffer should work, as we strongly want to allocate all the memory during the buffer creation (or the mapAsync call). So in 4) it should be valid to return nullptr (the spec doesn\u0027t exactly allow it, but IMHO should be changed).\n\nThe SPEC says \"it is always valid to get mapped ranges of a GPUBuffer that is mappedAtCreation, even if it is invalid\", which implies calling a small range of getMappedRange() on an OOM buffer is allowed. \n\nThere is a WebGPU CTS test that shows \"calling it on a small range of the buffer successfully returns an ArrayBuffer\" (https://github.com/gpuweb/cts/blob/main/src/webgpu/api/operation/buffers/map_oom.spec.ts#L116), which fails on Chromium right now.\n\nIf we agree on your suggestion here, we should first fix that test and the statements in SPEC.",
      "parentUuid": "2864bb11_838a4869",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "258fb2bf_dbef80bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-27T00:32:52Z",
      "side": 1,
      "message": "\u003e However I don\u0027t think it is reasonable for the spec to ask that getBufferMappedRange(4) on a giant buffer should work\n\nAnother question is the ErrorBuffer doesn\u0027t have \u0027size\u0027 (in GetSize() we have ASSERT(!IsError(), https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/Buffer.cpp;l\u003d203), so it seems error buffers are neither \u0027giant\u0027 or \u0027small\u0027.",
      "parentUuid": "e6b41267_7e49bbbc",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e27f120e_bfaedbd2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-10-28T13:14:01Z",
      "side": 1,
      "message": "We could remove that assert TBH.\n\nPut also please see with Kai, or even the wider group about what to do in this OOM case. Having to fake getMappedRange working would be very onerous as you\u0027ve found.",
      "parentUuid": "258fb2bf_dbef80bb",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78daab38_c85a7405",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-10-28T16:52:42Z",
      "side": 1,
      "message": "The spec changed a while back and I think the tests are outdated. Please see:\nhttps://github.com/gpuweb/gpuweb/pull/3351\n\nThe reason for \"it is always valid to get mapped ranges of a GPUBuffer that is mappedAtCreation, even if it is invalid\" is we can\u0027t have server-side validation block the client-side `getMappedRange` operation. It\u0027s not intended (anymore) that implementations have to hide OOM in `mappedAtCreation`. `createBuffer` will throw an exception if the mapping for `mappedAtCreation` fails, so there\u0027s no `GPUBuffer` object to call `getMappedRange` *on*:\nhttps://gpuweb.github.io/gpuweb/#abstract-opdef-initialize-an-active-buffer-mapping\n\nIn the C API, it\u0027s not possible to throw an exception, so it probably makes sense to return an error buffer and generate a Dawn validation error.",
      "parentUuid": "e27f120e_bfaedbd2",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70bbe2ec_be7c6282",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-31T01:44:03Z",
      "side": 1,
      "message": "Hi Kai, thanks for your explanation.\n\nSo when creating a buffer with mappedAtCreation \u003d\u003d true, invalid usage and a very large size that will OOM on the client side:\n1. With dawn_wire we should throw a RangeError and generate an error buffer at client side.\n2. Without dawn_wire we should generate a validation error and return an error buffer.\n\nAnd the tests in Dawn should also follow below rules (have different expectations with and without dawn_wire).",
      "parentUuid": "78daab38_c85a7405",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6912d1e0_2eaf9387",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-10-31T01:56:20Z",
      "side": 1,
      "message": "Hi Corentin,\n\nThe problem is that now the OOM happens at the server side instead of the client side, so we cannot allocate mFakeMappedData for the error buffer when creating it.\n\nNow there is a call of getMappedRange() on that error buffer with a small range, and the client passes the validation, but on the server side mFakeMappedData is pointing to a nullptr.\n\nIn this case I think we have to allocate mFakeMappedData at the call of getMappedRange(). What do you think?",
      "parentUuid": "70bbe2ec_be7c6282",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f44ea9b_b150d035",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-01T02:07:06Z",
      "side": 1,
      "message": "Catching up on this thread. From what I gather:\n 1. we don\u0027t want to unnecessarily add virtual method calls to support error cases\n 2. OOM is not intended to be hidden in mappedAtCreation\n 3. but there\u0027s still a problem that the service could OOM without the client knowing - so mappedAtCreation OOMs and getMappedRange succeeds\n 4. ideally, it we want native/wire to have as close as possible behavior\n\nThis CL intends to make (4) match the behavior in the spec.\n\n(4) *should* already be the case right now though? [here](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/Buffer.cpp;l\u003d64;bpv\u003d1;bpt\u003d1?q\u003df:dawn%20Errorbuffer) error buffers allocate fake mapped data, specifically for mappedAtCreation buffers.\nTesting locally, I can\u0027t pass the tests despite that existing code.\nLooks like it\u0027s because the allocation size is SO large that AllocNoThrow\u003c\u003e(size) returns nullptr.\n\nI feel like for the WebGPU C API, we can differ slightly from the JS API and say that this might return nullptr. We shouldn\u0027t regularly actually get such large allocations.",
      "parentUuid": "6912d1e0_2eaf9387",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e911c51c_6148ac20",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-01T22:36:09Z",
      "side": 1,
      "message": "Shouldn\u0027t mFakeMappedData only be used if not using dawn_wire? With dawn_wire, the fake mapped data needs to be immediately available on the client side. Seems to me the service shouldn\u0027t need fake mapped data at all.\n\nTangentially:\n\n\u003e In the C API, it\u0027s not possible to throw an exception, so it probably makes sense to return an error buffer and generate a Dawn validation error.\n\nOn second thought, this thing I said might not make sense. The options I see are:\n\n- It returns nullptr as a C alternative to `RangeError`, and maybe injects an error so we can provide an error message.\n- It returns an invalid buffer that is NOT mapped and cannot have GetMappedRange called on it.\n\nSince we want to be able to implement the C API on top of the JS API, the nullptr probably makes more sense.",
      "parentUuid": "7f44ea9b_b150d035",
      "revId": "ef5411e313b347f624f7e3ef2a954bfcec7b64ce",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}