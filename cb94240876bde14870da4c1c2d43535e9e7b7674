{
  "comments": [
    {
      "key": {
        "uuid": "48b32020_f7a8b757",
        "filename": "src/tests/end2end/GpuMemorySynchronizationTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2019-11-18T06:11:13Z",
      "side": 1,
      "message": "If we map/unmap buffer twice (with a CopyBufferToBuffer in between). It fails on almost all backend. Is this correct?",
      "range": {
        "startLine": 107,
        "startChar": 3,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "cb94240876bde14870da4c1c2d43535e9e7b7674",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a559cb0_6e1f4a11",
        "filename": "src/tests/end2end/GpuMemorySynchronizationTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-18T18:46:13Z",
      "side": 1,
      "message": "Do you mean:\n\nbuffer.Map(); *mappedData \u003d 2; buffer.Unmap();\nencoder.CopyBufferToBuffer(buffer, 0, readbackBuffer, 0, 4);\nbuffer.Map(); *mappedData \u003d 3; buffer.Unmap();\n\ncommands \u003d encoder.Finish();\nqueue.Submit(1, \u0026commands);\n\n\nWith no Queue.Submit() between? In ^that example, |readbackBuffer| will have 3 inside because the queue was submitted after.\n\n\nIf you want to upload mapped data twice, it needs to do something like:\n\nbuffer.Map(); *mappedData \u003d 2; buffer.Unmap();\nencoder.CopyBufferToBuffer(buffer, 0, readbackBuffer, 0, 4);\ncommands \u003d encoder.Finish();\nqueue.Submit(1, \u0026commands);\nMapReadAsyncAndWait(readbackBuffer);\n\nbuffer.Map(); *mappedData \u003d 3; buffer.Unmap();\nencoder.CopyBufferToBuffer(buffer, 0, readbackBuffer, 0, 4);\ncommands \u003d encoder.Finish();\nqueue.Submit(1, \u0026commands);\nMapReadAsyncAndWait(readbackBuffer);",
      "parentUuid": "48b32020_f7a8b757",
      "range": {
        "startLine": 107,
        "startChar": 3,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "cb94240876bde14870da4c1c2d43535e9e7b7674",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "debe7b50_369de091",
        "filename": "src/tests/end2end/GpuMemorySynchronizationTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2019-11-18T19:20:17Z",
      "side": 1,
      "message": "Austin, I am not saying map/unmap without queue submit. \n\nI added the code as I cited (you can compare the difference between patchset 1 and 2), and patchset 1 failed on many bots/backend (if not all). \n\nWhat I did is: \n1) clear the buffer with 0. \n2) verify the data has already been cleared to 0 via map/unmap (as the code snippet I commented). Well, this step is not needed for this test. I just want to verify intermediate values. \n3) iterate compute pass 3 times, in which the data will be changed to 3, and submit the queue\n4) map/unmap again, verify that the data is 3 as we expected\n\nThis is what I did in patch set 1. However, it succeeded at step 2) but failed at step 4) (it is 0). \n\nWhen I removed step 2), then verification at step 4) succeeded! That\u0027s patchset 2.   \n\nI think that map/unmap twice like patchset 1 is not wrong, step 4) at patchset 1 should succeed. However, almost all bots failed. So I asked the question above.",
      "parentUuid": "7a559cb0_6e1f4a11",
      "range": {
        "startLine": 107,
        "startChar": 3,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "cb94240876bde14870da4c1c2d43535e9e7b7674",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33a6b711_e6c17e1c",
        "filename": "src/tests/end2end/GpuMemorySynchronizationTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-11-18T22:15:12Z",
      "side": 1,
      "message": "Ah I see now. This definitely shouldn\u0027t be happening. Perhaps our mapping trackers are resolving callbacks at the wrong time?\n\nDo we need to do some barrier to read data on the CPU like vkFlushMappedMemoryRanges?\n\nI think it\u0027s likely that we need to add a Flush. This is a good find Yunchao",
      "parentUuid": "debe7b50_369de091",
      "range": {
        "startLine": 107,
        "startChar": 3,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "cb94240876bde14870da4c1c2d43535e9e7b7674",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc21d29a_cfb4cc1a",
        "filename": "src/tests/end2end/GpuMemorySynchronizationTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 110,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2019-11-19T01:27:25Z",
      "side": 1,
      "message": "Yes. Maybe we missed a flush. I added a test to expose the error at https://dawn-review.googlesource.com/c/dawn/+/13801. PTAL. \n\nThat bug is not relevant to this change. I\u0027d like to proceed the GPU memory sync among compute/render pass(es) at first.",
      "parentUuid": "33a6b711_e6c17e1c",
      "range": {
        "startLine": 107,
        "startChar": 3,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "cb94240876bde14870da4c1c2d43535e9e7b7674",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}