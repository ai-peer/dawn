{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1aa6ef05_20588eaf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 5
      },
      "lineNbr": 17,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-08-30T18:29:36Z",
      "side": 1,
      "message": "nit: 1092",
      "revId": "a50f8e3affe09ae59fb6a8ecbed3c78d0304282b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52581484_06b5be9b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-08-30T16:11:49Z",
      "side": 1,
      "message": "PTAL",
      "revId": "a50f8e3affe09ae59fb6a8ecbed3c78d0304282b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5bae2894_091bb36a",
        "filename": "src/dawn_wire/client/Buffer.h",
        "patchSetId": 5
      },
      "lineNbr": 89,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-08-30T16:46:56Z",
      "side": 1,
      "message": "Overall, I think we need a solution that is not local to each object. The RequestTracker here is only good for re-entrancy on the same object. i.e.\n\nbuffer.mapAsync().then(() \u003d\u003e {\n  buffer.mapAsync().then...\n});\n\nbut it doesn\u0027t work if you\u0027re re-entrant across multiple objects:\n\nbuffer.mapAsync().then(() \u003d\u003e {\n  queue.onSubmittedWorkDone().then(() \u003d\u003e {\n    buffer.mapAsync().then...\n  });\n});\n\nRequestTracker::CloseAll is insufficent to prevent leaking callbacks in this scenario",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 89,
        "endChar": 49
      },
      "revId": "a50f8e3affe09ae59fb6a8ecbed3c78d0304282b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}