{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "31957b41_e8b261a7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-11-01T02:22:32Z",
      "side": 1,
      "message": "I haven\u0027t found a way to reproduce this issue locally. But as it\u0027s a P1 issue, shall we just try to have the quick fix first?",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "25232f3f_d3d0acb3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-01T02:23:21Z",
      "side": 1,
      "message": "sorry for the slow reply - responding on the bug at this moment",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be8ee702_b6daee9a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-01T02:56:50Z",
      "side": 1,
      "message": "Ok I wrote up additional thoughts in the bug.\nI\u0027ll +1 this CL since I think it is at least part of the change we need to make, but it would be best to understand the failure mode and try to make some tests so we\u0027re certain.\n\nWe *could* revert the CL that introduced this problem, but I\u0027m hesitant since it\u0027s possible we end up reverting and relanding multiple times when there may be multiple fuzzer issues like this one. I\u0027d rather let it sit for some time to let the fuzzers continue to find problems instead of reverting - so long as we can make the fixes quickly enough.",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "292f4f5f_adcf0122",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-11-01T14:02:54Z",
      "side": 1,
      "message": "I\u0027ve managed to reproduce the issue. It turned out that this is not the right fix. First thing to clarify, this fuzzer test case only calls dawn_wire server APIs without any client API involved. It\u0027s not a normal MapAsync callback. It\u0027s called simply because of the Server destructor.\n\n```\nServer::~Server() {\n    // Un-set the error and lost callbacks since we cannot forward them\n    // after the server has been destroyed.\n    for (WGPUDevice device : DeviceObjects().GetAllHandles()) {\n        ClearDeviceCallbacks(device);\n    }\n    DestroyAllObjects(mProcs);\n}\n```\n\nPreviously the MapAsync callback was from `DestroyAllObjects(mProcs)`, so the buffer was destroyed before the callback. As a result, it returned at [1] before running into the null writeHandle. The stack:\n```\n   #4 0x56401c89f0a2 in dawn::wire::server::Server::OnBufferMapAsyncCallback(dawn::wire::server::MapUserdata*, WGPUBufferMapAsyncStatus) third_party/dawn/src/dawn/wire/server/ServerBuffer.cpp:242:13\n    #5 0x56401c8a0254 in dawn::wire::server::ForwardToServerHelper\u003c\u0026dawn::wire::server::Server::OnBufferMapAsyncCallback(dawn::wire::server::MapUserdata*, WGPUBufferMapAsyncStatus)\u003e::ExtractedTypes\u003cvoid (dawn::wire::server::Server::*)(dawn::wire::server::MapUserdata*, WGPUBufferMapAsyncStatus)\u003e::Callback(WGPUBufferMapAsyncStatus, void*) third_party/dawn/src/dawn/wire/server/Server.h:78:13\n    #6 0x56401b622a3b in dawn::native::BufferBase::UnmapInternal(WGPUBufferMapAsyncStatus) third_party/dawn/src/dawn/native/Buffer.cpp:434:9\n    #7 0x56401b6227cd in dawn::native::BufferBase::DestroyImpl() third_party/dawn/src/dawn/native/Buffer.cpp\n    #8 0x56401b82a22c in dawn::native::null::Buffer::DestroyImpl() third_party/dawn/src/dawn/native/null/DeviceNull.cpp:349:17\n    #9 0x56401b746003 in dawn::native::ApiObjectList::Destroy() third_party/dawn/src/dawn/native/ObjectBase.cpp:61:24\n    #10 0x56401b6b35c2 in DestroyObjects third_party/dawn/src/dawn/native/Device.cpp:364:28\n    #11 0x56401b6b35c2 in dawn::native::DeviceBase::Destroy() third_party/dawn/src/dawn/native/Device.cpp:438:9\n    #12 0x56401b6b2c2b in dawn::native::DeviceBase::WillDropLastExternalRef() third_party/dawn/src/dawn/native/Device.cpp:309:5\n    #13 0x56401b785e7b in dawn::native::RefCountedWithExternalCount::APIRelease() third_party/dawn/src/dawn/native/RefCountedWithExternalCount.cpp:26:9\n    #14 0x56401c81b242 in dawn::wire::server::ServerBase::DestroyAllObjects(DawnProcTable const\u0026) gen/third_party/dawn/src/dawn/wire/server/ServerBase_autogen.h:162:21\n    #15 0x56401c817ee0 in dawn::wire::server::Server::~Server() third_party/dawn/src/dawn/wire/server/Server.cpp:43:5\n```\n\nNow, with the my future serial CL landed, the callback is from `ClearDeviceCallbacks(device);`.\n```\n    #4 0x5578ba0abcd2 in dawn::wire::server::Server::OnBufferMapAsyncCallback(dawn::wire::server::MapUserdata*, WGPUBufferMapAsyncStatus) third_party/dawn/src/dawn/wire/server/ServerBuffer.cpp:245:5\n    #5 0x5578ba0aceb4 in dawn::wire::server::ForwardToServerHelper\u003c\u0026dawn::wire::server::Server::OnBufferMapAsyncCallback(dawn::wire::server::MapUserdata*, WGPUBufferMapAsyncStatus)\u003e::ExtractedTypes\u003cvoid (dawn::wire::server::Server::*)(dawn::wire::server::MapUserdata*, WGPUBufferMapAsyncStatus)\u003e::Callback(WGPUBufferMapAsyncStatus, void*) third_party/dawn/src/dawn/wire/server/Server.h:78:13\n    #6 0x5578b8e1b4dd in OnMapRequestCompleted third_party/dawn/src/dawn/native/Buffer.cpp:565:5\n    #7 0x5578b8e1b4dd in dawn::native::(anonymous namespace)::MapRequestTask::Finish() third_party/dawn/src/dawn/native/Buffer.cpp:45:17\n    #8 0x5578b8ea4978 in dawn::native::DeviceBase::FlushCallbackTaskQueue() third_party/dawn/src/dawn/native/Device.cpp:1785:27\n    #9 0x5578b8ea5f31 in dawn::native::DeviceBase::APISetUncapturedErrorCallback(void (*)(WGPUErrorType, char const*, void*), void*) third_party/dawn/src/dawn/native/Device.cpp:569:5\n    #10 0x5578ba0249a7 in ClearDeviceCallbacks third_party/dawn/src/dawn/wire/server/Server.cpp:188:5\n    #11 0x5578ba0249a7 in dawn::wire::server::Server::~Server() third_party/dawn/src/dawn/wire/server/Server.cpp:41:9\n    #12 0x5578ba028607 in dawn::wire::server::Server::~Server() third_party/dawn/src/dawn/wire/server/Server.cpp:37:19\n\n```\n\nHere the buffer hasn\u0027t been mapped successfully yet or destroyed. But `FlushCallbackTaskQueue` always finishes callbacks with success. So the test runs into the null writeHandle. Probably the right fix should be that `FlushCallbackTaskQueue` finishes callback with error instead if it\u0027s called from [`APISetUncapturedErrorCallback`](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/Device.cpp;drc\u003d5722f2878dc3210f653ea42867fd16c72cc04377;l\u003d569).",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "485c0d70_12c3565e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-01T16:40:10Z",
      "side": 1,
      "message": "great find! sounds like the right approach to me that when we finish callbacks without actually knowing their status, we pass the correct enum.",
      "parentUuid": "292f4f5f_adcf0122",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef4fbe22_68653377",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-11-02T05:06:54Z",
      "side": 1,
      "message": "I\u0027ve dug a little deeper, as I was still not clear about why the `writeHandle` is null. It turned out the test case is quite nasty. It frees the buffer with ongoing MapAsyncCall, and create a new buffer with same id and generation. So the previous callback falls into the new buffer. In the old buffer creation, the usage is map write, however it\u0027s none in the new buffer creation. This is why the `writeHandle` is null.\n\n```\n Server::DoDeviceCreateBuffer(...)\n Server::DoBufferMapAsync(...)\n server::KnownObjectsBase\u003cWGPUBufferImpl*\u003e::Free()\n Server::DoDeviceCreateBuffer(...) // same id and generation as the previous one, but the map usage differs.\n Server::~Server()\n Server::OnBufferMapAsyncCallback(...)\n```\n\nSo I think it\u0027s correct for `FlushCallbackTaskQueue` to finish callbacks with success. Before the CL, it took at least a Queue::Tick. In this test case no Tick is even called. So previously the callback of success just didn\u0027t have a chance to run.\n\nIdeally to fix this, we should cancel the on-the-fly async callback when the server frees the buffer. In reality, this case should be very rare. Maybe it\u0027s enough to mitigate it by simply adding the check of same buffer object handles.",
      "parentUuid": "485c0d70_12c3565e",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "83e8182a_e38ab08e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-11-02T19:07:56Z",
      "side": 1,
      "message": "\u003e and create a new buffer with same id and generation\n\nHow is this possible? The server should be checking that the generation is strictly increasing here so the testcase can\u0027t recreate the same id/generation no?\n\nAaaand looking at the code it seems that we broke this assumption (and I\u0027m pretty sure it was one of my CLs ^^). It\u0027s probably best to add the check that the generation is monotonically increasing.",
      "parentUuid": "ef4fbe22_68653377",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f10adfa_1b6e6585",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-11-03T01:02:51Z",
      "side": 1,
      "message": "The debug log code:\n```\ndiff --git a/src/dawn/wire/server/ObjectStorage.h b/src/dawn/wire/server/ObjectStorage.h\nindex 1bef0ad84..6f3b19dd2 100644\n--- a/src/dawn/wire/server/ObjectStorage.h\n+++ b/src/dawn/wire/server/ObjectStorage.h\n@@ -25,6 +25,8 @@\n #include \"dawn/wire/WireCmd_autogen.h\"\n #include \"dawn/wire/WireServer.h\"\n \n+#include \u003cstdio.h\u003e\n+\n namespace dawn::wire::server {\n \n // Whether this object has been allocated, or reserved for async object creation.\n@@ -150,6 +152,7 @@ class KnownObjectsBase {\n \n     // Marks an ID as deallocated\n     void Free(uint32_t id) {\n+        fprintf(stderr, \"KnownObjectsBase::Free -- id:%d\\n\", id);\n         ASSERT(id \u003c mKnown.size());\n         mKnown[id].state \u003d AllocationState::Free;\n     }\ndiff --git a/src/dawn/wire/server/ServerBuffer.cpp b/src/dawn/wire/server/ServerBuffer.cpp\nindex 61d5e1542..2f4b20b06 100644\n--- a/src/dawn/wire/server/ServerBuffer.cpp\n+++ b/src/dawn/wire/server/ServerBuffer.cpp\n@@ -109,6 +109,9 @@ bool Server::DoDeviceCreateBuffer(ObjectId deviceId,\n         return false;\n     }\n \n+    fprintf(stderr, \"Server::DoDeviceCreateBuffer -- id:%d, generation:%d\\n\", bufferResult.id,\n+            bufferResult.generation);\n+\n     // Create and register the buffer object.\n     auto* resultData \u003d BufferObjects().Allocate(bufferResult.id);\n     if (resultData \u003d\u003d nullptr) {\n@@ -222,7 +225,10 @@ bool Server::DoBufferUpdateMappedData(ObjectId bufferId,\n void Server::OnBufferMapAsyncCallback(MapUserdata* data, WGPUBufferMapAsyncStatus status) {\n     // Skip sending the callback if the buffer has already been destroyed.\n     auto* bufferData \u003d BufferObjects().Get(data-\u003ebuffer.id);\n-    if (bufferData \u003d\u003d nullptr || bufferData-\u003egeneration !\u003d data-\u003ebuffer.generation) {\n+    fprintf(stderr, \"Server::OnBufferMapAsyncCallback -- id:%d, generation:%d\\n\", data-\u003ebuffer.id,\n+            data-\u003ebuffer.generation);\n+    if (bufferData \u003d\u003d nullptr || bufferData-\u003egeneration !\u003d data-\u003ebuffer.generation ||\n+        bufferData-\u003ehandle !\u003d data-\u003ebufferObj) {\n         return;\n     }\n\n```\n\nThe output of running the test:\n\n```\nINFO: Seed: 14387655\nINFO: Loaded 11 modules   (628043 inline 8-bit counters): 26472 [0x7fbc194852b0, 0x7fbc1948ba18), 15236 [0x7fbc196f709a, 0x7fbc196fac1e), 119 [0x7fbc19bfc0ba, 0x7fbc19bfc131), 18835 [0x7fbc199a015a, 0x7fbc199a4aed), 415 [0x7fbc19c16fba, 0x7fbc19c17159), 209151 [0x558d93c35c80, 0x558d93c68d7f), 10866 [0x7fbc14ad284a, 0x7fbc14ad52bc), 149094 [0x7fbc008eb350, 0x7fbc0090f9b6), 1476 [0x7fbc1182133a, 0x7fbc118218fe), 3259 [0x7fbc1174d4ca, 0x7fbc1174e185), 193120 [0x7fbbfee573d0, 0x7fbbfee86630), \nINFO: Loaded 11 PC tables (628043 PCs): 26472 [0x7fbc1948ba18,0x7fbc194f3098), 15236 [0x7fbc196fac20,0x7fbc19736460), 119 [0x7fbc19bfc138,0x7fbc19bfc8a8), 18835 [0x7fbc199a4af0,0x7fbc199ee420), 415 [0x7fbc19c17160,0x7fbc19c18b50), 209151 [0x558d93c68d80,0x558d93f99d70), 10866 [0x7fbc14ad52c0,0x7fbc14aff9e0), 149094 [0x7fbc0090f9b8,0x7fbc00b56018), 1476 [0x7fbc11821900,0x7fbc11827540), 3259 [0x7fbc1174e188,0x7fbc1175ad38), 193120 [0x7fbbfee86630,0x7fbbff178c30), \nout/fuzzer/dawn_wire_server_and_frontend_fuzzer: Running 1 inputs 1 time(s) each.\nRunning: /home/cj/Downloads/clusterfuzz-testcase-minimized-dawn_wire_server_and_frontend_fuzzer-5109820152807424\nServer::DoDeviceCreateBuffer -- id:1, generation:2\nKnownObjectsBase::Free -- id:1\nServer::DoDeviceCreateBuffer -- id:1, generation:2\nServer::OnBufferMapAsyncCallback -- id:1, generation:2\nExecuted /home/cj/Downloads/clusterfuzz-testcase-minimized-dawn_wire_server_and_frontend_fuzzer-5109820152807424 in 0 ms\n\n```\n\n\nThe call stack of `Server::DoDeviceCreateBuffer`:\n\n```\n    #4 0x55b0b886f058 in dawn::wire::server::Server::DoDeviceCreateBuffer(unsigned int, WGPUBufferDescriptor const*, dawn::wire::ObjectHandle, unsigned long, unsigned char const*, unsigned long, unsigned char const*) third_party/dawn/src/dawn/wire/server/ServerBuffer.cpp:114:5\n    #5 0x55b0b881d2c8 in HandleDeviceCreateBuffer gen/third_party/dawn/src/dawn/wire/server/ServerHandlers_autogen.cpp:818:24\n    #6 0x55b0b881d2c8 in dawn::wire::server::Server::HandleCommandsImpl(char const volatile*, unsigned long) gen/third_party/dawn/src/dawn/wire/server/ServerHandlers_autogen.cpp:2608:31\n    #7 0x55b0b83feb5a in DawnWireServerFuzzer::Run(unsigned char const*, unsigned long, bool (*)(dawn::native::Adapter const\u0026), bool) third_party/dawn/src/dawn/fuzzers/DawnWireServerFuzzer.cpp:134:17\n    #8 0x55b0b7511051 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) third_party/libFuzzer/src/FuzzerLoop.cpp:556:15\n    #9 0x55b0b74dc82e in fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) third_party/libFuzzer/src/FuzzerDriver.cpp:292:6\n    #10 0x55b0b74e98af in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) third_party/libFuzzer/src/FuzzerDriver.cpp:774:9\n    #11 0x55b0b754903d in main third_party/libFuzzer/src/FuzzerMain.cpp:19:10\n\n```\n\nWhere do you think we\u0027d best add the generation increasing check?",
      "parentUuid": "83e8182a_e38ab08e",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8021911c_f42e7ece",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-11-03T01:23:12Z",
      "side": 1,
      "message": "I don\u0027t know for sure how fuzzer works. I guess the id and generation are not generated by dawn. Likely they are just parsed by dawn from the downloaded test case.",
      "parentUuid": "6f10adfa_1b6e6585",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6a7016a6_c7548a0f",
        "filename": "src/dawn/wire/server/ServerBuffer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 226,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-11-01T14:02:54Z",
      "side": 1,
      "message": "[1]",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e7fe980_53978e7e",
        "filename": "src/dawn/wire/server/ServerBuffer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 226,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-11-02T05:06:54Z",
      "side": 1,
      "message": "A small correction of my previous comment here. Before the my future serial CL, we didn\u0027t run into the error was due to [2] rather other [1].\n```\nvoid BufferBase::DestroyImpl() {\n    if (mState \u003d\u003d BufferState::Mapped) {\n        UnmapInternal(WGPUBufferMapAsyncStatus_DestroyedBeforeCallback);\n    } else if (mState \u003d\u003d BufferState::MappedAtCreation) {\n        if (mStagingBuffer !\u003d nullptr) {\n            mStagingBuffer.reset();\n        } else if (mSize !\u003d 0) {\n            UnmapInternal(WGPUBufferMapAsyncStatus_DestroyedBeforeCallback);\n        }\n    }\n    mState \u003d BufferState::Destroyed;\n}\n```\nIt was `WGPUBufferMapAsyncStatus_DestroyedBeforeCallback`. But now it\u0027s `WGPUBufferMapAsyncStatus_Success`.",
      "parentUuid": "6a7016a6_c7548a0f",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08c101fb_35a24d29",
        "filename": "src/dawn/wire/server/ServerBuffer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 240,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-11-01T14:02:54Z",
      "side": 1,
      "message": "[2]",
      "revId": "0f038adb9812fc73bbb57b1f3283dcff2400fb33",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}