{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4f7777f3_3b9223f1",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 4
      },
      "lineNbr": 156,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-09-03T23:19:06Z",
      "side": 1,
      "message": "Adding CopySrc usage will affect validation such that buffers not explicitly created with CopySrc will be able to be copied from (using the public API). That\u0027s why the other enums use kReadOnlyStorageBuffer / kInternalStorageBuffer\n\nWe could do a similar thing, but I might prefer to add an mInternalUsage, similar to what was done recently in Texture.cpp and with CopyTextureToTextureInternal which is permitted to see the internal usages.",
      "range": {
        "startLine": 156,
        "startChar": 12,
        "endLine": 156,
        "endChar": 49
      },
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f23d0cd7_f72b6a79",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 4
      },
      "lineNbr": 156,
      "author": {
        "id": 1002757
      },
      "writtenOn": "2021-09-08T20:04:22Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4f7777f3_3b9223f1",
      "range": {
        "startLine": 156,
        "startChar": 12,
        "endLine": 156,
        "endChar": 49
      },
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad775284_5d37339d",
        "filename": "src/dawn_native/Buffer.cpp",
        "patchSetId": 4
      },
      "lineNbr": 156,
      "author": {
        "id": 1002757
      },
      "writtenOn": "2021-09-08T20:04:22Z",
      "side": 1,
      "message": "Done (added mInternalUsage)",
      "parentUuid": "4f7777f3_3b9223f1",
      "range": {
        "startLine": 156,
        "startChar": 12,
        "endLine": 156,
        "endChar": 49
      },
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "080af316_a4401dce",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 4
      },
      "lineNbr": 175,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-09-03T23:19:06Z",
      "side": 1,
      "message": "this performs the writes ~immediately. We don\u0027t want to do that because the command buffer might be submitted later.\n\nIf I create two command buffers A, then B, which both use indirect commands, and then submit only A, it\u0027ll be looking at the data for B that was recorded into the scratch buffer.\n\nIn general, problems if the end of another pass is encoded while another pass has yet to be submitted.\n\nSo problems if you do something like:\nconst encoderA \u003d device.createCommandEncoder();\nconst passA \u003d encoderA.beginRenderPass();\n// stuff\n\nconst encoderB \u003d device.createCommandEncoder();\nconst passB \u003d encoderB.beginRenderPass();\n// stuff\n\npassA.endPass() // pass A writes index buffer sizes;\npassB.endPass(); // oh no! pass B overwrite index buffer sizes for pass A!\n\n\nSo I think that:\n  1. The current scratch buffer offset should scoped to the RenderValidationEncoder - can we use the index (times stride) we\u0027re at in mIndexedIndirectDraws? Two passes from separate command encoders could be looking at the same scratch buffer, so we don\u0027t want the offset to be modified inside Claim(..);\n  2. As you mentioned, we\u0027ll probably need to keep a host-side allocation to hold the index buffer sizes.\n  3. We need to wait to perform writes until GPUQueue::Submit\n  \n  \nIn addition:\n\nNeed to check the spec, but I don\u0027t think we actually need to validate the index buffer size (passed to setIndexBuffer)!. On Vulkan, we rely on robust buffer access provided by the driver, and vkCmdBindIndexBuffer doesn\u0027t even take a size argument. The driver prevents reads from going outside of the buffer (bigger than the \"bound range\" for WebGPU). So I think WebGPU should use the same rule. basically: we can use the whole size of the buffer, not just the \"bound\" range. I\u0027m not sure if this actually helps. Trying to think to see if it simplifies the need for a potentially big host-side allocation to hold size information before submission..",
      "range": {
        "startLine": 175,
        "startChar": 12,
        "endLine": 175,
        "endChar": 77
      },
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "556e30e9_d9442e30",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 4
      },
      "lineNbr": 175,
      "author": {
        "id": 1002757
      },
      "writtenOn": "2021-09-08T20:04:22Z",
      "side": 1,
      "message": "New patch does things differently:\n\n- There are now two scratch buffers: one for the index buffer sizes, and one for the validated indirect params.\n\n- Index buffer sizes are serialized into a host buffer at encoding time and attached to a new WriteBuffer command. This has a thin impl in each backend which just delegates back to Queue::WriteBuffer.\n\n- The WriteBuffer command for a validation pass is encoded immediately before that validation pass, along with each buffer-to-buffer copy for the relevant indirect params.\n\nAs for what to validate exactly, I don\u0027t *think* it costs us extra to account for the bound range of an index buffer vs the total size. Without losing efficiency elsewhere I think we\u0027re always going to end up needing at least one u32 of metadata per draw call.",
      "parentUuid": "080af316_a4401dce",
      "range": {
        "startLine": 175,
        "startChar": 12,
        "endLine": 175,
        "endChar": 77
      },
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "169cf165_fa559454",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 4
      },
      "lineNbr": 175,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-09T16:40:01Z",
      "side": 1,
      "message": "I have some concerns with the current approach because the cost per drawIndexedIndirect seems relatively high (and application can do a lot of drawIndexedIndirect):\n - We allocate a DeferredBufferRef\n - We do a copyBufferToBuffer. Because the same buffer is written to (and because we don\u0027t do range tracking for buffer memory barriers), we end up generating a lot of TRANSFER_DST -\u003e TRANSFER_DST barriers. We also do a lot of small copies, spamming the frontend processor. (note that on some hardware, copies are done through compute shaders, but only above a certain size)\n \nThe type of code that would use drawIndexedIndirect would look a bit like the following:\n\n run dispatches to cull objects, write data in an indirect buffer.\n for each object:\n    record the indirect call\n\nThere are a lot of indirect calls, but most of them come from the same buffer so we should be able to do 1 dispatch that copies all of the indirect calls into a scratch buffer that will be sourced by the drawIndexedIndirect. The data passed to the shader could be prepped directly in the recording of DrawIndexedIndirect and the RenderValidation would use it directly.",
      "parentUuid": "556e30e9_d9442e30",
      "range": {
        "startLine": 175,
        "startChar": 12,
        "endLine": 175,
        "endChar": 77
      },
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2336e8a3_e5be4f26",
        "filename": "src/dawn_native/RenderValidationEncoder.cpp",
        "patchSetId": 4
      },
      "lineNbr": 175,
      "author": {
        "id": 1002757
      },
      "writtenOn": "2021-09-16T01:55:00Z",
      "side": 1,
      "message": "Thanks for the pointers here, makes tons of sense.\n\nWhat we do now is have a single validation pass for each unique tuple of (indirectBuffer, indexBufferNumElements). Per the above comment, this pass may also be chunked into multiple passes in the rare event that the number of draw calls or span of indirect offsets used is massive enough (on the order of millions in both cases).\n\nFor each pass, we bind the minimum necessary span of the indirect buffer containing all client\u0027s parameter blocks, as well as a buffer populated from host memory at encoding time, containing all offsets used from that buffer as well as the number of addressable index buffer elements at the time of the draw calls. Finally we also bind our validation output buffer as writable storage.\n\nThe validated parameters are copied out of the client\u0027s indirect buffer from their original offset and packed tightly into the output buffer on success. On failure the corresponding output bytes are instead zeroed out.",
      "parentUuid": "169cf165_fa559454",
      "range": {
        "startLine": 175,
        "startChar": 12,
        "endLine": 175,
        "endChar": 77
      },
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f0d72e3_3ea61922",
        "filename": "src/dawn_native/ValidationScratchBuffer.cpp",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-09-03T23:19:06Z",
      "side": 1,
      "message": "We could set the buffer as initialized so we don\u0027t incur a lazy clear when we use it. It\u0027s internally managed so this should be safe as long as we always populate the data in the compute pass.",
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9bc59397_02b97c95",
        "filename": "src/dawn_native/ValidationScratchBuffer.cpp",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1002757
      },
      "writtenOn": "2021-09-08T20:04:22Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1f0d72e3_3ea61922",
      "revId": "6b2418628cd1d5bb0eb8747ebf7d3d93cdc2c53f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}