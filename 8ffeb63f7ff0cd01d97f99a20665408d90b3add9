{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fc7933ed_9b2b893b",
        "filename": "src/dawn/tests/end2end/IOSurfaceWrappingTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 620,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "Move `RunInParallel` to TestUtils.h/cpp and reuse it?",
      "range": {
        "startLine": 618,
        "startChar": 4,
        "endLine": 620,
        "endChar": 42
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "23263722_2a1491d6",
        "filename": "src/dawn/tests/end2end/IOSurfaceWrappingTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 620,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fc7933ed_9b2b893b",
      "range": {
        "startLine": 618,
        "startChar": 4,
        "endLine": 620,
        "endChar": 42
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "276fbb83_477800f5",
        "filename": "src/dawn/tests/end2end/IOSurfaceWrappingTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 657,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "ditto: RunInParallel",
      "range": {
        "startLine": 655,
        "startChar": 3,
        "endLine": 657,
        "endChar": 34
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "809de635_9d17b6d4",
        "filename": "src/dawn/tests/end2end/IOSurfaceWrappingTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 657,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "276fbb83_477800f5",
      "range": {
        "startLine": 655,
        "startChar": 3,
        "endLine": 657,
        "endChar": 34
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "301dbe53_f5bd8b49",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 139,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "nit: can use RunInParallel",
      "range": {
        "startLine": 139,
        "startChar": 0,
        "endLine": 139,
        "endChar": 49
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7951c858_c04550bd",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 139,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "301dbe53_f5bd8b49",
      "range": {
        "startLine": 139,
        "startChar": 0,
        "endLine": 139,
        "endChar": 49
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7e59856_21ef97f1",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 140,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "nit: std::move here would make it more obvious we\u0027re taking the original ref and setting it to nullptr it at the end of this for-block",
      "range": {
        "startLine": 140,
        "startChar": 8,
        "endLine": 140,
        "endChar": 44
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c355307_72d47c4d",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 140,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c7e59856_21ef97f1",
      "range": {
        "startLine": 140,
        "startChar": 8,
        "endLine": 140,
        "endChar": 44
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81265844_1db64441",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 170,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "what is sleep and wait here important for?",
      "range": {
        "startLine": 169,
        "startChar": 3,
        "endLine": 170,
        "endChar": 15
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7276bca6_503be6e0",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 170,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T06:48:51Z",
      "side": 1,
      "message": "without a sleep, WaitABit() would be reached too fast here before the other threads even do the dropping. If that happened, the scenario that I want to test \"one or many devices being dropped while processEvents is in process\" wouldn\u0027t happen.\n\nbtw, I guess we can rely on the randomness nature of multithreading to make it happen without any sleep or random variable. But when testing locally, I noticed inserting a sleep here make it happen more consistently.",
      "parentUuid": "81265844_1db64441",
      "range": {
        "startLine": 169,
        "startChar": 3,
        "endLine": 170,
        "endChar": 15
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ae840e8e_3648f62d",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 170,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "Done. Removed all the explicit randomness \u0026 sleep.",
      "parentUuid": "7276bca6_503be6e0",
      "range": {
        "startLine": 169,
        "startChar": 3,
        "endLine": 170,
        "endChar": 15
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86bd6c57_3e172688",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 189,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "nit: can use RunInParallel",
      "range": {
        "startLine": 189,
        "startChar": 0,
        "endLine": 189,
        "endChar": 49
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6dc15de1_35a14671",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 189,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "86bd6c57_3e172688",
      "range": {
        "startLine": 189,
        "startChar": 0,
        "endLine": 189,
        "endChar": 49
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1ebdf51d_bc538641",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 190,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "ditto: std::move",
      "range": {
        "startLine": 190,
        "startChar": 0,
        "endLine": 190,
        "endChar": 44
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "49fcf9ad_eab003fb",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 190,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1ebdf51d_bc538641",
      "range": {
        "startLine": 190,
        "startChar": 0,
        "endLine": 190,
        "endChar": 44
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "572ab856_a678a53d",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 223,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "what is Wait important for? We\u0027re going to join and all the threads perform WaitABit",
      "range": {
        "startLine": 223,
        "startChar": 0,
        "endLine": 223,
        "endChar": 15
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59765e85_2b3e35e0",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 223,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T06:48:51Z",
      "side": 1,
      "message": "same as previous test, the scenario we want to test is that while processEvents is in progress on main thread, other threads drop devices (inside callback in this particular test).",
      "parentUuid": "572ab856_a678a53d",
      "range": {
        "startLine": 223,
        "startChar": 0,
        "endLine": 223,
        "endChar": 15
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c0a5575_2a4f36a5",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 223,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "oh wait, we already do `WaitABit()` on the child threads.",
      "parentUuid": "59765e85_2b3e35e0",
      "range": {
        "startLine": 223,
        "startChar": 0,
        "endLine": 223,
        "endChar": 15
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "675fcb4e_51d130ed",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 282,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "should have each thread write a different value.\n\nRight now, I believe all these pipelines are going to get deduped into the same one.\nNot only that, even if they weren\u0027t deduped, the test would pass if the implementation returned to you the \"wrong\" pipeline created by a different thread.\n\nBy having unique shaders, you can test that you actually got the pipeline you requested to compile.\n\n\nThere can be a separate test that creating multiple identical pipelines simultaneously on multiple threads yields pointer-equal pipelines. i.e. pipeline1.Get() \u003d\u003d pipeline2.Get(). That test would only be enabled without the wire",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 282,
        "endChar": 28
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7c9a68ea_51de8bcf",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 282,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "I think the purpose of this thread is creating pipeline in parallel doesn\u0027t race. Particularly the internal pipeline cache and async threads should be thread safe. We don\u0027t necessarily need to have unique pipeline returned on each thread.\n\nDone as suggested anw.",
      "parentUuid": "675fcb4e_51d130ed",
      "range": {
        "startLine": 282,
        "startChar": 0,
        "endLine": 282,
        "endChar": 28
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf1d79b6_69a2f8c9",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 352,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "same comments as in compute pipeline test",
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dd50e9b1_f275188f",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 352,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bf1d79b6_69a2f8c9",
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f20e0c5_11f90c7a",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 673,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "I like how `writeThread` has the signal/wait operations separately in the test body which makes it more clear what ordering is being tested.\n\nCould we have `CopyTextureToTextureInLockStep` do something similar? For example, I think the srcView, dstView, Wait, and Signal could be factored out to the caller.\n\nditto for `CopyBufferToTextureInLockStep`\n\nthat said.. what precisely is this testing?\n\nThe threads race on creating resources and views, then the copyThread waits for the writeThread to signal WriteTexture. Those are strictly ordered.\nMaybe you want to *encode* the CopyT2T at the same time as WriteTexture but defer submitting it until after WriteTexture occurs?\n\nI didn\u0027t fully review the tests after this - similar comments though",
      "range": {
        "startLine": 671,
        "startChar": 8,
        "endLine": 673,
        "endChar": 0
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e70da3c_3b2616b5",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 673,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T06:48:51Z",
      "side": 1,
      "message": "We can insert some renderings and expectations to the writing thread after it signals the copying thread to let some thing happen in parallel while the copying thread to the copying.\n\nThat\u0027s being said, originally I wanted to test that there is no deadlock happening when copying depth textures. Internally, this will create temp resources and queue a temp render pass do to a blit in BlitDepthToDepth.cpp.\n\nAfter several iterations, I realized the deadlock would be tested by enabling --enable-implicit-device-sync to test all singlethreaded tests with mutex in future. So we could modify this test a little bit, adding expectations to writing thread in parellel while the copying thread does the copy.",
      "parentUuid": "0f20e0c5_11f90c7a",
      "range": {
        "startLine": 671,
        "startChar": 8,
        "endLine": 673,
        "endChar": 0
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bdee5aac_2bee8885",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 673,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T09:04:02Z",
      "side": 1,
      "message": "btw, I think even without adding expectations on the writing thread, this test is still useful to verify that there is no race between texture\u0027s ref count dropped on writing thread and copy works being done on the copying thread.",
      "parentUuid": "7e70da3c_3b2616b5",
      "range": {
        "startLine": 671,
        "startChar": 8,
        "endLine": 673,
        "endChar": 0
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a5d64dd_7eee4231",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 673,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T15:05:44Z",
      "side": 1,
      "message": "\u003e I like how writeThread has the signal/wait operations separately in the test body which makes it more clear what ordering is being tested.\n\u003e\n\u003e Could we have CopyTextureToTextureInLockStep do something similar? For example, I think the srcView, dstView, Wait, and Signal could be factored out to the caller.\n\nDone",
      "parentUuid": "bdee5aac_2bee8885",
      "range": {
        "startLine": 671,
        "startChar": 8,
        "endLine": 673,
        "endChar": 0
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76425bf7_17d5ac0a",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 676,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-18T04:43:07Z",
      "side": 1,
      "message": "can be after the joins to keep the test precise",
      "range": {
        "startLine": 675,
        "startChar": 8,
        "endLine": 676,
        "endChar": 83
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a0439b4_8f3a6027",
        "filename": "src/dawn/tests/end2end/MultithreadTests.cpp",
        "patchSetId": 67
      },
      "lineNbr": 676,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-18T06:48:51Z",
      "side": 1,
      "message": "Why doing expectations on main thread is more precise? We might want to do another expectation in parallel on writing thread as well.",
      "parentUuid": "76425bf7_17d5ac0a",
      "range": {
        "startLine": 675,
        "startChar": 8,
        "endLine": 676,
        "endChar": 83
      },
      "revId": "8ffeb63f7ff0cd01d97f99a20665408d90b3add9",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}