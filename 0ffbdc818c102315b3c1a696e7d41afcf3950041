{
  "comments": [
    {
      "key": {
        "uuid": "e543764a_9d646de4",
        "filename": "src/dawn_native/opengl/TextureGL.cpp",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-03-13T06:43:37Z",
      "side": 1,
      "message": "This will be called when the texture refcount reaches zero, even if the texture is immune.\n\nI\u0027m worried that immunity might be dependent on the backend, for example in Metal we can wrap an IOSurface but the resulting texture isn\u0027t immune thanks to proper refcounting. Maybe immunity could be passed as a TextureBase argument so that the backends can choose?",
      "revId": "0ffbdc818c102315b3c1a696e7d41afcf3950041",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45998aaf_0320ce2f",
        "filename": "src/dawn_native/opengl/TextureGL.cpp",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2019-03-13T22:05:01Z",
      "side": 1,
      "message": "How should backend decide if they should be immune (other than being a swapchain texture)? Is metal the only one that has this special case?",
      "parentUuid": "e543764a_9d646de4",
      "revId": "0ffbdc818c102315b3c1a696e7d41afcf3950041",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "91d5f370_b2798f18",
        "filename": "src/dawn_native/opengl/TextureGL.cpp",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2019-03-13T22:26:40Z",
      "side": 1,
      "message": "The backend would just need to know whether it\u0027s a swapchain texture. Or, worded differently whether its native texture object is \"owned\" or \"non-owned\" (i.e. owned by something other than the Dawn Texture object).\n\nIn Vulkan, D3D12, and GL, it is \"non-owned\" (I think), but in Metal it is \"owned\" (the MTLTexture object is owned - the object represents a ref to the refcounted shared-ownership texture object).",
      "parentUuid": "45998aaf_0320ce2f",
      "revId": "0ffbdc818c102315b3c1a696e7d41afcf3950041",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08a30af2_6b975dcb",
        "filename": "src/dawn_native/opengl/TextureGL.cpp",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-03-13T23:30:01Z",
      "side": 1,
      "message": "+1 to Corentin and Kai.\n\nMy proposal:\n1) Have an enum with three members: owned, unowned and destroyed. \"Owned\" means the resource is owned by the Texture object itself. \"unowned\" means the resource is owned by another object such as a swapchain. \u0027Destroyed\u0027 means the Texture object has destroyed the resource. \n2) Texture::DestroyImpl would be overridden by the subclasses and destroy the texture with the device no matter what. \n3) TextureBase::Destroy would look at the member variable enum and decide whether to call DestroyImpl on the subclass. Owned textures would call DestroyImpl and set the enum to the \u0027destroyed\u0027 state. Unowned textures would skip the call to DestroyImpl.\n4) TextureBase constructor would expose parameter for the starting value of the enum that subclasses can fill with what they think is best.\n\nFrom code inspection, I think SwapChain Texture objects should be created as \u0027unowned\u0027 for GL, D3D12 and Vulkan backends and \u0027owned\u0027 for Metal. In Metal\u0027s implementation of SwapChainImplMTL::GetNextTexture, it calls \u0027retain\u0027 on the texture before giving it to the Texture object. Hence, the texture object should be responsible for releasing it.\n\nI do not feel strongly about the names so feel free to suggest better ones. Perhaps \u0027Owned\u0027, \u0027ImmuneFromDestruction\u0027 and \u0027Destroyed\u0027 would work better?\n\nShould calling Destroy on a SwapChain texture be an error or should we just ignore it?  Should calling Destroy twice on a Texture or Buffer be an error? My preference would be for it to be an error. Probably something we should discuss with the community group",
      "parentUuid": "91d5f370_b2798f18",
      "revId": "0ffbdc818c102315b3c1a696e7d41afcf3950041",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "465740db_c7ff6202",
        "filename": "src/dawn_native/opengl/TextureGL.cpp",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2019-03-13T23:32:20Z",
      "side": 1,
      "message": "It would probably be fine if calling Destroy on a SwapChain texture caused it to enter the \"destroyed\" state. As long as it doesn\u0027t actually try to destroy the handle.\n\nI guess we also need to make sure that the Texture can\u0027t outlive the SwapChain that its handle comes from.",
      "parentUuid": "08a30af2_6b975dcb",
      "revId": "0ffbdc818c102315b3c1a696e7d41afcf3950041",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b83f20e_6aec6d84",
        "filename": "src/dawn_native/opengl/TextureGL.cpp",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-03-13T23:47:53Z",
      "side": 1,
      "message": "@Kai, a texture can outlive its swapchain if the Javascript developer keeps a reference to the texture after the swapchain has been garbage collected. In this instance, I do not see a problem with the developer rendering to a texture that is never shown to the user. We should avoid exposing garbage collection details to web developers.\n\nIs it the case that Texture objects are guarenteed to have a valid resource at creation?  If so, we can add a boolean for owned vs. not-owned and use the pointer to the resource to denote destroy vs. not-destroyed. In this approach, the impl object takes care of reading the owned boolean and decide what to do with the resource in addition to clearing the handle/pointer. We end up with fewer overall states to track with this solution.",
      "parentUuid": "465740db_c7ff6202",
      "revId": "0ffbdc818c102315b3c1a696e7d41afcf3950041",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d711b70_6d63ab2c",
        "filename": "src/dawn_native/opengl/TextureGL.cpp",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-03-14T00:03:58Z",
      "side": 1,
      "message": "+1 to being able to destroy unowned textures, that\u0027s useful for swapchain and also for Chromium SharedImages imported in Dawn. We discussed what should happen when destroy is called twice in the group. I think we decided it is _not_ an error so that applications can defensively call destroy() to make sure they free the memory.\n\nTextures are guaranteed a valid resource at creation, so either of Rafael\u0027s implementation proposals sound good.",
      "parentUuid": "2b83f20e_6aec6d84",
      "revId": "0ffbdc818c102315b3c1a696e7d41afcf3950041",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b7ac4c6_38c107c1",
        "filename": "src/dawn_native/opengl/TextureGL.cpp",
        "patchSetId": 5
      },
      "lineNbr": 134,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-03-14T00:28:45Z",
      "side": 1,
      "message": "\u003e +1 to being able to destroy unowned textures\n\nMy point was that if the swapchain got garbage collected before one of its textures did, we should prevent the developer from being able to detect this. So having Destroy eagerly release resources is OK but swapchain garbage collection should not eargerly destroy the underlying textures.\n\nBy the way, the way code is currently setup, the web developer can detect how many textures are in a swapchain by keeping pointers to the handed out textures and doing test renders to see if content shows up in more than one place. I know there was reticence in the F2F meeting on exposing the length of the swap chain. Perhaps we should plug this hole by having the swap chain destroy its underlying textures on present.  \n\n\u003e I think we decided it is _not_ an error so that applications can defensively call destroy() to make sure they free the memory.\n\nThanks for the reminder. That makes sense.",
      "parentUuid": "7d711b70_6d63ab2c",
      "revId": "0ffbdc818c102315b3c1a696e7d41afcf3950041",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}