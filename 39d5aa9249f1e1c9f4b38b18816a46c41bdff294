{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1bb45371_72689209",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2021-11-23T23:36:56Z",
      "side": 1,
      "message": "Wow, not sure what\u0027s going on with the CQ failures... the failures look precisely like the ones this CL is supposed to ultimately fix ðŸ˜­",
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "521929e3_b9516c48",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2021-11-24T01:22:30Z",
      "side": 1,
      "message": "Okay, FXC is really broken. Now it\u0027s producing an infinite loop with optimizations disabled. Here\u0027s what it fails on:\n\n//1: /* Dumped generated HLSL */\nvoid atomicStore_1(RWByteAddressBuffer buffer, uint offset, uint value) {\n  uint ignored;\n  buffer.InterlockedExchange(offset, value, ignored);\n}\n\nRWByteAddressBuffer output : register(u0, space0);\n\n[numthreads(1, 1, 1)]\nvoid main() {\n  float2 testVar \u003d float2(0.0f, 0.0f);\n  {\n    [loop] for(uint i0 \u003d 0u; (i0 \u003c 2u); i0 \u003d (i0 + 1u)) {\n      if ((testVar[min(i0, 1u)] !\u003d 0.0f)) {\n        atomicStore_1(output, 0u, 1u);\n      }\n      //if (i0 \u003c 2u) break;\n    }\n  }\n  return;\n}\n\nWhen optimizations are enabled, FXC figures out that this loop does nothing (note that testVar is initialized to 0, so the \"if\" in the loop is always false), and emits a valid empty program:\n\ncs_5_1\ndcl_globalFlags refactoringAllowed | skipOptimization\ndcl_thread_group 1, 1, 1\nret\n\nOTOH, with optimizations disabled, it still sees that the loop does nothing BUT because of the [loop] attribute, it emits a loop that never breaks -- at least, that\u0027s my suspicion. Here\u0027s what it outputs:\n\ncs_5_1\ndcl_globalFlags refactoringAllowed | skipOptimization\ndcl_uav_raw U0[0:0], space\u003d0\ndcl_temps 1\ndcl_thread_group 1, 1, 1\nloop\n  mov r0.x, l(0)\n  ne r0.x, r0.x, l(0.000000)\n  if_nz r0.x\n    mov r0.x, l(0)\n    mov r0.y, l(1)\n    imm_atomic_exch r0.x, U0[0], r0.x, r0.y\n  endif\nendloop\nret\n\nNow here\u0027s something interesting. If I take the loop condition, and simply repeat it at the top of the for loop body and break, like this:\n\n    [loop] for(uint i0 \u003d 0u; (i0 \u003c 2u); i0 \u003d (i0 + 1u)) {\n      if (i0 \u003c 2u) break; // \u003c-- repeat exit condition\n\n      if ((testVar[min(i0, 1u)] !\u003d 0.0f)) {\n        atomicStore_1(output, 0u, 1u);\n      }\n    \n    }\n\nWhen I compile with FXC with optimizations disabled, it now produces the empty program (!!) and emits these warnings:\n\nC:\\src\\tint\\out\\build\\x64-Debug\\70700.hlsl(13,12-55): warning X3557: loop only executes for 0 iteration(s), consider removing [loop]\nC:\\src\\tint\\out\\build\\x64-Debug\\70700.hlsl(13,12-55): warning X3557: loop doesn\u0027t seem to do anything, consider removing [loop]\n\nWhat this reveals is that the infinite loop generation bug in FXC has to do with the compiler deciding to generate a loop AND having determined that the loop doesn\u0027t do anything. In that case, it generates the loop body with no exit condition! This is pretty terrible.\n\nSince repeating the break condition seems to have worked here, my guess is that the problem happens with \u0027for\u0027 loops, but maybe not \u0027while\u0027 loops. If I rewrite the for loop as a while (true) loop, FXC still gives the 2 warnings, but produces a valid empty program:\n\n    uint i0 \u003d 0u;\n    [loop] while (true) {\n      if (i0 \u003c 2u) break; // \u003c-- repeat exit condition\n\n      if ((testVar[min(i0, 1u)] !\u003d 0.0f)) {\n        atomicStore_1(output, 0u, 1u);\n      }\n      \n      i0 \u003d (i0 + 1u);\n    }\n  }\n\nSo maybe the HLSL backend should always emit \u0027while (true)\u0027 loops... ðŸ˜ž",
      "parentUuid": "1bb45371_72689209",
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c510108_54572ed0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2021-11-24T03:19:10Z",
      "side": 1,
      "message": "Took another look. I realized that I had forgotten to \"gclient sync\" my Dawn checkout, which is why my comment above shows code with the \"[loop]\" attribute, despite this change having been reverted. Turns out that the \"[loop]\" attribute here has no bearing on the bug.\n\nSo let me rephrase what I wrote above without mixing up the \"[loop]\" attribute in there:\n\nFXC fails to compiles loops into infinite loops if:\n1. Optimizations are disabled (the point of this CL)\n2. FXC statically determines that the loop does nothing\n\nSo the \"[loop]\" attribute has no bearing. Indeed, the CQ failures here are running without the \"[loop]\" change.\n\nKeep in mind that FXC ALSO fails to compile loops into infinite loops when optimizations are _enabled_ in some cases, like https://crbug.com/tint/1175. In this case, FXC miscompiles when there are early returns in the loop. With this new information, I tried modifying the 1175 code by replacing for loops with while loops, and it still miscompiles with optimizations enabled, but compiles correctly with optimizations disabled.\n\nSo what\u0027s my conclusion? Well, I think it\u0027s this:\n\n1. FXC\u0027s optimizations are broken, we should disable them (this CL).\n2. FXC\u0027s analysis of loops are broken, we should effectively disable them by replacing for loops with while loops.\n\nIf I\u0027m right, then we can\u0027t land this CL before we modify Tint to produce while loops instead of for loops in the HLSL backend.\n\nThat\u0027s where I\u0027m at at 10:20 pm on Tuesday night.",
      "parentUuid": "521929e3_b9516c48",
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "738438ec_9ca8e292",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2021-11-24T03:37:00Z",
      "side": 1,
      "message": "10:30 pm: scratch that. FXC still miscompiles to infinite loops even when I make \"for\" loops into \"while\" loops... except if I repeat the loop condition as the last statement in the while loop:\n\n    uint i0 \u003d 0u;\n    while (true) {\n      if (!((i0 \u003c 2u))) { break; }\n      if ((testVar[min(i0, 1u)] !\u003d 0.0f)) {\n        atomicStore_1(output, 0u, 1u);\n      }\n      i0 \u003d (i0 + 1u);\n      if (!((i0 \u003c 2u))) { break; } // Repeat break condition\n    }\n    \nDoing this in for loops doesn\u0027t work, though.\n\nSorry for the wall of text, btw.",
      "parentUuid": "9c510108_54572ed0",
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca834cac_fae6d56e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2021-11-24T03:53:39Z",
      "side": 1,
      "message": "10:45 pm: OMG, I can\u0027t believe this! I was thinking about how \"skip/disable optimizations (/Od)\" is a separate flag from the actual optimization level (e.g. \"/O2\"), so then I wondered -- what if I disable optimizations AND I tell it to optimize at level 0? In other words, calling \"fxc /Od /O0 ...\". I figured, maybe the bad analysis of loops is coming from the optimization level being at 2 (the default), while skip optimizations is something that\u0027s orthogonal and applied afterwards or something. Well, I just tried it against the above examples, and it does the right thing for both \"for\" and \"while\" loops!\n\nI need to run more tests, but maybe we can set only optimization level 0 (/O0) and forget about skip optimizations (/Od). I\u0027m not sure yet.",
      "parentUuid": "738438ec_9ca8e292",
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a987e8b8_72eef77d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-11-24T13:04:14Z",
      "side": 1,
      "message": "Oh wow that\u0027s crazy, both the bugs with FXC failing to compile infinite loops and the double flags being required to completely disable optimizations! (also 11PM Tuesday night \u003e_\u003e)\n\nPassing both flags SGTM.",
      "parentUuid": "ca834cac_fae6d56e",
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4442c7a_041e3c8f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2021-11-24T16:06:47Z",
      "side": 1,
      "message": "It looks like \"/O0\" should be enough. Am trying with that, since adding \"/Od\" produces even less optimal code. Updloaded a new patch, let\u0027s see how it goes with CQ.",
      "parentUuid": "a987e8b8_72eef77d",
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d27dcd96_9adfeb00",
        "filename": "src/dawn_native/Toggles.h",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2021-11-23T18:59:53Z",
      "side": 1,
      "message": "@cwallez In chat, Ben suggested that perhaps we want a more specific flag like \"fxc_optimizations\" set to false by default. The reason I went for this flag was that it was more general, and could be used to disable DXC optimizations in the future. However, I admit that it\u0027s confusing that this flag is true for FXC, but false for DXC. What do you think?",
      "range": {
        "startLine": 63,
        "startChar": 8,
        "endLine": 63,
        "endChar": 28
      },
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f79e6f0_cc8598ce",
        "filename": "src/dawn_native/Toggles.h",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2021-11-23T19:02:51Z",
      "side": 1,
      "message": "That was half my nit, the other half is the double negative in usage `disable-dawn-features\u003ddisable_optimizations`.\n\n`enable-dawn-features\u003dfxc_optimizations` is what I\u0027d guess the toggle is without looking it up.\n\nI\u0027d probably be happy with `enable-dawn-features\u003dshader_optimizations`, if you want something generic, but \u0027optimizations\u0027 is very non-shader specific.",
      "parentUuid": "d27dcd96_9adfeb00",
      "range": {
        "startLine": 63,
        "startChar": 8,
        "endLine": 63,
        "endChar": 28
      },
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f77c36fb_3670e2ab",
        "filename": "src/dawn_native/Toggles.h",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-11-24T13:04:14Z",
      "side": 1,
      "message": "Yeah there\u0027s a number of toggles I\u0027d like to rename to not cause double negatives. fxc_optimistations with a SetToggle in d3d12::Device::SetToggles sounds good.",
      "parentUuid": "8f79e6f0_cc8598ce",
      "range": {
        "startLine": 63,
        "startChar": 8,
        "endLine": 63,
        "endChar": 28
      },
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "939051b7_3e1ba2ce",
        "filename": "src/dawn_native/Toggles.h",
        "patchSetId": 2
      },
      "lineNbr": 63,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2021-11-24T16:06:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f77c36fb_3670e2ab",
      "range": {
        "startLine": 63,
        "startChar": 8,
        "endLine": 63,
        "endChar": 28
      },
      "revId": "39d5aa9249f1e1c9f4b38b18816a46c41bdff294",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}