{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "71f5da47_8b827679",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2023-10-09T10:04:49Z",
      "side": 1,
      "message": "PTAL, thanks!",
      "revId": "131fc7dee17b2ce022ddb7ef58981ab47a7aad8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7c019268_22eab2da",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-10-09T13:57:09Z",
      "side": 1,
      "message": "LGTM",
      "revId": "131fc7dee17b2ce022ddb7ef58981ab47a7aad8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd644799_c8419246",
        "filename": "src/dawn/tests/end2end/MaxLimitTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 734,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-10-09T13:57:09Z",
      "side": 1,
      "message": "nit: variableCount?\n\nAlso nit: could be an array of structures instead of structure of array.",
      "range": {
        "startLine": 734,
        "startChar": 32,
        "endLine": 734,
        "endChar": 50
      },
      "revId": "131fc7dee17b2ce022ddb7ef58981ab47a7aad8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "273c5575_13d9cdfa",
        "filename": "src/dawn/tests/end2end/MaxLimitTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 754,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-10-09T13:57:09Z",
      "side": 1,
      "message": "I think this could be simpler by doing the following (assuming a variableSize of 5 is valid if the count is 0):\n\n```\n// Try to allocate all variables using whatever type makes sure we don\u0027t go past the interStageVariableCount and use the second set of variables to add extra components if that size is too small.\nallocation[0].variableSize \u003d userDefinedInterStageComponents / interStageVariableCount;\nallocation[1].variableSize \u003d allocation.variableSize[1]; + 1;\n\n// We need to add as many variables to the second set as there are missing component if all variables are in the first set.\nallocation[1].variableCount \u003d userDefinedInterStageComponents - interStageVariableCount * allocation[0].variableSize;\nallocation[0].variableCount \u003d interStageVariableCount - allocation[1].variableCount;\n```",
      "revId": "131fc7dee17b2ce022ddb7ef58981ab47a7aad8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d646b88a_201ce256",
        "filename": "src/dawn/tests/end2end/MaxLimitTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 804,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-10-09T13:57:09Z",
      "side": 1,
      "message": "I can\u0027t remember for sure, but are we allowed to nest IO structs?\n\n```\nstruct InterStage {\n  foo: f32,\n  bar : f32,\n}\n\nstruct VertexOutput {\n  is : InterStage,\n  @builtin(position) pos : vec4f,\n}\n\nstrict FragmentInput {\n  is : InterStage,\n  // other builtins\n}\n```\n\nIt could help simplify the code by having `GetInterStageVariableDeclarations` just used a single time for both shaders, so we have a single source and a single module.\n\n(and potentially we can loop over the variables only once, adding to the InterStage struct, its creation in the VS, its consumption in the FS and assembling everything at the end)",
      "revId": "131fc7dee17b2ce022ddb7ef58981ab47a7aad8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}