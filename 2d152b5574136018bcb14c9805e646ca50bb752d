{
  "comments": [
    {
      "key": {
        "uuid": "3baac4b2_7b1c059b",
        "filename": "src/dawn_native/d3d12/LRUCacheD3D12.cpp",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-01-22T18:25:32Z",
      "side": 1,
      "message": "Heavy usage of CONTAINING_RECORD here. I understand its perfectly acceptable to use CONTAINING_RECORD - however in the context of Dawn it strikes me as a \"use only if absolutely necessary\" sort of a thing.",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "919fa071_04c88fbd",
        "filename": "src/dawn_native/d3d12/LRUCacheD3D12.cpp",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T21:48:23Z",
      "side": 1,
      "message": "I looked at other Chromium code to see if there is precedence for what we\u0027re doing and I found a very similar container class in base/containers/linked_list.h.  \n\nNote how:\n* The linked list class itself does no memory allocation. Rather, it accepts already allocated nodes from elsewhere. \n* The node class of LinkedList contains no domain-specific information, just forward and backward pointers. Domain-specific information is kept in classes derived from the node class. \n* The linked list class also has no domain-specific information, it just does linked list things. \n* Policy for where in the list things get added (front vs back) are done outside of the linked list class.\n* All insertions and deletions are O(1)\n\nYou\u0027ve written a similar class but used containment for node storage instead of derivation. Derivation has the disadvantage that list items can only belong to one list at a time but that might be fine for our purposes. \n\nIf you want to re-use the class in linked_list, I would not be opposed. However, if we keep what you have, we should break apart the domain management such that the node and list classes do not contain any D3D12 things in them. \n\nIf we do not want to have all of these allocation types, perhaps we can store a pointer to the D3D12 object in the node derived class and put the node derived class in ResourceHeapAllocation and Heap.",
      "parentUuid": "3baac4b2_7b1c059b",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32cc2f2a_18ce487d",
        "filename": "src/dawn_native/d3d12/LRUCacheD3D12.cpp",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T22:06:03Z",
      "side": 1,
      "message": "Another option to storing data in the node class directly is to have the Node class contain virtual methods. In the derived node classes, the implementations of the virtual methods can do the correct CONTAINING_RECORD business to answer questions about the resource.",
      "parentUuid": "919fa071_04c88fbd",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "283c35bb_7d0cb58b",
        "filename": "src/dawn_native/d3d12/LRUCacheD3D12.cpp",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-01-22T22:56:47Z",
      "side": 1,
      "message": "For me, the use of CONTAINING_RECORD isn\u0027t of concern but the fact there is D3D12 stuff being woven into a generic container class.\n\nHow about instead of having an allocation contain a LRUEntry, flip it? Store the Heap in the LRUEntry. If we cache both the size and pagable, there is no need to know the allocation type anymore.",
      "parentUuid": "919fa071_04c88fbd",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0eef5c85_c7bf519a",
        "filename": "src/dawn_native/d3d12/LRUCacheD3D12.h",
        "patchSetId": 5
      },
      "lineNbr": 29,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-01-22T18:25:32Z",
      "side": 1,
      "message": "Had to add this enum to know which type to go back to through CONTAINING_RECORD. AllocationMethod already exists and is basically the same, however I needed to have the kHeap type.",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dbad1d9c_13d65960",
        "filename": "src/dawn_native/d3d12/LRUCacheD3D12.h",
        "patchSetId": 5
      },
      "lineNbr": 63,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-01-22T18:25:32Z",
      "side": 1,
      "message": "I chose to keep allocation size cached on the entry. This could be eliminated and looked up at Evict/MakeResident time.",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80c4d731_ee16d076",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.cpp",
        "patchSetId": 5
      },
      "lineNbr": 24,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-01-22T18:25:32Z",
      "side": 1,
      "message": "Added AllocationType parameter in constructor. I must have this to initialize and then differentiate an LRUEntry. This type is almost, but not quite a duplication of AllocationInfo.mMethod.",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ebb7273_070edf64",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 5
      },
      "lineNbr": 39,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-01-22T18:25:32Z",
      "side": 1,
      "message": "LRUEntry at a minimum must store pointers to the next and previous links, as well as the AllocationType enum. By making this a member, it means those bytes are always being allocated, whether it\u0027s used in the LRUCache or not (an entry is only needed for AllocationMethod::kDirect). Previously, we just had a pointer to the entry, which meant we only had to allocate the entry if we needed one, otherwise it was just an unused pointer. Since kSubAllocation types should always be the most abundant of the types, it seems like the net effect could actually be more bytes used.",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4cf2ff07_9fb2b6a0",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 5
      },
      "lineNbr": 39,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-22T21:48:23Z",
      "side": 1,
      "message": "How is the current code tracking sub allocations and evicting the containing heap?",
      "parentUuid": "0ebb7273_070edf64",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9314c286_c943c058",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 5
      },
      "lineNbr": 39,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-01-22T22:49:29Z",
      "side": 1,
      "message": "Suballocations are not really tracked from a residency perspective. In D3D12, we can\u0027t change the residency of a suballocation, but we can change the residency of the heap it\u0027s contained in. \n\nSo if a suballocation needs to be resident, its entire heap must made resident. That heap\u0027s position in the LRU cache is dependent on how recently any underlying suballocation was referenced.",
      "parentUuid": "4cf2ff07_9fb2b6a0",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ecc4b59b_13f07b9f",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-01-22T18:25:32Z",
      "side": 1,
      "message": "Had to make LRUEntry a friend in order to use CONTAINING_RECORD.\n\n(Comment applies to the Heap type as well)",
      "revId": "2d152b5574136018bcb14c9805e646ca50bb752d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}