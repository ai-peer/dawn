// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// DO NOT EDIT THIS FILE: This file is autogenerated

#include <algorithm>
#include <memory>
#include <utility>
#include <vector>

#include "dawn/fuzzers/lpmfuzz/DawnLPMConstants_gen.h"
#include "dawn/fuzzers/lpmfuzz/DawnLPMSerializer_gen.h"
#include "dawn/fuzzers/lpmfuzz/FuzzObjectIdProvider.h"
#include "dawn/fuzzers/lpmfuzz/FuzzObjectStore.h"
#include "dawn/fuzzers/lpmfuzz/dawn_lpm.pb.h"
#include "dawn/webgpu.h"
#include "dawn/wire/Wire.h"
#include "dawn/wire/WireClient.h"
#include "dawn/wire/WireCmd_autogen.h"
#include "dawn/wire/client/ApiObjects_autogen.h"
#include "dawn/wire/client/Client.h"

namespace dawn::wire {

void GetSerializedData(const fuzzing::Program& program,
                       dawn::wire::ChunkedCommandSerializer serializer) {
    FuzzObjectIdProvider provider;
    ityp::array<ObjectType, client::FuzzObjectStore, 24> gObjectStores;

    for (const fuzzing::Command& command : program.commands()) {
        switch (command.command_case()) {
            case fuzzing::Command::kAdapterRequestDevice: {
                AdapterRequestDeviceCmd cmd;
                memset(&cmd, 0, sizeof(AdapterRequestDeviceCmd));

                cmd.adapterId = gObjectStores[ObjectType::Adapter].Get(
                    command.adapterrequestdevice().adapterid());
                cmd.requestSerial = command.adapterrequestdevice().requestserial();
                if (gObjectStores[ObjectType::Device].size() > DEVICE_LIMIT) {
                    break;
                }
                cmd.deviceObjectHandle = gObjectStores[ObjectType::Device].ReserveHandle();
                // start structure WGPUDeviceDescriptor
                WGPUDeviceDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUDeviceDescriptor));

                // start variable length WGPUFeatureName[]
                size_t dawn_descriptorN_requiredfeatures_size =
                    command.adapterrequestdevice().desc().requiredfeatures().size();
                std::unique_ptr<WGPUFeatureName[]> dawn_descriptorN_requiredfeatures(
                    new WGPUFeatureName[dawn_descriptorN_requiredfeatures_size]);
                for (size_t i = 0; i < dawn_descriptorN_requiredfeatures_size; i++) {
                    dawn_descriptorN_requiredfeatures[i] = static_cast<WGPUFeatureName>(
                        command.adapterrequestdevice().desc().requiredfeatures(i));
                }

                dawn_descriptor.requiredFeatures = dawn_descriptorN_requiredfeatures.get();
                dawn_descriptor.requiredFeaturesCount =
                    command.adapterrequestdevice().desc().requiredfeatures().size();
                // end variablelength WGPUFeatureName[]
                // start structure WGPURequiredLimits
                WGPURequiredLimits dawn_descriptor_requiredlimits;
                memset(&dawn_descriptor_requiredlimits, 0, sizeof(struct WGPURequiredLimits));

                // start structure WGPULimits
                WGPULimits dawn_descriptor_requiredlimits_limits;
                memset(&dawn_descriptor_requiredlimits_limits, 0, sizeof(struct WGPULimits));

                dawn_descriptor_requiredlimits_limits.maxTextureDimension1D =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxtexturedimension1d();
                dawn_descriptor_requiredlimits_limits.maxTextureDimension2D =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxtexturedimension2d();
                dawn_descriptor_requiredlimits_limits.maxTextureDimension3D =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxtexturedimension3d();
                dawn_descriptor_requiredlimits_limits.maxTextureArrayLayers =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxtexturearraylayers();
                dawn_descriptor_requiredlimits_limits.maxBindGroups =
                    command.adapterrequestdevice().desc().requiredlimits().limits().maxbindgroups();
                dawn_descriptor_requiredlimits_limits.maxBindingsPerBindGroup =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxbindingsperbindgroup();
                dawn_descriptor_requiredlimits_limits.maxDynamicUniformBuffersPerPipelineLayout =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxdynamicuniformbuffersperpipelinelayout();
                dawn_descriptor_requiredlimits_limits.maxDynamicStorageBuffersPerPipelineLayout =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxdynamicstoragebuffersperpipelinelayout();
                dawn_descriptor_requiredlimits_limits.maxSampledTexturesPerShaderStage =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxsampledtexturespershaderstage();
                dawn_descriptor_requiredlimits_limits.maxSamplersPerShaderStage =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxsamplerspershaderstage();
                dawn_descriptor_requiredlimits_limits.maxStorageBuffersPerShaderStage =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxstoragebufferspershaderstage();
                dawn_descriptor_requiredlimits_limits.maxStorageTexturesPerShaderStage =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxstoragetexturespershaderstage();
                dawn_descriptor_requiredlimits_limits.maxUniformBuffersPerShaderStage =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxuniformbufferspershaderstage();
                dawn_descriptor_requiredlimits_limits.maxUniformBufferBindingSize =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxuniformbufferbindingsize();
                dawn_descriptor_requiredlimits_limits.maxStorageBufferBindingSize =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxstoragebufferbindingsize();
                dawn_descriptor_requiredlimits_limits.minUniformBufferOffsetAlignment =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .minuniformbufferoffsetalignment();
                dawn_descriptor_requiredlimits_limits.minStorageBufferOffsetAlignment =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .minstoragebufferoffsetalignment();
                dawn_descriptor_requiredlimits_limits.maxVertexBuffers =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxvertexbuffers();
                dawn_descriptor_requiredlimits_limits.maxBufferSize =
                    command.adapterrequestdevice().desc().requiredlimits().limits().maxbuffersize();
                dawn_descriptor_requiredlimits_limits.maxVertexAttributes =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxvertexattributes();
                dawn_descriptor_requiredlimits_limits.maxVertexBufferArrayStride =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxvertexbufferarraystride();
                dawn_descriptor_requiredlimits_limits.maxInterStageShaderComponents =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxinterstageshadercomponents();
                dawn_descriptor_requiredlimits_limits.maxInterStageShaderVariables =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxinterstageshadervariables();
                dawn_descriptor_requiredlimits_limits.maxColorAttachments =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxcolorattachments();
                dawn_descriptor_requiredlimits_limits.maxComputeWorkgroupStorageSize =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxcomputeworkgroupstoragesize();
                dawn_descriptor_requiredlimits_limits.maxComputeInvocationsPerWorkgroup =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxcomputeinvocationsperworkgroup();
                dawn_descriptor_requiredlimits_limits.maxComputeWorkgroupSizeX =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxcomputeworkgroupsizex();
                dawn_descriptor_requiredlimits_limits.maxComputeWorkgroupSizeY =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxcomputeworkgroupsizey();
                dawn_descriptor_requiredlimits_limits.maxComputeWorkgroupSizeZ =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxcomputeworkgroupsizez();
                dawn_descriptor_requiredlimits_limits.maxComputeWorkgroupsPerDimension =
                    command.adapterrequestdevice()
                        .desc()
                        .requiredlimits()
                        .limits()
                        .maxcomputeworkgroupsperdimension();
                // end structure WGPULimits
                dawn_descriptor_requiredlimits.limits = dawn_descriptor_requiredlimits_limits;
                // end structure WGPURequiredLimits
                dawn_descriptor.requiredLimits = &dawn_descriptor_requiredlimits;  // HARDCODED
                // start structure WGPUQueueDescriptor
                WGPUQueueDescriptor dawn_descriptor_defaultqueue;
                memset(&dawn_descriptor_defaultqueue, 0, sizeof(struct WGPUQueueDescriptor));

                // end structure WGPUQueueDescriptor
                dawn_descriptor.defaultQueue = dawn_descriptor_defaultqueue;
                // end structure WGPUDeviceDescriptor
                cmd.descriptor = &dawn_descriptor;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kBindGroupLayoutSetLabel: {
                BindGroupLayoutSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(BindGroupLayoutSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::BindGroupLayout].Get(
                    command.bindgrouplayoutsetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUBindGroupLayout>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kBindGroupSetLabel: {
                BindGroupSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(BindGroupSetLabelCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::BindGroup].Get(command.bindgroupsetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUBindGroup>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kBufferDestroy: {
                BufferDestroyCmd cmd;
                memset(&cmd, 0, sizeof(BufferDestroyCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Buffer].Get(command.bufferdestroy().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUBuffer>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kBufferMapAsync: {
                BufferMapAsyncCmd cmd;
                memset(&cmd, 0, sizeof(BufferMapAsyncCmd));

                cmd.bufferId =
                    gObjectStores[ObjectType::Buffer].Get(command.buffermapasync().bufferid());
                cmd.requestSerial = command.buffermapasync().requestserial();

                for (int i = 0; i < command.buffermapasync().mode().size(); i++) {
                    cmd.mode |= static_cast<WGPUMapMode>(command.buffermapasync().mode(i));
                }
                cmd.offset = command.buffermapasync().offset();
                cmd.size = std::min(command.buffermapasync().size(),
                                    (uint64_t)std::pow(2, 20));  // HARDCODED
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kBufferSetLabel: {
                BufferSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(BufferSetLabelCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Buffer].Get(command.buffersetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUBuffer>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kBufferUnmap: {
                BufferUnmapCmd cmd;
                memset(&cmd, 0, sizeof(BufferUnmapCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Buffer].Get(command.bufferunmap().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUBuffer>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kBufferUpdateMappedData: {
                BufferUpdateMappedDataCmd cmd;
                memset(&cmd, 0, sizeof(BufferUpdateMappedDataCmd));

                cmd.bufferId = gObjectStores[ObjectType::Buffer].Get(
                    command.bufferupdatemappeddata().bufferid());
                cmd.offset = command.bufferupdatemappeddata().offset();
                cmd.size =
                    std::min(command.bufferupdatemappeddata().size(), (uint64_t)std::pow(2, 20));
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandBufferSetLabel: {
                CommandBufferSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(CommandBufferSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandBuffer].Get(
                    command.commandbuffersetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandBuffer>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderBeginComputePass: {
                CommandEncoderBeginComputePassCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderBeginComputePassCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderbegincomputepass().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                // start structure WGPUComputePassDescriptor
                WGPUComputePassDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUComputePassDescriptor));

                // start variable length WGPUComputePassTimestampWrite[]
                size_t dawn_descriptorN_timestampwrites_size =
                    command.commandencoderbegincomputepass().desc().timestampwrites().size();
                std::unique_ptr<WGPUComputePassTimestampWrite[]> dawn_descriptorN_timestampwrites(
                    new WGPUComputePassTimestampWrite[dawn_descriptorN_timestampwrites_size]);
                for (size_t i = 0; i < dawn_descriptorN_timestampwrites_size; i++) {
                    // start structure WGPUComputePassTimestampWrite
                    WGPUComputePassTimestampWrite dawn_descriptor_timestampwrites;
                    memset(&dawn_descriptor_timestampwrites, 0,
                           sizeof(struct WGPUComputePassTimestampWrite));

                    ObjectId dawn_descriptor_timestampwrites_queryset_id =
                        gObjectStores[ObjectType::QuerySet].Get(
                            command.commandencoderbegincomputepass()
                                .desc()
                                .timestampwrites(i)
                                .queryset());

                    if (dawn_descriptor_timestampwrites_queryset_id ==
                        static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    dawn_descriptor_timestampwrites.querySet =
                        reinterpret_cast<WGPUQuerySet>(dawn_descriptor_timestampwrites_queryset_id);
                    dawn_descriptor_timestampwrites.queryIndex =
                        command.commandencoderbegincomputepass()
                            .desc()
                            .timestampwrites(i)
                            .queryindex();
                    dawn_descriptor_timestampwrites.location =
                        static_cast<WGPUComputePassTimestampLocation>(
                            command.commandencoderbegincomputepass()
                                .desc()
                                .timestampwrites(i)
                                .location());
                    // end structure WGPUComputePassTimestampWrite

                    dawn_descriptorN_timestampwrites[i] = dawn_descriptor_timestampwrites;
                }

                dawn_descriptor.timestampWrites = dawn_descriptorN_timestampwrites.get();
                dawn_descriptor.timestampWriteCount =
                    command.commandencoderbegincomputepass().desc().timestampwrites().size();
                // end variablelength WGPUComputePassTimestampWrite[]
                // end structure WGPUComputePassDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::ComputePassEncoder].size() >
                    COMPUTE_PASS_ENCODER_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::ComputePassEncoder].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderBeginRenderPass: {
                CommandEncoderBeginRenderPassCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderBeginRenderPassCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderbeginrenderpass().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                // start structure WGPURenderPassDescriptor
                WGPURenderPassDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPURenderPassDescriptor));

                // start variable length WGPURenderPassColorAttachment[]
                size_t dawn_descriptorN_colorattachments_size =
                    command.commandencoderbeginrenderpass().desc().colorattachments().size();
                std::unique_ptr<WGPURenderPassColorAttachment[]> dawn_descriptorN_colorattachments(
                    new WGPURenderPassColorAttachment[dawn_descriptorN_colorattachments_size]);
                for (size_t i = 0; i < dawn_descriptorN_colorattachments_size; i++) {
                    // start structure WGPURenderPassColorAttachment
                    WGPURenderPassColorAttachment dawn_descriptor_colorattachments;
                    memset(&dawn_descriptor_colorattachments, 0,
                           sizeof(struct WGPURenderPassColorAttachment));

                    ObjectId dawn_descriptor_colorattachments_view_id =
                        gObjectStores[ObjectType::TextureView].Get(
                            command.commandencoderbeginrenderpass()
                                .desc()
                                .colorattachments(i)
                                .view());

                    if (dawn_descriptor_colorattachments_view_id ==
                        static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    dawn_descriptor_colorattachments.view =
                        reinterpret_cast<WGPUTextureView>(dawn_descriptor_colorattachments_view_id);
                    ObjectId dawn_descriptor_colorattachments_resolvetarget_id =
                        gObjectStores[ObjectType::TextureView].Get(
                            command.commandencoderbeginrenderpass()
                                .desc()
                                .colorattachments(i)
                                .resolvetarget());

                    if (dawn_descriptor_colorattachments_resolvetarget_id ==
                        static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    dawn_descriptor_colorattachments.resolveTarget =
                        reinterpret_cast<WGPUTextureView>(
                            dawn_descriptor_colorattachments_resolvetarget_id);
                    dawn_descriptor_colorattachments.loadOp =
                        static_cast<WGPULoadOp>(command.commandencoderbeginrenderpass()
                                                    .desc()
                                                    .colorattachments(i)
                                                    .loadop());
                    dawn_descriptor_colorattachments.storeOp =
                        static_cast<WGPUStoreOp>(command.commandencoderbeginrenderpass()
                                                     .desc()
                                                     .colorattachments(i)
                                                     .storeop());
                    // start structure WGPUColor
                    WGPUColor dawn_descriptor_colorattachments_clearcolor;
                    memset(&dawn_descriptor_colorattachments_clearcolor, 0,
                           sizeof(struct WGPUColor));

                    dawn_descriptor_colorattachments_clearcolor.r =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .colorattachments(i)
                            .clearcolor()
                            .r();
                    dawn_descriptor_colorattachments_clearcolor.g =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .colorattachments(i)
                            .clearcolor()
                            .g();
                    dawn_descriptor_colorattachments_clearcolor.b =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .colorattachments(i)
                            .clearcolor()
                            .b();
                    dawn_descriptor_colorattachments_clearcolor.a =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .colorattachments(i)
                            .clearcolor()
                            .a();
                    // end structure WGPUColor
                    dawn_descriptor_colorattachments.clearColor =
                        dawn_descriptor_colorattachments_clearcolor;
                    // start structure WGPUColor
                    WGPUColor dawn_descriptor_colorattachments_clearvalue;
                    memset(&dawn_descriptor_colorattachments_clearvalue, 0,
                           sizeof(struct WGPUColor));

                    dawn_descriptor_colorattachments_clearvalue.r =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .colorattachments(i)
                            .clearvalue()
                            .r();
                    dawn_descriptor_colorattachments_clearvalue.g =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .colorattachments(i)
                            .clearvalue()
                            .g();
                    dawn_descriptor_colorattachments_clearvalue.b =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .colorattachments(i)
                            .clearvalue()
                            .b();
                    dawn_descriptor_colorattachments_clearvalue.a =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .colorattachments(i)
                            .clearvalue()
                            .a();
                    // end structure WGPUColor
                    dawn_descriptor_colorattachments.clearValue =
                        dawn_descriptor_colorattachments_clearvalue;
                    // end structure WGPURenderPassColorAttachment

                    dawn_descriptorN_colorattachments[i] = dawn_descriptor_colorattachments;
                }

                dawn_descriptor.colorAttachments = dawn_descriptorN_colorattachments.get();
                dawn_descriptor.colorAttachmentCount =
                    command.commandencoderbeginrenderpass().desc().colorattachments().size();
                // end variablelength WGPURenderPassColorAttachment[]
                // start structure WGPURenderPassDepthStencilAttachment
                WGPURenderPassDepthStencilAttachment dawn_descriptor_depthstencilattachment;
                memset(&dawn_descriptor_depthstencilattachment, 0,
                       sizeof(struct WGPURenderPassDepthStencilAttachment));

                ObjectId dawn_descriptor_depthstencilattachment_view_id =
                    gObjectStores[ObjectType::TextureView].Get(
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .depthstencilattachment()
                            .view());

                if (dawn_descriptor_depthstencilattachment_view_id ==
                    static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor_depthstencilattachment.view = reinterpret_cast<WGPUTextureView>(
                    dawn_descriptor_depthstencilattachment_view_id);
                dawn_descriptor_depthstencilattachment.depthLoadOp =
                    static_cast<WGPULoadOp>(command.commandencoderbeginrenderpass()
                                                .desc()
                                                .depthstencilattachment()
                                                .depthloadop());
                dawn_descriptor_depthstencilattachment.depthStoreOp =
                    static_cast<WGPUStoreOp>(command.commandencoderbeginrenderpass()
                                                 .desc()
                                                 .depthstencilattachment()
                                                 .depthstoreop());
                dawn_descriptor_depthstencilattachment.clearDepth =
                    command.commandencoderbeginrenderpass()
                        .desc()
                        .depthstencilattachment()
                        .cleardepth();
                dawn_descriptor_depthstencilattachment.depthClearValue =
                    command.commandencoderbeginrenderpass()
                        .desc()
                        .depthstencilattachment()
                        .depthclearvalue();
                dawn_descriptor_depthstencilattachment.depthReadOnly =
                    command.commandencoderbeginrenderpass()
                        .desc()
                        .depthstencilattachment()
                        .depthreadonly();
                dawn_descriptor_depthstencilattachment.stencilLoadOp =
                    static_cast<WGPULoadOp>(command.commandencoderbeginrenderpass()
                                                .desc()
                                                .depthstencilattachment()
                                                .stencilloadop());
                dawn_descriptor_depthstencilattachment.stencilStoreOp =
                    static_cast<WGPUStoreOp>(command.commandencoderbeginrenderpass()
                                                 .desc()
                                                 .depthstencilattachment()
                                                 .stencilstoreop());
                dawn_descriptor_depthstencilattachment.clearStencil =
                    command.commandencoderbeginrenderpass()
                        .desc()
                        .depthstencilattachment()
                        .clearstencil();
                dawn_descriptor_depthstencilattachment.stencilClearValue =
                    command.commandencoderbeginrenderpass()
                        .desc()
                        .depthstencilattachment()
                        .stencilclearvalue();
                dawn_descriptor_depthstencilattachment.stencilReadOnly =
                    command.commandencoderbeginrenderpass()
                        .desc()
                        .depthstencilattachment()
                        .stencilreadonly();
                // end structure WGPURenderPassDepthStencilAttachment
                dawn_descriptor.depthStencilAttachment =
                    &dawn_descriptor_depthstencilattachment;  // HARDCODED
                ObjectId dawn_descriptor_occlusionqueryset_id =
                    gObjectStores[ObjectType::QuerySet].Get(
                        command.commandencoderbeginrenderpass().desc().occlusionqueryset());

                if (dawn_descriptor_occlusionqueryset_id ==
                    static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor.occlusionQuerySet =
                    reinterpret_cast<WGPUQuerySet>(dawn_descriptor_occlusionqueryset_id);
                // start variable length WGPURenderPassTimestampWrite[]
                size_t dawn_descriptorN_timestampwrites_size =
                    command.commandencoderbeginrenderpass().desc().timestampwrites().size();
                std::unique_ptr<WGPURenderPassTimestampWrite[]> dawn_descriptorN_timestampwrites(
                    new WGPURenderPassTimestampWrite[dawn_descriptorN_timestampwrites_size]);
                for (size_t i = 0; i < dawn_descriptorN_timestampwrites_size; i++) {
                    // start structure WGPURenderPassTimestampWrite
                    WGPURenderPassTimestampWrite dawn_descriptor_timestampwrites;
                    memset(&dawn_descriptor_timestampwrites, 0,
                           sizeof(struct WGPURenderPassTimestampWrite));

                    ObjectId dawn_descriptor_timestampwrites_queryset_id =
                        gObjectStores[ObjectType::QuerySet].Get(
                            command.commandencoderbeginrenderpass()
                                .desc()
                                .timestampwrites(i)
                                .queryset());

                    if (dawn_descriptor_timestampwrites_queryset_id ==
                        static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    dawn_descriptor_timestampwrites.querySet =
                        reinterpret_cast<WGPUQuerySet>(dawn_descriptor_timestampwrites_queryset_id);
                    dawn_descriptor_timestampwrites.queryIndex =
                        command.commandencoderbeginrenderpass()
                            .desc()
                            .timestampwrites(i)
                            .queryindex();
                    dawn_descriptor_timestampwrites.location =
                        static_cast<WGPURenderPassTimestampLocation>(
                            command.commandencoderbeginrenderpass()
                                .desc()
                                .timestampwrites(i)
                                .location());
                    // end structure WGPURenderPassTimestampWrite

                    dawn_descriptorN_timestampwrites[i] = dawn_descriptor_timestampwrites;
                }

                dawn_descriptor.timestampWrites = dawn_descriptorN_timestampwrites.get();
                dawn_descriptor.timestampWriteCount =
                    command.commandencoderbeginrenderpass().desc().timestampwrites().size();
                // end variablelength WGPURenderPassTimestampWrite[]
                // end structure WGPURenderPassDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::RenderPassEncoder].size() >
                    RENDER_PASS_ENCODER_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::RenderPassEncoder].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderClearBuffer: {
                CommandEncoderClearBufferCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderClearBufferCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderclearbuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                ObjectId cmd_buffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.commandencoderclearbuffer().buffer());

                if (cmd_buffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.buffer = reinterpret_cast<WGPUBuffer>(cmd_buffer_id);
                cmd.offset = command.commandencoderclearbuffer().offset();
                cmd.size = command.commandencoderclearbuffer().size();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderCopyBufferToBuffer: {
                CommandEncoderCopyBufferToBufferCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderCopyBufferToBufferCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencodercopybuffertobuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                ObjectId cmd_source_id = gObjectStores[ObjectType::Buffer].Get(
                    command.commandencodercopybuffertobuffer().source());

                if (cmd_source_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.source = reinterpret_cast<WGPUBuffer>(cmd_source_id);
                cmd.sourceOffset = command.commandencodercopybuffertobuffer().sourceoffset();
                ObjectId cmd_destination_id = gObjectStores[ObjectType::Buffer].Get(
                    command.commandencodercopybuffertobuffer().destination());

                if (cmd_destination_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.destination = reinterpret_cast<WGPUBuffer>(cmd_destination_id);
                cmd.destinationOffset =
                    command.commandencodercopybuffertobuffer().destinationoffset();
                cmd.size = command.commandencodercopybuffertobuffer().size();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderCopyBufferToTexture: {
                CommandEncoderCopyBufferToTextureCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderCopyBufferToTextureCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencodercopybuffertotexture().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                // start structure WGPUImageCopyBuffer
                WGPUImageCopyBuffer dawn_source;
                memset(&dawn_source, 0, sizeof(struct WGPUImageCopyBuffer));

                // start structure WGPUTextureDataLayout
                WGPUTextureDataLayout dawn_source_layout;
                memset(&dawn_source_layout, 0, sizeof(struct WGPUTextureDataLayout));

                dawn_source_layout.offset =
                    command.commandencodercopybuffertotexture().source().layout().offset();
                dawn_source_layout.bytesPerRow =
                    command.commandencodercopybuffertotexture().source().layout().bytesperrow();
                dawn_source_layout.rowsPerImage =
                    command.commandencodercopybuffertotexture().source().layout().rowsperimage();
                // end structure WGPUTextureDataLayout
                dawn_source.layout = dawn_source_layout;
                ObjectId dawn_source_buffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.commandencodercopybuffertotexture().source().buffer());

                if (dawn_source_buffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_source.buffer = reinterpret_cast<WGPUBuffer>(dawn_source_buffer_id);
                // end structure WGPUImageCopyBuffer
                cmd.source = &dawn_source;
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_destination;
                memset(&dawn_destination, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_destination_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.commandencodercopybuffertotexture().destination().texture());

                if (dawn_destination_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_destination.texture =
                    reinterpret_cast<WGPUTexture>(dawn_destination_texture_id);
                dawn_destination.mipLevel =
                    command.commandencodercopybuffertotexture().destination().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_destination_origin;
                memset(&dawn_destination_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_destination_origin.x =
                    command.commandencodercopybuffertotexture().destination().origin().x();
                dawn_destination_origin.y =
                    command.commandencodercopybuffertotexture().destination().origin().y();
                dawn_destination_origin.z =
                    command.commandencodercopybuffertotexture().destination().origin().z();
                // end structure WGPUOrigin3D
                dawn_destination.origin = dawn_destination_origin;
                dawn_destination.aspect = static_cast<WGPUTextureAspect>(
                    command.commandencodercopybuffertotexture().destination().aspect());
                // end structure WGPUImageCopyTexture
                cmd.destination = &dawn_destination;
                // start structure WGPUExtent3D
                WGPUExtent3D dawn_copysize;
                memset(&dawn_copysize, 0, sizeof(struct WGPUExtent3D));

                dawn_copysize.width =
                    command.commandencodercopybuffertotexture().copysize().width();
                dawn_copysize.height =
                    command.commandencodercopybuffertotexture().copysize().height();
                dawn_copysize.depthOrArrayLayers =
                    command.commandencodercopybuffertotexture().copysize().depthorarraylayers();
                // end structure WGPUExtent3D
                cmd.copySize = &dawn_copysize;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderCopyTextureToBuffer: {
                CommandEncoderCopyTextureToBufferCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderCopyTextureToBufferCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencodercopytexturetobuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_source;
                memset(&dawn_source, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_source_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.commandencodercopytexturetobuffer().source().texture());

                if (dawn_source_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_source.texture = reinterpret_cast<WGPUTexture>(dawn_source_texture_id);
                dawn_source.mipLevel =
                    command.commandencodercopytexturetobuffer().source().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_source_origin;
                memset(&dawn_source_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_source_origin.x =
                    command.commandencodercopytexturetobuffer().source().origin().x();
                dawn_source_origin.y =
                    command.commandencodercopytexturetobuffer().source().origin().y();
                dawn_source_origin.z =
                    command.commandencodercopytexturetobuffer().source().origin().z();
                // end structure WGPUOrigin3D
                dawn_source.origin = dawn_source_origin;
                dawn_source.aspect = static_cast<WGPUTextureAspect>(
                    command.commandencodercopytexturetobuffer().source().aspect());
                // end structure WGPUImageCopyTexture
                cmd.source = &dawn_source;
                // start structure WGPUImageCopyBuffer
                WGPUImageCopyBuffer dawn_destination;
                memset(&dawn_destination, 0, sizeof(struct WGPUImageCopyBuffer));

                // start structure WGPUTextureDataLayout
                WGPUTextureDataLayout dawn_destination_layout;
                memset(&dawn_destination_layout, 0, sizeof(struct WGPUTextureDataLayout));

                dawn_destination_layout.offset =
                    command.commandencodercopytexturetobuffer().destination().layout().offset();
                dawn_destination_layout.bytesPerRow = command.commandencodercopytexturetobuffer()
                                                          .destination()
                                                          .layout()
                                                          .bytesperrow();
                dawn_destination_layout.rowsPerImage = command.commandencodercopytexturetobuffer()
                                                           .destination()
                                                           .layout()
                                                           .rowsperimage();
                // end structure WGPUTextureDataLayout
                dawn_destination.layout = dawn_destination_layout;
                ObjectId dawn_destination_buffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.commandencodercopytexturetobuffer().destination().buffer());

                if (dawn_destination_buffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_destination.buffer = reinterpret_cast<WGPUBuffer>(dawn_destination_buffer_id);
                // end structure WGPUImageCopyBuffer
                cmd.destination = &dawn_destination;
                // start structure WGPUExtent3D
                WGPUExtent3D dawn_copysize;
                memset(&dawn_copysize, 0, sizeof(struct WGPUExtent3D));

                dawn_copysize.width =
                    command.commandencodercopytexturetobuffer().copysize().width();
                dawn_copysize.height =
                    command.commandencodercopytexturetobuffer().copysize().height();
                dawn_copysize.depthOrArrayLayers =
                    command.commandencodercopytexturetobuffer().copysize().depthorarraylayers();
                // end structure WGPUExtent3D
                cmd.copySize = &dawn_copysize;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderCopyTextureToTexture: {
                CommandEncoderCopyTextureToTextureCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderCopyTextureToTextureCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencodercopytexturetotexture().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_source;
                memset(&dawn_source, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_source_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.commandencodercopytexturetotexture().source().texture());

                if (dawn_source_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_source.texture = reinterpret_cast<WGPUTexture>(dawn_source_texture_id);
                dawn_source.mipLevel =
                    command.commandencodercopytexturetotexture().source().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_source_origin;
                memset(&dawn_source_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_source_origin.x =
                    command.commandencodercopytexturetotexture().source().origin().x();
                dawn_source_origin.y =
                    command.commandencodercopytexturetotexture().source().origin().y();
                dawn_source_origin.z =
                    command.commandencodercopytexturetotexture().source().origin().z();
                // end structure WGPUOrigin3D
                dawn_source.origin = dawn_source_origin;
                dawn_source.aspect = static_cast<WGPUTextureAspect>(
                    command.commandencodercopytexturetotexture().source().aspect());
                // end structure WGPUImageCopyTexture
                cmd.source = &dawn_source;
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_destination;
                memset(&dawn_destination, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_destination_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.commandencodercopytexturetotexture().destination().texture());

                if (dawn_destination_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_destination.texture =
                    reinterpret_cast<WGPUTexture>(dawn_destination_texture_id);
                dawn_destination.mipLevel =
                    command.commandencodercopytexturetotexture().destination().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_destination_origin;
                memset(&dawn_destination_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_destination_origin.x =
                    command.commandencodercopytexturetotexture().destination().origin().x();
                dawn_destination_origin.y =
                    command.commandencodercopytexturetotexture().destination().origin().y();
                dawn_destination_origin.z =
                    command.commandencodercopytexturetotexture().destination().origin().z();
                // end structure WGPUOrigin3D
                dawn_destination.origin = dawn_destination_origin;
                dawn_destination.aspect = static_cast<WGPUTextureAspect>(
                    command.commandencodercopytexturetotexture().destination().aspect());
                // end structure WGPUImageCopyTexture
                cmd.destination = &dawn_destination;
                // start structure WGPUExtent3D
                WGPUExtent3D dawn_copysize;
                memset(&dawn_copysize, 0, sizeof(struct WGPUExtent3D));

                dawn_copysize.width =
                    command.commandencodercopytexturetotexture().copysize().width();
                dawn_copysize.height =
                    command.commandencodercopytexturetotexture().copysize().height();
                dawn_copysize.depthOrArrayLayers =
                    command.commandencodercopytexturetotexture().copysize().depthorarraylayers();
                // end structure WGPUExtent3D
                cmd.copySize = &dawn_copysize;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderCopyTextureToTextureInternal: {
                CommandEncoderCopyTextureToTextureInternalCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderCopyTextureToTextureInternalCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencodercopytexturetotextureinternal().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_source;
                memset(&dawn_source, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_source_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.commandencodercopytexturetotextureinternal().source().texture());

                if (dawn_source_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_source.texture = reinterpret_cast<WGPUTexture>(dawn_source_texture_id);
                dawn_source.mipLevel =
                    command.commandencodercopytexturetotextureinternal().source().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_source_origin;
                memset(&dawn_source_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_source_origin.x =
                    command.commandencodercopytexturetotextureinternal().source().origin().x();
                dawn_source_origin.y =
                    command.commandencodercopytexturetotextureinternal().source().origin().y();
                dawn_source_origin.z =
                    command.commandencodercopytexturetotextureinternal().source().origin().z();
                // end structure WGPUOrigin3D
                dawn_source.origin = dawn_source_origin;
                dawn_source.aspect = static_cast<WGPUTextureAspect>(
                    command.commandencodercopytexturetotextureinternal().source().aspect());
                // end structure WGPUImageCopyTexture
                cmd.source = &dawn_source;
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_destination;
                memset(&dawn_destination, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_destination_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.commandencodercopytexturetotextureinternal().destination().texture());

                if (dawn_destination_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_destination.texture =
                    reinterpret_cast<WGPUTexture>(dawn_destination_texture_id);
                dawn_destination.mipLevel =
                    command.commandencodercopytexturetotextureinternal().destination().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_destination_origin;
                memset(&dawn_destination_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_destination_origin.x =
                    command.commandencodercopytexturetotextureinternal().destination().origin().x();
                dawn_destination_origin.y =
                    command.commandencodercopytexturetotextureinternal().destination().origin().y();
                dawn_destination_origin.z =
                    command.commandencodercopytexturetotextureinternal().destination().origin().z();
                // end structure WGPUOrigin3D
                dawn_destination.origin = dawn_destination_origin;
                dawn_destination.aspect = static_cast<WGPUTextureAspect>(
                    command.commandencodercopytexturetotextureinternal().destination().aspect());
                // end structure WGPUImageCopyTexture
                cmd.destination = &dawn_destination;
                // start structure WGPUExtent3D
                WGPUExtent3D dawn_copysize;
                memset(&dawn_copysize, 0, sizeof(struct WGPUExtent3D));

                dawn_copysize.width =
                    command.commandencodercopytexturetotextureinternal().copysize().width();
                dawn_copysize.height =
                    command.commandencodercopytexturetotextureinternal().copysize().height();
                dawn_copysize.depthOrArrayLayers =
                    command.commandencodercopytexturetotextureinternal()
                        .copysize()
                        .depthorarraylayers();
                // end structure WGPUExtent3D
                cmd.copySize = &dawn_copysize;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderFinish: {
                CommandEncoderFinishCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderFinishCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderfinish().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                // start structure WGPUCommandBufferDescriptor
                WGPUCommandBufferDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUCommandBufferDescriptor));

                // end structure WGPUCommandBufferDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::CommandBuffer].size() > RENDER_BUNDLE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::CommandBuffer].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderInjectValidationError: {
                CommandEncoderInjectValidationErrorCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderInjectValidationErrorCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderinjectvalidationerror().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                cmd.message = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderInsertDebugMarker: {
                CommandEncoderInsertDebugMarkerCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderInsertDebugMarkerCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderinsertdebugmarker().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                cmd.markerLabel = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderPopDebugGroup: {
                CommandEncoderPopDebugGroupCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderPopDebugGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderpopdebuggroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderPushDebugGroup: {
                CommandEncoderPushDebugGroupCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderPushDebugGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderpushdebuggroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                cmd.groupLabel = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderResolveQuerySet: {
                CommandEncoderResolveQuerySetCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderResolveQuerySetCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderresolvequeryset().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                ObjectId cmd_queryset_id = gObjectStores[ObjectType::QuerySet].Get(
                    command.commandencoderresolvequeryset().queryset());

                if (cmd_queryset_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.querySet = reinterpret_cast<WGPUQuerySet>(cmd_queryset_id);
                cmd.firstQuery = command.commandencoderresolvequeryset().firstquery();
                cmd.queryCount = command.commandencoderresolvequeryset().querycount();
                ObjectId cmd_destination_id = gObjectStores[ObjectType::Buffer].Get(
                    command.commandencoderresolvequeryset().destination());

                if (cmd_destination_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.destination = reinterpret_cast<WGPUBuffer>(cmd_destination_id);
                cmd.destinationOffset = command.commandencoderresolvequeryset().destinationoffset();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderSetLabel: {
                CommandEncoderSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencodersetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderWriteBuffer: {
                CommandEncoderWriteBufferCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderWriteBufferCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderwritebuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                ObjectId cmd_buffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.commandencoderwritebuffer().buffer());

                if (cmd_buffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.buffer = reinterpret_cast<WGPUBuffer>(cmd_buffer_id);
                cmd.bufferOffset = command.commandencoderwritebuffer().bufferoffset();
                // start variable length uint8_t[]
                size_t cmdN_data_size = command.commandencoderwritebuffer().data().size();
                std::unique_ptr<uint8_t[]> cmdN_data(new uint8_t[cmdN_data_size]);
                for (size_t i = 0; i < cmdN_data_size; i++) {
                    cmdN_data[i] = static_cast<uint8_t>(
                        command.commandencoderwritebuffer().data()[i]);  // HARDCODED
                }

                cmd.data = cmdN_data.get();
                cmd.size = command.commandencoderwritebuffer().data().size();
                // end variablelength uint8_t[]
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kCommandEncoderWriteTimestamp: {
                CommandEncoderWriteTimestampCmd cmd;
                memset(&cmd, 0, sizeof(CommandEncoderWriteTimestampCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::CommandEncoder].Get(
                    command.commandencoderwritetimestamp().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUCommandEncoder>(cmd_self_id);
                ObjectId cmd_queryset_id = gObjectStores[ObjectType::QuerySet].Get(
                    command.commandencoderwritetimestamp().queryset());

                if (cmd_queryset_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.querySet = reinterpret_cast<WGPUQuerySet>(cmd_queryset_id);
                cmd.queryIndex = command.commandencoderwritetimestamp().queryindex();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderDispatch: {
                ComputePassEncoderDispatchCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderDispatchCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderdispatch().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                cmd.workgroupCountX = command.computepassencoderdispatch().workgroupcountx();
                cmd.workgroupCountY = command.computepassencoderdispatch().workgroupcounty();
                cmd.workgroupCountZ = command.computepassencoderdispatch().workgroupcountz();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderDispatchIndirect: {
                ComputePassEncoderDispatchIndirectCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderDispatchIndirectCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderdispatchindirect().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                ObjectId cmd_indirectbuffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.computepassencoderdispatchindirect().indirectbuffer());

                if (cmd_indirectbuffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.indirectBuffer = reinterpret_cast<WGPUBuffer>(cmd_indirectbuffer_id);
                cmd.indirectOffset = command.computepassencoderdispatchindirect().indirectoffset();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderDispatchWorkgroups: {
                ComputePassEncoderDispatchWorkgroupsCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderDispatchWorkgroupsCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderdispatchworkgroups().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                cmd.workgroupCountX =
                    command.computepassencoderdispatchworkgroups().workgroupcountx();
                cmd.workgroupCountY =
                    command.computepassencoderdispatchworkgroups().workgroupcounty();
                cmd.workgroupCountZ =
                    command.computepassencoderdispatchworkgroups().workgroupcountz();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderDispatchWorkgroupsIndirect: {
                ComputePassEncoderDispatchWorkgroupsIndirectCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderDispatchWorkgroupsIndirectCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderdispatchworkgroupsindirect().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                ObjectId cmd_indirectbuffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.computepassencoderdispatchworkgroupsindirect().indirectbuffer());

                if (cmd_indirectbuffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.indirectBuffer = reinterpret_cast<WGPUBuffer>(cmd_indirectbuffer_id);
                cmd.indirectOffset =
                    command.computepassencoderdispatchworkgroupsindirect().indirectoffset();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderEnd: {
                ComputePassEncoderEndCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderEndCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderend().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderEndPass: {
                ComputePassEncoderEndPassCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderEndPassCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderendpass().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderInsertDebugMarker: {
                ComputePassEncoderInsertDebugMarkerCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderInsertDebugMarkerCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderinsertdebugmarker().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                cmd.markerLabel = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderPopDebugGroup: {
                ComputePassEncoderPopDebugGroupCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderPopDebugGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderpopdebuggroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderPushDebugGroup: {
                ComputePassEncoderPushDebugGroupCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderPushDebugGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderpushdebuggroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                cmd.groupLabel = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderSetBindGroup: {
                ComputePassEncoderSetBindGroupCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderSetBindGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencodersetbindgroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                cmd.groupIndex = command.computepassencodersetbindgroup().groupindex();
                ObjectId cmd_group_id = gObjectStores[ObjectType::BindGroup].Get(
                    command.computepassencodersetbindgroup().group());

                if (cmd_group_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.group = reinterpret_cast<WGPUBindGroup>(cmd_group_id);
                // start variable length uint32_t[]
                size_t cmdN_dynamicoffsets_size =
                    command.computepassencodersetbindgroup().dynamicoffsets().size();
                std::unique_ptr<uint32_t[]> cmdN_dynamicoffsets(
                    new uint32_t[cmdN_dynamicoffsets_size]);
                for (size_t i = 0; i < cmdN_dynamicoffsets_size; i++) {
                    cmdN_dynamicoffsets[i] = static_cast<uint32_t>(
                        command.computepassencodersetbindgroup().dynamicoffsets()[i]);
                }

                cmd.dynamicOffsets = cmdN_dynamicoffsets.get();
                cmd.dynamicOffsetCount =
                    command.computepassencodersetbindgroup().dynamicoffsets().size();
                // end variablelength uint32_t[]
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderSetLabel: {
                ComputePassEncoderSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencodersetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderSetPipeline: {
                ComputePassEncoderSetPipelineCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderSetPipelineCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencodersetpipeline().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                ObjectId cmd_pipeline_id = gObjectStores[ObjectType::ComputePipeline].Get(
                    command.computepassencodersetpipeline().pipeline());

                if (cmd_pipeline_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.pipeline = reinterpret_cast<WGPUComputePipeline>(cmd_pipeline_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePassEncoderWriteTimestamp: {
                ComputePassEncoderWriteTimestampCmd cmd;
                memset(&cmd, 0, sizeof(ComputePassEncoderWriteTimestampCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePassEncoder].Get(
                    command.computepassencoderwritetimestamp().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePassEncoder>(cmd_self_id);
                ObjectId cmd_queryset_id = gObjectStores[ObjectType::QuerySet].Get(
                    command.computepassencoderwritetimestamp().queryset());

                if (cmd_queryset_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.querySet = reinterpret_cast<WGPUQuerySet>(cmd_queryset_id);
                cmd.queryIndex = command.computepassencoderwritetimestamp().queryindex();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePipelineGetBindGroupLayout: {
                ComputePipelineGetBindGroupLayoutCmd cmd;
                memset(&cmd, 0, sizeof(ComputePipelineGetBindGroupLayoutCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePipeline].Get(
                    command.computepipelinegetbindgrouplayout().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePipeline>(cmd_self_id);
                cmd.groupIndex = command.computepipelinegetbindgrouplayout().groupindex();
                if (gObjectStores[ObjectType::BindGroupLayout].size() > BIND_GROUP_LAYOUT_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::BindGroupLayout].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kComputePipelineSetLabel: {
                ComputePipelineSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(ComputePipelineSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ComputePipeline].Get(
                    command.computepipelinesetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUComputePipeline>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDestroyObject: {
                DestroyObjectCmd cmd;
                memset(&cmd, 0, sizeof(DestroyObjectCmd));

                cmd.objectType =
                    static_cast<ObjectType>(command.destroyobject().objecttype());  // HARDCODED
                cmd.objectId = gObjectStores[static_cast<ObjectType>(cmd.objectType)].Get(
                    command.destroyobject().objectid());

                gObjectStores[cmd.objectType].Free(cmd.objectId);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateBindGroup: {
                DeviceCreateBindGroupCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateBindGroupCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicecreatebindgroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUBindGroupDescriptor
                WGPUBindGroupDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUBindGroupDescriptor));

                ObjectId dawn_descriptor_layout_id = gObjectStores[ObjectType::BindGroupLayout].Get(
                    command.devicecreatebindgroup().desc().layout());

                if (dawn_descriptor_layout_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor.layout =
                    reinterpret_cast<WGPUBindGroupLayout>(dawn_descriptor_layout_id);
                // start variable length WGPUBindGroupEntry[]
                size_t dawn_descriptorN_entries_size =
                    command.devicecreatebindgroup().desc().entries().size();
                std::unique_ptr<WGPUBindGroupEntry[]> dawn_descriptorN_entries(
                    new WGPUBindGroupEntry[dawn_descriptorN_entries_size]);
                for (size_t i = 0; i < dawn_descriptorN_entries_size; i++) {
                    // start structure WGPUBindGroupEntry
                    WGPUBindGroupEntry dawn_descriptor_entries;
                    memset(&dawn_descriptor_entries, 0, sizeof(struct WGPUBindGroupEntry));

                    dawn_descriptor_entries.binding =
                        command.devicecreatebindgroup().desc().entries(i).binding();
                    ObjectId dawn_descriptor_entries_buffer_id =
                        gObjectStores[ObjectType::Buffer].Get(
                            command.devicecreatebindgroup().desc().entries(i).buffer());

                    if (dawn_descriptor_entries_buffer_id ==
                        static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    dawn_descriptor_entries.buffer =
                        reinterpret_cast<WGPUBuffer>(dawn_descriptor_entries_buffer_id);
                    dawn_descriptor_entries.offset =
                        command.devicecreatebindgroup().desc().entries(i).offset();
                    dawn_descriptor_entries.size =
                        command.devicecreatebindgroup().desc().entries(i).size();
                    ObjectId dawn_descriptor_entries_sampler_id =
                        gObjectStores[ObjectType::Sampler].Get(
                            command.devicecreatebindgroup().desc().entries(i).sampler());

                    if (dawn_descriptor_entries_sampler_id ==
                        static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    dawn_descriptor_entries.sampler =
                        reinterpret_cast<WGPUSampler>(dawn_descriptor_entries_sampler_id);
                    ObjectId dawn_descriptor_entries_textureview_id =
                        gObjectStores[ObjectType::TextureView].Get(
                            command.devicecreatebindgroup().desc().entries(i).textureview());

                    if (dawn_descriptor_entries_textureview_id ==
                        static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    dawn_descriptor_entries.textureView =
                        reinterpret_cast<WGPUTextureView>(dawn_descriptor_entries_textureview_id);
                    // end structure WGPUBindGroupEntry

                    dawn_descriptorN_entries[i] = dawn_descriptor_entries;
                }

                dawn_descriptor.entries = dawn_descriptorN_entries.get();
                dawn_descriptor.entryCount =
                    command.devicecreatebindgroup().desc().entries().size();
                // end variablelength WGPUBindGroupEntry[]
                // end structure WGPUBindGroupDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::BindGroup].size() > BIND_GROUP_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::BindGroup].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateBindGroupLayout: {
                DeviceCreateBindGroupLayoutCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateBindGroupLayoutCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreatebindgrouplayout().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUBindGroupLayoutDescriptor
                WGPUBindGroupLayoutDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUBindGroupLayoutDescriptor));

                // start variable length WGPUBindGroupLayoutEntry[]
                size_t dawn_descriptorN_entries_size =
                    command.devicecreatebindgrouplayout().desc().entries().size();
                std::unique_ptr<WGPUBindGroupLayoutEntry[]> dawn_descriptorN_entries(
                    new WGPUBindGroupLayoutEntry[dawn_descriptorN_entries_size]);
                for (size_t i = 0; i < dawn_descriptorN_entries_size; i++) {
                    // start structure WGPUBindGroupLayoutEntry
                    WGPUBindGroupLayoutEntry dawn_descriptor_entries;
                    memset(&dawn_descriptor_entries, 0, sizeof(struct WGPUBindGroupLayoutEntry));

                    dawn_descriptor_entries.binding =
                        command.devicecreatebindgrouplayout().desc().entries(i).binding();

                    int bitmask_upper =
                        command.devicecreatebindgrouplayout().desc().entries(i).visibility().size();
                    for (int j = 0; j < bitmask_upper; j++) {
                        dawn_descriptor_entries.visibility |= static_cast<WGPUShaderStage>(
                            command.devicecreatebindgrouplayout().desc().entries(i).visibility(j));
                    }

                    if (command.devicecreatebindgrouplayout().desc().entries(i).has_buffer()) {
                        // start structure WGPUBufferBindingLayout
                        WGPUBufferBindingLayout dawn_descriptor_entries_buffer;
                        memset(&dawn_descriptor_entries_buffer, 0,
                               sizeof(struct WGPUBufferBindingLayout));

                        dawn_descriptor_entries_buffer.type =
                            static_cast<WGPUBufferBindingType>(command.devicecreatebindgrouplayout()
                                                                   .desc()
                                                                   .entries(i)
                                                                   .buffer()
                                                                   .type());
                        dawn_descriptor_entries_buffer.hasDynamicOffset =
                            command.devicecreatebindgrouplayout()
                                .desc()
                                .entries(i)
                                .buffer()
                                .hasdynamicoffset();
                        dawn_descriptor_entries_buffer.minBindingSize =
                            command.devicecreatebindgrouplayout()
                                .desc()
                                .entries(i)
                                .buffer()
                                .minbindingsize();
                        // end structure WGPUBufferBindingLayout
                        dawn_descriptor_entries.buffer = dawn_descriptor_entries_buffer;
                    } else if (command.devicecreatebindgrouplayout()
                                   .desc()
                                   .entries(i)
                                   .has_sampler()) {
                        // start structure WGPUSamplerBindingLayout
                        WGPUSamplerBindingLayout dawn_descriptor_entries_sampler;
                        memset(&dawn_descriptor_entries_sampler, 0,
                               sizeof(struct WGPUSamplerBindingLayout));

                        dawn_descriptor_entries_sampler.type = static_cast<WGPUSamplerBindingType>(
                            command.devicecreatebindgrouplayout()
                                .desc()
                                .entries(i)
                                .sampler()
                                .type());
                        // end structure WGPUSamplerBindingLayout
                        dawn_descriptor_entries.sampler = dawn_descriptor_entries_sampler;
                    } else if (command.devicecreatebindgrouplayout()
                                   .desc()
                                   .entries(i)
                                   .has_texture()) {
                        // start structure WGPUTextureBindingLayout
                        WGPUTextureBindingLayout dawn_descriptor_entries_texture;
                        memset(&dawn_descriptor_entries_texture, 0,
                               sizeof(struct WGPUTextureBindingLayout));

                        dawn_descriptor_entries_texture.sampleType =
                            static_cast<WGPUTextureSampleType>(command.devicecreatebindgrouplayout()
                                                                   .desc()
                                                                   .entries(i)
                                                                   .texture()
                                                                   .sampletype());
                        dawn_descriptor_entries_texture.viewDimension =
                            static_cast<WGPUTextureViewDimension>(
                                command.devicecreatebindgrouplayout()
                                    .desc()
                                    .entries(i)
                                    .texture()
                                    .viewdimension());
                        dawn_descriptor_entries_texture.multisampled =
                            command.devicecreatebindgrouplayout()
                                .desc()
                                .entries(i)
                                .texture()
                                .multisampled();
                        // end structure WGPUTextureBindingLayout
                        dawn_descriptor_entries.texture = dawn_descriptor_entries_texture;
                    } else if (command.devicecreatebindgrouplayout()
                                   .desc()
                                   .entries(i)
                                   .has_storagetexture()) {
                        WGPUStorageTextureBindingLayout dawn_descriptor_entries_storagetexture;
                        memset(&dawn_descriptor_entries_storagetexture, 0,
                               sizeof(struct WGPUStorageTextureBindingLayout));

                        dawn_descriptor_entries_storagetexture.access =
                            static_cast<WGPUStorageTextureAccess>(
                                command.devicecreatebindgrouplayout()
                                    .desc()
                                    .entries(i)
                                    .storagetexture()
                                    .access());
                        dawn_descriptor_entries_storagetexture.format =
                            static_cast<WGPUTextureFormat>(command.devicecreatebindgrouplayout()
                                                               .desc()
                                                               .entries(i)
                                                               .storagetexture()
                                                               .format());
                        dawn_descriptor_entries_storagetexture.viewDimension =
                            static_cast<WGPUTextureViewDimension>(
                                command.devicecreatebindgrouplayout()
                                    .desc()
                                    .entries(i)
                                    .storagetexture()
                                    .viewdimension());
                        // end structure WGPUStorageTextureBindingLayout
                        dawn_descriptor_entries.storageTexture =
                            dawn_descriptor_entries_storagetexture;
                        // end structure WGPUBindGroupLayoutEntry
                    }
                    dawn_descriptorN_entries[i] = dawn_descriptor_entries;
                }

                dawn_descriptor.entries = dawn_descriptorN_entries.get();
                dawn_descriptor.entryCount =
                    command.devicecreatebindgrouplayout().desc().entries().size();
                // end variablelength WGPUBindGroupLayoutEntry[]
                // end structure WGPUBindGroupLayoutDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::BindGroupLayout].size() > BIND_GROUP_LAYOUT_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::BindGroupLayout].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateBuffer: {
                DeviceCreateBufferCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateBufferCmd));

                cmd.deviceId =
                    gObjectStores[ObjectType::Device].Get(command.devicecreatebuffer().deviceid());
                // start structure WGPUBufferDescriptor
                WGPUBufferDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUBufferDescriptor));

                for (int i = 0; i < command.devicecreatebuffer().desc().usage().size(); i++) {
                    dawn_descriptor.usage |= command.devicecreatebuffer().desc().usage(i);
                }
                dawn_descriptor.size =
                    std::min(command.devicecreatebuffer().desc().size(), (uint64_t)std::pow(2, 20));
                dawn_descriptor.mappedAtCreation =
                    command.devicecreatebuffer().desc().mappedatcreation();
                // end structure WGPUBufferDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::Buffer].size() > BUFFER_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::Buffer].ReserveHandle();
                // end variablelength uint8_t[]
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateCommandEncoder: {
                DeviceCreateCommandEncoderCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateCommandEncoderCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreatecommandencoder().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUCommandEncoderDescriptor
                WGPUCommandEncoderDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUCommandEncoderDescriptor));

                // end structure WGPUCommandEncoderDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::CommandEncoder].size() > COMMAND_ENCODER_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::CommandEncoder].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateComputePipeline: {
                DeviceCreateComputePipelineCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateComputePipelineCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreatecomputepipeline().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUComputePipelineDescriptor
                WGPUComputePipelineDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUComputePipelineDescriptor));

                ObjectId dawn_descriptor_layout_id = gObjectStores[ObjectType::PipelineLayout].Get(
                    command.devicecreatecomputepipeline().desc().layout());

                if (dawn_descriptor_layout_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor.layout =
                    reinterpret_cast<WGPUPipelineLayout>(dawn_descriptor_layout_id);
                // start structure WGPUProgrammableStageDescriptor
                WGPUProgrammableStageDescriptor dawn_descriptor_compute;
                memset(&dawn_descriptor_compute, 0, sizeof(struct WGPUProgrammableStageDescriptor));

                ObjectId dawn_descriptor_compute_module_id =
                    gObjectStores[ObjectType::ShaderModule].Get(
                        command.devicecreatecomputepipeline().desc().compute().module());

                if (dawn_descriptor_compute_module_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor_compute.module =
                    reinterpret_cast<WGPUShaderModule>(dawn_descriptor_compute_module_id);
                dawn_descriptor_compute.entryPoint = "main";
                // start variable length WGPUConstantEntry[]
                size_t dawn_descriptor_computeN_constants_size =
                    command.devicecreatecomputepipeline().desc().compute().constants().size();
                std::unique_ptr<WGPUConstantEntry[]> dawn_descriptor_computeN_constants(
                    new WGPUConstantEntry[dawn_descriptor_computeN_constants_size]);
                for (size_t i = 0; i < dawn_descriptor_computeN_constants_size; i++) {
                    // start structure WGPUConstantEntry
                    WGPUConstantEntry dawn_descriptor_compute_constants;
                    memset(&dawn_descriptor_compute_constants, 0, sizeof(struct WGPUConstantEntry));

                    dawn_descriptor_compute_constants.key = "main";
                    dawn_descriptor_compute_constants.value =
                        command.devicecreatecomputepipeline().desc().compute().constants(i).value();
                    // end structure WGPUConstantEntry

                    dawn_descriptor_computeN_constants[i] = dawn_descriptor_compute_constants;
                }

                dawn_descriptor_compute.constants = dawn_descriptor_computeN_constants.get();
                dawn_descriptor_compute.constantCount =
                    command.devicecreatecomputepipeline().desc().compute().constants().size();
                // end variablelength WGPUConstantEntry[]
                // end structure WGPUProgrammableStageDescriptor
                dawn_descriptor.compute = dawn_descriptor_compute;
                // end structure WGPUComputePipelineDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::ComputePipeline].size() > COMPUTE_PIPELINE_LIMIT) {
                    break;
                }

                cmd.result = gObjectStores[ObjectType::ComputePipeline].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateComputePipelineAsync: {
                DeviceCreateComputePipelineAsyncCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateComputePipelineAsyncCmd));
                cmd.deviceId = gObjectStores[ObjectType::Device].Get(
                    command.devicecreatecomputepipelineasync().deviceid());
                cmd.requestSerial = command.devicecreatecomputepipelineasync().requestserial();
                if (gObjectStores[ObjectType::ComputePipeline].size() > COMPUTE_PIPELINE_LIMIT) {
                    break;
                }
                cmd.pipelineObjectHandle =
                    gObjectStores[ObjectType::ComputePipeline].ReserveHandle();
                // start structure WGPUComputePipelineDescriptor
                WGPUComputePipelineDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUComputePipelineDescriptor));

                ObjectId dawn_descriptor_layout_id = gObjectStores[ObjectType::PipelineLayout].Get(
                    command.devicecreatecomputepipelineasync().desc().layout());

                if (dawn_descriptor_layout_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor.layout =
                    reinterpret_cast<WGPUPipelineLayout>(dawn_descriptor_layout_id);
                // start structure WGPUProgrammableStageDescriptor
                WGPUProgrammableStageDescriptor dawn_descriptor_compute;
                memset(&dawn_descriptor_compute, 0, sizeof(struct WGPUProgrammableStageDescriptor));

                ObjectId dawn_descriptor_compute_module_id =
                    gObjectStores[ObjectType::ShaderModule].Get(
                        command.devicecreatecomputepipelineasync().desc().compute().module());

                if (dawn_descriptor_compute_module_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor_compute.module =
                    reinterpret_cast<WGPUShaderModule>(dawn_descriptor_compute_module_id);
                dawn_descriptor_compute.entryPoint = "main";
                // start variable length WGPUConstantEntry[]
                size_t dawn_descriptor_computeN_constants_size =
                    command.devicecreatecomputepipelineasync().desc().compute().constants().size();
                std::unique_ptr<WGPUConstantEntry[]> dawn_descriptor_computeN_constants(
                    new WGPUConstantEntry[dawn_descriptor_computeN_constants_size]);
                for (size_t i = 0; i < dawn_descriptor_computeN_constants_size; i++) {
                    // start structure WGPUConstantEntry
                    WGPUConstantEntry dawn_descriptor_compute_constants;
                    memset(&dawn_descriptor_compute_constants, 0, sizeof(struct WGPUConstantEntry));

                    dawn_descriptor_compute_constants.key = "main";
                    dawn_descriptor_compute_constants.value =
                        command.devicecreatecomputepipelineasync()
                            .desc()
                            .compute()
                            .constants(i)
                            .value();
                    // end structure WGPUConstantEntry

                    dawn_descriptor_computeN_constants[i] = dawn_descriptor_compute_constants;
                }

                dawn_descriptor_compute.constants = dawn_descriptor_computeN_constants.get();
                dawn_descriptor_compute.constantCount =
                    command.devicecreatecomputepipelineasync().desc().compute().constants().size();
                // end variablelength WGPUConstantEntry[]
                // end structure WGPUProgrammableStageDescriptor
                dawn_descriptor.compute = dawn_descriptor_compute;
                // end structure WGPUComputePipelineDescriptor
                cmd.descriptor = &dawn_descriptor;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateErrorBuffer: {
                DeviceCreateErrorBufferCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateErrorBufferCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicecreateerrorbuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                if (gObjectStores[ObjectType::Buffer].size() > BUFFER_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::Buffer].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateErrorExternalTexture: {
                DeviceCreateErrorExternalTextureCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateErrorExternalTextureCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreateerrorexternaltexture().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                if (gObjectStores[ObjectType::ExternalTexture].size() > EXTERNAL_TEXTURE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::ExternalTexture].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateErrorTexture: {
                DeviceCreateErrorTextureCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateErrorTextureCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreateerrortexture().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUTextureDescriptor
                WGPUTextureDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUTextureDescriptor));

                int bitmap_upper = command.devicecreateerrortexture().desc().usage().size();
                for (int i = 0; i < bitmap_upper; i++) {
                    dawn_descriptor.usage |= static_cast<WGPUTextureUsage>(
                        command.devicecreateerrortexture().desc().usage(i));
                }
                dawn_descriptor.dimension = static_cast<WGPUTextureDimension>(
                    command.devicecreateerrortexture().desc().dimension());
                // start structure WGPUExtent3D
                WGPUExtent3D dawn_descriptor_size;
                memset(&dawn_descriptor_size, 0, sizeof(struct WGPUExtent3D));

                dawn_descriptor_size.width =
                    command.devicecreateerrortexture().desc().size().width();
                dawn_descriptor_size.height =
                    command.devicecreateerrortexture().desc().size().height();
                dawn_descriptor_size.depthOrArrayLayers =
                    command.devicecreateerrortexture().desc().size().depthorarraylayers();
                // end structure WGPUExtent3D
                dawn_descriptor.size = dawn_descriptor_size;
                dawn_descriptor.format = static_cast<WGPUTextureFormat>(
                    command.devicecreateerrortexture().desc().format());
                dawn_descriptor.mipLevelCount =
                    command.devicecreateerrortexture().desc().miplevelcount();
                dawn_descriptor.sampleCount =
                    command.devicecreateerrortexture().desc().samplecount();
                // start variable length WGPUTextureFormat[]
                size_t dawn_descriptorN_viewformats_size =
                    command.devicecreateerrortexture().desc().viewformats().size();
                std::unique_ptr<WGPUTextureFormat[]> dawn_descriptorN_viewformats(
                    new WGPUTextureFormat[dawn_descriptorN_viewformats_size]);
                for (size_t i = 0; i < dawn_descriptorN_viewformats_size; i++) {
                    dawn_descriptorN_viewformats[i] = static_cast<WGPUTextureFormat>(
                        command.devicecreateerrortexture().desc().viewformats(i));
                }

                dawn_descriptor.viewFormats = dawn_descriptorN_viewformats.get();
                dawn_descriptor.viewFormatCount =
                    command.devicecreateerrortexture().desc().viewformats().size();
                // end variablelength WGPUTextureFormat[]
                // end structure WGPUTextureDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::Texture].size() > TEXTURE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::Texture].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateExternalTexture: {
                DeviceCreateExternalTextureCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateExternalTextureCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreateexternaltexture().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUExternalTextureDescriptor
                WGPUExternalTextureDescriptor dawn_externaltexturedescriptor;
                memset(&dawn_externaltexturedescriptor, 0,
                       sizeof(struct WGPUExternalTextureDescriptor));

                ObjectId dawn_externaltexturedescriptor_plane0_id =
                    gObjectStores[ObjectType::TextureView].Get(
                        command.devicecreateexternaltexture().externaltexturedescriptor().plane0());

                if (dawn_externaltexturedescriptor_plane0_id ==
                    static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_externaltexturedescriptor.plane0 =
                    reinterpret_cast<WGPUTextureView>(dawn_externaltexturedescriptor_plane0_id);
                ObjectId dawn_externaltexturedescriptor_plane1_id =
                    gObjectStores[ObjectType::TextureView].Get(
                        command.devicecreateexternaltexture().externaltexturedescriptor().plane1());

                if (dawn_externaltexturedescriptor_plane1_id ==
                    static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_externaltexturedescriptor.plane1 =
                    reinterpret_cast<WGPUTextureView>(dawn_externaltexturedescriptor_plane1_id);
                dawn_externaltexturedescriptor.doYuvToRgbConversionOnly =
                    command.devicecreateexternaltexture()
                        .externaltexturedescriptor()
                        .doyuvtorgbconversiononly();

                // HARDCODED
                std::unique_ptr<float[]> dawn_yuvtorgbconversionmatrix(new float[12]);
                dawn_externaltexturedescriptor.yuvToRgbConversionMatrix =
                    dawn_yuvtorgbconversionmatrix.get();

                std::unique_ptr<float[]> dawn_srctransferfunctionparameters(new float[7]);
                dawn_externaltexturedescriptor.srcTransferFunctionParameters =
                    dawn_srctransferfunctionparameters.get();

                std::unique_ptr<float[]> dawn_dsttransferfunctionparameters(new float[7]);
                dawn_externaltexturedescriptor.dstTransferFunctionParameters =
                    dawn_dsttransferfunctionparameters.get();

                std::unique_ptr<float[]> dawn_gamutconversionmatrix(new float[9]);
                dawn_externaltexturedescriptor.gamutConversionMatrix =
                    dawn_gamutconversionmatrix.get();

                // end structure WGPUExternalTextureDescriptor
                cmd.externalTextureDescriptor = &dawn_externaltexturedescriptor;
                if (gObjectStores[ObjectType::ExternalTexture].size() > EXTERNAL_TEXTURE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::ExternalTexture].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreatePipelineLayout: {
                DeviceCreatePipelineLayoutCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreatePipelineLayoutCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreatepipelinelayout().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUPipelineLayoutDescriptor
                WGPUPipelineLayoutDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUPipelineLayoutDescriptor));

                // start variable length WGPUBindGroupLayout[]
                size_t dawn_descriptorN_bindgrouplayouts_size =
                    command.devicecreatepipelinelayout().desc().bindgrouplayouts().size();
                std::unique_ptr<WGPUBindGroupLayout[]> dawn_descriptorN_bindgrouplayouts(
                    new WGPUBindGroupLayout[dawn_descriptorN_bindgrouplayouts_size]);
                for (size_t i = 0; i < dawn_descriptorN_bindgrouplayouts_size; i++) {
                    ObjectId dawn_descriptor_bindgrouplayouts_id =
                        gObjectStores[ObjectType::BindGroupLayout].Get(
                            command.devicecreatepipelinelayout().desc().bindgrouplayouts(i));

                    if (dawn_descriptor_bindgrouplayouts_id ==
                        static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    dawn_descriptorN_bindgrouplayouts[i] =
                        reinterpret_cast<WGPUBindGroupLayout>(dawn_descriptor_bindgrouplayouts_id);
                }

                dawn_descriptor.bindGroupLayouts = dawn_descriptorN_bindgrouplayouts.get();
                dawn_descriptor.bindGroupLayoutCount =
                    command.devicecreatepipelinelayout().desc().bindgrouplayouts().size();
                // end variablelength WGPUBindGroupLayout[]
                // end structure WGPUPipelineLayoutDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::PipelineLayout].size() > PIPELINE_LAYOUT_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::PipelineLayout].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateQuerySet: {
                DeviceCreateQuerySetCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateQuerySetCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicecreatequeryset().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUQuerySetDescriptor
                WGPUQuerySetDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUQuerySetDescriptor));

                dawn_descriptor.type =
                    static_cast<WGPUQueryType>(command.devicecreatequeryset().desc().type());
                dawn_descriptor.count = command.devicecreatequeryset().desc().count();
                // start variable length WGPUPipelineStatisticName[]
                size_t dawn_descriptorN_pipelinestatistics_size =
                    command.devicecreatequeryset().desc().pipelinestatistics().size();
                std::unique_ptr<WGPUPipelineStatisticName[]> dawn_descriptorN_pipelinestatistics(
                    new WGPUPipelineStatisticName[dawn_descriptorN_pipelinestatistics_size]);
                for (size_t i = 0; i < dawn_descriptorN_pipelinestatistics_size; i++) {
                    dawn_descriptorN_pipelinestatistics[i] = static_cast<WGPUPipelineStatisticName>(
                        command.devicecreatequeryset().desc().pipelinestatistics(i));
                }

                dawn_descriptor.pipelineStatistics = dawn_descriptorN_pipelinestatistics.get();
                dawn_descriptor.pipelineStatisticsCount =
                    command.devicecreatequeryset().desc().pipelinestatistics().size();
                // end variablelength WGPUPipelineStatisticName[]
                // end structure WGPUQuerySetDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::QuerySet].size() > QUERY_SET_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::QuerySet].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateRenderBundleEncoder: {
                DeviceCreateRenderBundleEncoderCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateRenderBundleEncoderCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreaterenderbundleencoder().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPURenderBundleEncoderDescriptor
                WGPURenderBundleEncoderDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPURenderBundleEncoderDescriptor));

                // start variable length WGPUTextureFormat[]
                size_t dawn_descriptorN_colorformats_size =
                    command.devicecreaterenderbundleencoder().desc().colorformats().size();
                std::unique_ptr<WGPUTextureFormat[]> dawn_descriptorN_colorformats(
                    new WGPUTextureFormat[dawn_descriptorN_colorformats_size]);
                for (size_t i = 0; i < dawn_descriptorN_colorformats_size; i++) {
                    dawn_descriptorN_colorformats[i] = static_cast<WGPUTextureFormat>(
                        command.devicecreaterenderbundleencoder().desc().colorformats(i));
                }

                dawn_descriptor.colorFormats = dawn_descriptorN_colorformats.get();
                dawn_descriptor.colorFormatsCount =
                    command.devicecreaterenderbundleencoder().desc().colorformats().size();
                // end variablelength WGPUTextureFormat[]
                dawn_descriptor.depthStencilFormat = static_cast<WGPUTextureFormat>(
                    command.devicecreaterenderbundleencoder().desc().depthstencilformat());
                dawn_descriptor.sampleCount =
                    command.devicecreaterenderbundleencoder().desc().samplecount();
                dawn_descriptor.depthReadOnly =
                    command.devicecreaterenderbundleencoder().desc().depthreadonly();
                dawn_descriptor.stencilReadOnly =
                    command.devicecreaterenderbundleencoder().desc().stencilreadonly();
                // end structure WGPURenderBundleEncoderDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::RenderBundleEncoder].size() >
                    RENDER_BUNDLE_ENCODER_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::RenderBundleEncoder].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateRenderPipeline: {
                DeviceCreateRenderPipelineCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateRenderPipelineCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreaterenderpipeline().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPURenderPipelineDescriptor
                WGPURenderPipelineDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPURenderPipelineDescriptor));

                ObjectId dawn_descriptor_layout_id = gObjectStores[ObjectType::PipelineLayout].Get(
                    command.devicecreaterenderpipeline().desc().layout());

                if (dawn_descriptor_layout_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor.layout =
                    reinterpret_cast<WGPUPipelineLayout>(dawn_descriptor_layout_id);
                // start structure WGPUVertexState
                WGPUVertexState dawn_descriptor_vertex;
                memset(&dawn_descriptor_vertex, 0, sizeof(struct WGPUVertexState));

                ObjectId dawn_descriptor_vertex_module_id =
                    gObjectStores[ObjectType::ShaderModule].Get(
                        command.devicecreaterenderpipeline().desc().vertex().module());

                if (dawn_descriptor_vertex_module_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor_vertex.module =
                    reinterpret_cast<WGPUShaderModule>(dawn_descriptor_vertex_module_id);
                dawn_descriptor_vertex.entryPoint = "main";
                // start variable length WGPUConstantEntry[]
                size_t dawn_descriptor_vertexN_constants_size =
                    command.devicecreaterenderpipeline().desc().vertex().constants().size();
                std::unique_ptr<WGPUConstantEntry[]> dawn_descriptor_vertexN_constants(
                    new WGPUConstantEntry[dawn_descriptor_vertexN_constants_size]);
                for (size_t i = 0; i < dawn_descriptor_vertexN_constants_size; i++) {
                    // start structure WGPUConstantEntry
                    WGPUConstantEntry dawn_descriptor_vertex_constants;
                    memset(&dawn_descriptor_vertex_constants, 0, sizeof(struct WGPUConstantEntry));

                    dawn_descriptor_vertex_constants.key = "main";
                    dawn_descriptor_vertex_constants.value =
                        command.devicecreaterenderpipeline().desc().vertex().constants(i).value();
                    // end structure WGPUConstantEntry

                    dawn_descriptor_vertexN_constants[i] = dawn_descriptor_vertex_constants;
                }

                dawn_descriptor_vertex.constants = dawn_descriptor_vertexN_constants.get();
                dawn_descriptor_vertex.constantCount =
                    command.devicecreaterenderpipeline().desc().vertex().constants().size();
                // end variablelength WGPUConstantEntry[]
                // start variable length WGPUVertexBufferLayout[]
                size_t dawn_descriptor_vertexN_buffers_size =
                    command.devicecreaterenderpipeline().desc().vertex().buffers().size();
                std::unique_ptr<WGPUVertexBufferLayout[]> dawn_descriptor_vertexN_buffers(
                    new WGPUVertexBufferLayout[dawn_descriptor_vertexN_buffers_size]);

                std::vector<std::unique_ptr<WGPUVertexAttribute[]>>
                    dawn_descriptor_vertex_buffersN_attributesN(
                        dawn_descriptor_vertexN_buffers_size);

                for (size_t i = 0; i < dawn_descriptor_vertexN_buffers_size; i++) {
                    // start structure WGPUVertexBufferLayout
                    WGPUVertexBufferLayout dawn_descriptor_vertex_buffers;
                    memset(&dawn_descriptor_vertex_buffers, 0,
                           sizeof(struct WGPUVertexBufferLayout));

                    dawn_descriptor_vertex_buffers.arrayStride =
                        command.devicecreaterenderpipeline()
                            .desc()
                            .vertex()
                            .buffers(i)
                            .arraystride();
                    dawn_descriptor_vertex_buffers.stepMode = static_cast<WGPUVertexStepMode>(
                        command.devicecreaterenderpipeline().desc().vertex().buffers(i).stepmode());
                    // start variable length WGPUVertexAttribute[]
                    size_t dawn_descriptor_vertex_buffersN_attributes_size =
                        command.devicecreaterenderpipeline()
                            .desc()
                            .vertex()
                            .buffers(i)
                            .attributes()
                            .size();
                    std::unique_ptr<WGPUVertexAttribute[]>
                        dawn_descriptor_vertex_buffersN_attributes(
                            new WGPUVertexAttribute
                                [dawn_descriptor_vertex_buffersN_attributes_size]);
                    for (size_t j = 0; j < dawn_descriptor_vertex_buffersN_attributes_size; j++) {
                        // start structure WGPUVertexAttribute
                        WGPUVertexAttribute dawn_descriptor_vertex_buffers_attributes;
                        memset(&dawn_descriptor_vertex_buffers_attributes, 0,
                               sizeof(struct WGPUVertexAttribute));

                        dawn_descriptor_vertex_buffers_attributes.format =
                            static_cast<WGPUVertexFormat>(command.devicecreaterenderpipeline()
                                                              .desc()
                                                              .vertex()
                                                              .buffers(i)
                                                              .attributes(j)
                                                              .format());
                        dawn_descriptor_vertex_buffers_attributes.offset =
                            command.devicecreaterenderpipeline()
                                .desc()
                                .vertex()
                                .buffers(i)
                                .attributes(j)
                                .offset();
                        dawn_descriptor_vertex_buffers_attributes.shaderLocation =
                            command.devicecreaterenderpipeline()
                                .desc()
                                .vertex()
                                .buffers(i)
                                .attributes(j)
                                .shaderlocation();
                        // end structure WGPUVertexAttribute
                        dawn_descriptor_vertex_buffersN_attributes[j] =
                            dawn_descriptor_vertex_buffers_attributes;
                    }

                    dawn_descriptor_vertex_buffers.attributes =
                        dawn_descriptor_vertex_buffersN_attributes.get();
                    dawn_descriptor_vertex_buffers.attributeCount =
                        command.devicecreaterenderpipeline()
                            .desc()
                            .vertex()
                            .buffers(i)
                            .attributes()
                            .size();
                    // end variablelength WGPUVertexAttribute[]
                    // end structure WGPUVertexBufferLayout

                    dawn_descriptor_vertexN_buffers[i] = dawn_descriptor_vertex_buffers;
                    dawn_descriptor_vertex_buffersN_attributesN.push_back(
                        std::move(dawn_descriptor_vertex_buffersN_attributes));
                }

                dawn_descriptor_vertex.buffers = dawn_descriptor_vertexN_buffers.get();
                dawn_descriptor_vertex.bufferCount =
                    command.devicecreaterenderpipeline().desc().vertex().buffers().size();
                // end variablelength WGPUVertexBufferLayout[]
                // end structure WGPUVertexState
                dawn_descriptor.vertex = dawn_descriptor_vertex;
                // start structure WGPUPrimitiveState
                WGPUPrimitiveState dawn_descriptor_primitive;
                memset(&dawn_descriptor_primitive, 0, sizeof(struct WGPUPrimitiveState));

                dawn_descriptor_primitive.topology = static_cast<WGPUPrimitiveTopology>(
                    command.devicecreaterenderpipeline().desc().primitive().topology());
                dawn_descriptor_primitive.stripIndexFormat = static_cast<WGPUIndexFormat>(
                    command.devicecreaterenderpipeline().desc().primitive().stripindexformat());
                dawn_descriptor_primitive.frontFace = static_cast<WGPUFrontFace>(
                    command.devicecreaterenderpipeline().desc().primitive().frontface());
                dawn_descriptor_primitive.cullMode = static_cast<WGPUCullMode>(
                    command.devicecreaterenderpipeline().desc().primitive().cullmode());
                // end structure WGPUPrimitiveState
                dawn_descriptor.primitive = dawn_descriptor_primitive;
                // start structure WGPUDepthStencilState
                WGPUDepthStencilState dawn_descriptor_depthstencil;
                memset(&dawn_descriptor_depthstencil, 0, sizeof(struct WGPUDepthStencilState));

                dawn_descriptor_depthstencil.format = static_cast<WGPUTextureFormat>(
                    command.devicecreaterenderpipeline().desc().depthstencil().format());
                dawn_descriptor_depthstencil.depthWriteEnabled =
                    command.devicecreaterenderpipeline().desc().depthstencil().depthwriteenabled();
                dawn_descriptor_depthstencil.depthCompare = static_cast<WGPUCompareFunction>(
                    command.devicecreaterenderpipeline().desc().depthstencil().depthcompare());
                // start structure WGPUStencilFaceState
                WGPUStencilFaceState dawn_descriptor_depthstencil_stencilfront;
                memset(&dawn_descriptor_depthstencil_stencilfront, 0,
                       sizeof(struct WGPUStencilFaceState));

                dawn_descriptor_depthstencil_stencilfront.compare =
                    static_cast<WGPUCompareFunction>(command.devicecreaterenderpipeline()
                                                         .desc()
                                                         .depthstencil()
                                                         .stencilfront()
                                                         .compare());
                dawn_descriptor_depthstencil_stencilfront.failOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipeline()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilfront()
                                                          .failop());
                dawn_descriptor_depthstencil_stencilfront.depthFailOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipeline()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilfront()
                                                          .depthfailop());
                dawn_descriptor_depthstencil_stencilfront.passOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipeline()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilfront()
                                                          .passop());
                // end structure WGPUStencilFaceState
                dawn_descriptor_depthstencil.stencilFront =
                    dawn_descriptor_depthstencil_stencilfront;
                // start structure WGPUStencilFaceState
                WGPUStencilFaceState dawn_descriptor_depthstencil_stencilback;
                memset(&dawn_descriptor_depthstencil_stencilback, 0,
                       sizeof(struct WGPUStencilFaceState));

                dawn_descriptor_depthstencil_stencilback.compare =
                    static_cast<WGPUCompareFunction>(command.devicecreaterenderpipeline()
                                                         .desc()
                                                         .depthstencil()
                                                         .stencilback()
                                                         .compare());
                dawn_descriptor_depthstencil_stencilback.failOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipeline()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilback()
                                                          .failop());
                dawn_descriptor_depthstencil_stencilback.depthFailOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipeline()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilback()
                                                          .depthfailop());
                dawn_descriptor_depthstencil_stencilback.passOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipeline()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilback()
                                                          .passop());
                // end structure WGPUStencilFaceState
                dawn_descriptor_depthstencil.stencilBack = dawn_descriptor_depthstencil_stencilback;
                dawn_descriptor_depthstencil.stencilReadMask =
                    command.devicecreaterenderpipeline().desc().depthstencil().stencilreadmask();
                dawn_descriptor_depthstencil.stencilWriteMask =
                    command.devicecreaterenderpipeline().desc().depthstencil().stencilwritemask();
                dawn_descriptor_depthstencil.depthBias =
                    command.devicecreaterenderpipeline().desc().depthstencil().depthbias();
                dawn_descriptor_depthstencil.depthBiasSlopeScale =
                    command.devicecreaterenderpipeline()
                        .desc()
                        .depthstencil()
                        .depthbiasslopescale();
                dawn_descriptor_depthstencil.depthBiasClamp =
                    command.devicecreaterenderpipeline().desc().depthstencil().depthbiasclamp();
                // end structure WGPUDepthStencilState
                dawn_descriptor.depthStencil = &dawn_descriptor_depthstencil;  // HARDCODED
                // start structure WGPUMultisampleState
                WGPUMultisampleState dawn_descriptor_multisample;
                memset(&dawn_descriptor_multisample, 0, sizeof(struct WGPUMultisampleState));

                dawn_descriptor_multisample.count =
                    command.devicecreaterenderpipeline().desc().multisample().count();
                dawn_descriptor_multisample.mask =
                    command.devicecreaterenderpipeline().desc().multisample().mask();
                dawn_descriptor_multisample.alphaToCoverageEnabled =
                    command.devicecreaterenderpipeline()
                        .desc()
                        .multisample()
                        .alphatocoverageenabled();
                // end structure WGPUMultisampleState
                dawn_descriptor.multisample = dawn_descriptor_multisample;
                // start structure WGPUFragmentState
                WGPUFragmentState dawn_descriptor_fragment;
                memset(&dawn_descriptor_fragment, 0, sizeof(struct WGPUFragmentState));

                ObjectId dawn_descriptor_fragment_module_id =
                    gObjectStores[ObjectType::ShaderModule].Get(
                        command.devicecreaterenderpipeline().desc().fragment().module());

                if (dawn_descriptor_fragment_module_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor_fragment.module =
                    reinterpret_cast<WGPUShaderModule>(dawn_descriptor_fragment_module_id);
                dawn_descriptor_fragment.entryPoint = "main";
                // start variable length WGPUConstantEntry[]
                size_t dawn_descriptor_fragmentN_constants_size =
                    command.devicecreaterenderpipeline().desc().fragment().constants().size();
                std::unique_ptr<WGPUConstantEntry[]> dawn_descriptor_fragmentN_constants(
                    new WGPUConstantEntry[dawn_descriptor_fragmentN_constants_size]);
                for (size_t i = 0; i < dawn_descriptor_fragmentN_constants_size; i++) {
                    // start structure WGPUConstantEntry
                    WGPUConstantEntry dawn_descriptor_fragment_constants;
                    memset(&dawn_descriptor_fragment_constants, 0,
                           sizeof(struct WGPUConstantEntry));

                    dawn_descriptor_fragment_constants.key = "main";
                    dawn_descriptor_fragment_constants.value =
                        command.devicecreaterenderpipeline().desc().fragment().constants(i).value();
                    // end structure WGPUConstantEntry

                    dawn_descriptor_fragmentN_constants[i] = dawn_descriptor_fragment_constants;
                }

                dawn_descriptor_fragment.constants = dawn_descriptor_fragmentN_constants.get();
                dawn_descriptor_fragment.constantCount =
                    command.devicecreaterenderpipeline().desc().fragment().constants().size();
                // end variablelength WGPUConstantEntry[]
                // start variable length WGPUColorTargetState[]
                size_t dawn_descriptor_fragmentN_targets_size =
                    command.devicecreaterenderpipeline().desc().fragment().targets().size();
                std::unique_ptr<WGPUColorTargetState[]> dawn_descriptor_fragmentN_targets(
                    new WGPUColorTargetState[dawn_descriptor_fragmentN_targets_size]);

                std::unique_ptr<WGPUBlendState[]> dawn_descriptor_fragmentN_targets_blend(
                    new WGPUBlendState[dawn_descriptor_fragmentN_targets_size]);

                for (size_t i = 0; i < dawn_descriptor_fragmentN_targets_size; i++) {
                    // start structure WGPUColorTargetState
                    WGPUColorTargetState dawn_descriptor_fragment_targets;
                    memset(&dawn_descriptor_fragment_targets, 0,
                           sizeof(struct WGPUColorTargetState));

                    dawn_descriptor_fragment_targets.format = static_cast<WGPUTextureFormat>(
                        command.devicecreaterenderpipeline().desc().fragment().targets(i).format());
                    // start structure WGPUBlendState
                    WGPUBlendState dawn_descriptor_fragment_targets_blend;
                    memset(&dawn_descriptor_fragmentN_targets_blend[i], 0,
                           sizeof(struct WGPUBlendState));

                    // start structure WGPUBlendComponent
                    WGPUBlendComponent dawn_descriptor_fragment_targets_blend_color;
                    memset(&dawn_descriptor_fragment_targets_blend_color, 0,
                           sizeof(struct WGPUBlendComponent));

                    dawn_descriptor_fragment_targets_blend_color.operation =
                        static_cast<WGPUBlendOperation>(command.devicecreaterenderpipeline()
                                                            .desc()
                                                            .fragment()
                                                            .targets(i)
                                                            .blend()
                                                            .color()
                                                            .operation());
                    dawn_descriptor_fragment_targets_blend_color.srcFactor =
                        static_cast<WGPUBlendFactor>(command.devicecreaterenderpipeline()
                                                         .desc()
                                                         .fragment()
                                                         .targets(i)
                                                         .blend()
                                                         .color()
                                                         .srcfactor());
                    dawn_descriptor_fragment_targets_blend_color.dstFactor =
                        static_cast<WGPUBlendFactor>(command.devicecreaterenderpipeline()
                                                         .desc()
                                                         .fragment()
                                                         .targets(i)
                                                         .blend()
                                                         .color()
                                                         .dstfactor());
                    // end structure WGPUBlendComponent
                    dawn_descriptor_fragment_targets_blend.color =
                        dawn_descriptor_fragment_targets_blend_color;
                    // start structure WGPUBlendComponent
                    WGPUBlendComponent dawn_descriptor_fragment_targets_blend_alpha;
                    memset(&dawn_descriptor_fragment_targets_blend_alpha, 0,
                           sizeof(struct WGPUBlendComponent));

                    dawn_descriptor_fragment_targets_blend_alpha.operation =
                        static_cast<WGPUBlendOperation>(command.devicecreaterenderpipeline()
                                                            .desc()
                                                            .fragment()
                                                            .targets(i)
                                                            .blend()
                                                            .alpha()
                                                            .operation());
                    dawn_descriptor_fragment_targets_blend_alpha.srcFactor =
                        static_cast<WGPUBlendFactor>(command.devicecreaterenderpipeline()
                                                         .desc()
                                                         .fragment()
                                                         .targets(i)
                                                         .blend()
                                                         .alpha()
                                                         .srcfactor());
                    dawn_descriptor_fragment_targets_blend_alpha.dstFactor =
                        static_cast<WGPUBlendFactor>(command.devicecreaterenderpipeline()
                                                         .desc()
                                                         .fragment()
                                                         .targets(i)
                                                         .blend()
                                                         .alpha()
                                                         .dstfactor());
                    // end structure WGPUBlendComponent
                    dawn_descriptor_fragment_targets_blend.alpha =
                        dawn_descriptor_fragment_targets_blend_alpha;
                    // end structure WGPUBlendState
                    dawn_descriptor_fragmentN_targets_blend[i] =
                        dawn_descriptor_fragment_targets_blend;
                    dawn_descriptor_fragment_targets.blend =
                        &dawn_descriptor_fragmentN_targets_blend[i];  // HARDCODED

                    int bitmask_upper = command.devicecreaterenderpipeline()
                                            .desc()
                                            .fragment()
                                            .targets(i)
                                            .writemask()
                                            .size();
                    for (int j = 0; j < bitmask_upper; j++) {
                        dawn_descriptor_fragment_targets.writeMask |=
                            static_cast<WGPUColorWriteMask>(command.devicecreaterenderpipeline()
                                                                .desc()
                                                                .fragment()
                                                                .targets(i)
                                                                .writemask(j));
                    }
                    // end structure WGPUColorTargetState

                    dawn_descriptor_fragmentN_targets[i] = dawn_descriptor_fragment_targets;
                }

                dawn_descriptor_fragment.targets = dawn_descriptor_fragmentN_targets.get();
                dawn_descriptor_fragment.targetCount =
                    command.devicecreaterenderpipeline().desc().fragment().targets().size();
                // end variablelength WGPUColorTargetState[]
                // end structure WGPUFragmentState
                dawn_descriptor.fragment = &dawn_descriptor_fragment;  // HARDCODED
                // end structure WGPURenderPipelineDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::RenderPipeline].size() > RENDER_PIPELINE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::RenderPipeline].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateRenderPipelineAsync: {
                DeviceCreateRenderPipelineAsyncCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateRenderPipelineAsyncCmd));

                cmd.deviceId = gObjectStores[ObjectType::Device].Get(
                    command.devicecreaterenderpipelineasync().deviceid());
                cmd.requestSerial = command.devicecreaterenderpipelineasync().requestserial();
                if (gObjectStores[ObjectType::RenderPipeline].size() > RENDER_PIPELINE_LIMIT) {
                    break;
                }
                cmd.pipelineObjectHandle =
                    gObjectStores[ObjectType::RenderPipeline].ReserveHandle();
                // start structure WGPURenderPipelineDescriptor
                WGPURenderPipelineDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPURenderPipelineDescriptor));

                ObjectId dawn_descriptor_layout_id = gObjectStores[ObjectType::PipelineLayout].Get(
                    command.devicecreaterenderpipelineasync().desc().layout());

                if (dawn_descriptor_layout_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor.layout =
                    reinterpret_cast<WGPUPipelineLayout>(dawn_descriptor_layout_id);
                // start structure WGPUVertexState
                WGPUVertexState dawn_descriptor_vertex;
                memset(&dawn_descriptor_vertex, 0, sizeof(struct WGPUVertexState));

                ObjectId dawn_descriptor_vertex_module_id =
                    gObjectStores[ObjectType::ShaderModule].Get(
                        command.devicecreaterenderpipelineasync().desc().vertex().module());

                if (dawn_descriptor_vertex_module_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor_vertex.module =
                    reinterpret_cast<WGPUShaderModule>(dawn_descriptor_vertex_module_id);
                dawn_descriptor_vertex.entryPoint = "main";
                // start variable length WGPUConstantEntry[]
                size_t dawn_descriptor_vertexN_constants_size =
                    command.devicecreaterenderpipelineasync().desc().vertex().constants().size();
                std::unique_ptr<WGPUConstantEntry[]> dawn_descriptor_vertexN_constants(
                    new WGPUConstantEntry[dawn_descriptor_vertexN_constants_size]);
                for (size_t i = 0; i < dawn_descriptor_vertexN_constants_size; i++) {
                    // start structure WGPUConstantEntry
                    WGPUConstantEntry dawn_descriptor_vertex_constants;
                    memset(&dawn_descriptor_vertex_constants, 0, sizeof(struct WGPUConstantEntry));

                    dawn_descriptor_vertex_constants.key = "main";
                    dawn_descriptor_vertex_constants.value =
                        command.devicecreaterenderpipelineasync()
                            .desc()
                            .vertex()
                            .constants(i)
                            .value();
                    // end structure WGPUConstantEntry

                    dawn_descriptor_vertexN_constants[i] = dawn_descriptor_vertex_constants;
                }

                dawn_descriptor_vertex.constants = dawn_descriptor_vertexN_constants.get();
                dawn_descriptor_vertex.constantCount =
                    command.devicecreaterenderpipelineasync().desc().vertex().constants().size();
                // end variablelength WGPUConstantEntry[]
                // start variable length WGPUVertexBufferLayout[]
                size_t dawn_descriptor_vertexN_buffers_size =
                    command.devicecreaterenderpipelineasync().desc().vertex().buffers().size();
                std::unique_ptr<WGPUVertexBufferLayout[]> dawn_descriptor_vertexN_buffers(
                    new WGPUVertexBufferLayout[dawn_descriptor_vertexN_buffers_size]);
                std::vector<std::unique_ptr<WGPUVertexAttribute[]>>
                    dawn_descriptor_vertex_buffersN_attributesN(
                        dawn_descriptor_vertexN_buffers_size);
                // HARDCODED
                for (size_t i = 0; i < dawn_descriptor_vertexN_buffers_size; i++) {
                    // start structure WGPUVertexBufferLayout
                    WGPUVertexBufferLayout dawn_descriptor_vertex_buffers;
                    memset(&dawn_descriptor_vertex_buffers, 0,
                           sizeof(struct WGPUVertexBufferLayout));

                    dawn_descriptor_vertex_buffers.arrayStride =
                        command.devicecreaterenderpipelineasync()
                            .desc()
                            .vertex()
                            .buffers(i)
                            .arraystride();
                    dawn_descriptor_vertex_buffers.stepMode =
                        static_cast<WGPUVertexStepMode>(command.devicecreaterenderpipelineasync()
                                                            .desc()
                                                            .vertex()
                                                            .buffers(i)
                                                            .stepmode());
                    // start variable length WGPUVertexAttribute[]
                    size_t dawn_descriptor_vertex_buffersN_attributes_size =
                        command.devicecreaterenderpipelineasync()
                            .desc()
                            .vertex()
                            .buffers(i)
                            .attributes()
                            .size();
                    std::unique_ptr<WGPUVertexAttribute[]>
                        dawn_descriptor_vertex_buffersN_attributes(
                            new WGPUVertexAttribute
                                [dawn_descriptor_vertex_buffersN_attributes_size]);
                    for (size_t j = 0; j < dawn_descriptor_vertex_buffersN_attributes_size; j++) {
                        // start structure WGPUVertexAttribute
                        WGPUVertexAttribute dawn_descriptor_vertex_buffers_attributes;
                        memset(&dawn_descriptor_vertex_buffers_attributes, 0,
                               sizeof(struct WGPUVertexAttribute));

                        dawn_descriptor_vertex_buffers_attributes.format =
                            static_cast<WGPUVertexFormat>(command.devicecreaterenderpipelineasync()
                                                              .desc()
                                                              .vertex()
                                                              .buffers(i)
                                                              .attributes(j)
                                                              .format());
                        dawn_descriptor_vertex_buffers_attributes.offset =
                            command.devicecreaterenderpipelineasync()
                                .desc()
                                .vertex()
                                .buffers(i)
                                .attributes(j)
                                .offset();
                        dawn_descriptor_vertex_buffers_attributes.shaderLocation =
                            command.devicecreaterenderpipelineasync()
                                .desc()
                                .vertex()
                                .buffers(i)
                                .attributes(j)
                                .shaderlocation();
                        // end structure WGPUVertexAttribute
                        dawn_descriptor_vertex_buffersN_attributes[j] =
                            dawn_descriptor_vertex_buffers_attributes;
                    }

                    dawn_descriptor_vertex_buffers.attributes =
                        dawn_descriptor_vertex_buffersN_attributes.get();
                    dawn_descriptor_vertex_buffers.attributeCount =
                        command.devicecreaterenderpipelineasync()
                            .desc()
                            .vertex()
                            .buffers(i)
                            .attributes()
                            .size();
                    dawn_descriptor_vertex_buffersN_attributesN.push_back(
                        std::move(dawn_descriptor_vertex_buffersN_attributes));
                    // end variablelength WGPUVertexAttribute[]
                    // end structure WGPUVertexBufferLayout
                    dawn_descriptor_vertexN_buffers[i] = dawn_descriptor_vertex_buffers;
                }

                dawn_descriptor_vertex.buffers = dawn_descriptor_vertexN_buffers.get();
                dawn_descriptor_vertex.bufferCount =
                    command.devicecreaterenderpipelineasync().desc().vertex().buffers().size();
                // end variablelength WGPUVertexBufferLayout[]
                // end structure WGPUVertexState
                dawn_descriptor.vertex = dawn_descriptor_vertex;
                // start structure WGPUPrimitiveState
                WGPUPrimitiveState dawn_descriptor_primitive;
                memset(&dawn_descriptor_primitive, 0, sizeof(struct WGPUPrimitiveState));

                dawn_descriptor_primitive.topology = static_cast<WGPUPrimitiveTopology>(
                    command.devicecreaterenderpipelineasync().desc().primitive().topology());
                dawn_descriptor_primitive.stripIndexFormat =
                    static_cast<WGPUIndexFormat>(command.devicecreaterenderpipelineasync()
                                                     .desc()
                                                     .primitive()
                                                     .stripindexformat());
                dawn_descriptor_primitive.frontFace = static_cast<WGPUFrontFace>(
                    command.devicecreaterenderpipelineasync().desc().primitive().frontface());
                dawn_descriptor_primitive.cullMode = static_cast<WGPUCullMode>(
                    command.devicecreaterenderpipelineasync().desc().primitive().cullmode());
                // end structure WGPUPrimitiveState
                dawn_descriptor.primitive = dawn_descriptor_primitive;
                // start structure WGPUDepthStencilState
                WGPUDepthStencilState dawn_descriptor_depthstencil;
                memset(&dawn_descriptor_depthstencil, 0, sizeof(struct WGPUDepthStencilState));

                dawn_descriptor_depthstencil.format = static_cast<WGPUTextureFormat>(
                    command.devicecreaterenderpipelineasync().desc().depthstencil().format());
                dawn_descriptor_depthstencil.depthWriteEnabled =
                    command.devicecreaterenderpipelineasync()
                        .desc()
                        .depthstencil()
                        .depthwriteenabled();
                dawn_descriptor_depthstencil.depthCompare = static_cast<WGPUCompareFunction>(
                    command.devicecreaterenderpipelineasync().desc().depthstencil().depthcompare());
                // start structure WGPUStencilFaceState
                WGPUStencilFaceState dawn_descriptor_depthstencil_stencilfront;
                memset(&dawn_descriptor_depthstencil_stencilfront, 0,
                       sizeof(struct WGPUStencilFaceState));

                dawn_descriptor_depthstencil_stencilfront.compare =
                    static_cast<WGPUCompareFunction>(command.devicecreaterenderpipelineasync()
                                                         .desc()
                                                         .depthstencil()
                                                         .stencilfront()
                                                         .compare());
                dawn_descriptor_depthstencil_stencilfront.failOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipelineasync()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilfront()
                                                          .failop());
                dawn_descriptor_depthstencil_stencilfront.depthFailOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipelineasync()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilfront()
                                                          .depthfailop());
                dawn_descriptor_depthstencil_stencilfront.passOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipelineasync()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilfront()
                                                          .passop());
                // end structure WGPUStencilFaceState
                dawn_descriptor_depthstencil.stencilFront =
                    dawn_descriptor_depthstencil_stencilfront;
                // start structure WGPUStencilFaceState
                WGPUStencilFaceState dawn_descriptor_depthstencil_stencilback;
                memset(&dawn_descriptor_depthstencil_stencilback, 0,
                       sizeof(struct WGPUStencilFaceState));

                dawn_descriptor_depthstencil_stencilback.compare =
                    static_cast<WGPUCompareFunction>(command.devicecreaterenderpipelineasync()
                                                         .desc()
                                                         .depthstencil()
                                                         .stencilback()
                                                         .compare());
                dawn_descriptor_depthstencil_stencilback.failOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipelineasync()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilback()
                                                          .failop());
                dawn_descriptor_depthstencil_stencilback.depthFailOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipelineasync()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilback()
                                                          .depthfailop());
                dawn_descriptor_depthstencil_stencilback.passOp =
                    static_cast<WGPUStencilOperation>(command.devicecreaterenderpipelineasync()
                                                          .desc()
                                                          .depthstencil()
                                                          .stencilback()
                                                          .passop());
                // end structure WGPUStencilFaceState
                dawn_descriptor_depthstencil.stencilBack = dawn_descriptor_depthstencil_stencilback;
                dawn_descriptor_depthstencil.stencilReadMask =
                    command.devicecreaterenderpipelineasync()
                        .desc()
                        .depthstencil()
                        .stencilreadmask();
                dawn_descriptor_depthstencil.stencilWriteMask =
                    command.devicecreaterenderpipelineasync()
                        .desc()
                        .depthstencil()
                        .stencilwritemask();
                dawn_descriptor_depthstencil.depthBias =
                    command.devicecreaterenderpipelineasync().desc().depthstencil().depthbias();
                dawn_descriptor_depthstencil.depthBiasSlopeScale =
                    command.devicecreaterenderpipelineasync()
                        .desc()
                        .depthstencil()
                        .depthbiasslopescale();
                dawn_descriptor_depthstencil.depthBiasClamp =
                    command.devicecreaterenderpipelineasync()
                        .desc()
                        .depthstencil()
                        .depthbiasclamp();
                // end structure WGPUDepthStencilState
                dawn_descriptor.depthStencil = &dawn_descriptor_depthstencil;  // HARDCODED
                // start structure WGPUMultisampleState
                WGPUMultisampleState dawn_descriptor_multisample;
                memset(&dawn_descriptor_multisample, 0, sizeof(struct WGPUMultisampleState));

                dawn_descriptor_multisample.count =
                    command.devicecreaterenderpipelineasync().desc().multisample().count();
                dawn_descriptor_multisample.mask =
                    command.devicecreaterenderpipelineasync().desc().multisample().mask();
                dawn_descriptor_multisample.alphaToCoverageEnabled =
                    command.devicecreaterenderpipelineasync()
                        .desc()
                        .multisample()
                        .alphatocoverageenabled();
                // end structure WGPUMultisampleState
                dawn_descriptor.multisample = dawn_descriptor_multisample;
                // start structure WGPUFragmentState
                WGPUFragmentState dawn_descriptor_fragment;
                memset(&dawn_descriptor_fragment, 0, sizeof(struct WGPUFragmentState));

                ObjectId dawn_descriptor_fragment_module_id =
                    gObjectStores[ObjectType::ShaderModule].Get(
                        command.devicecreaterenderpipelineasync().desc().fragment().module());

                if (dawn_descriptor_fragment_module_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_descriptor_fragment.module =
                    reinterpret_cast<WGPUShaderModule>(dawn_descriptor_fragment_module_id);
                dawn_descriptor_fragment.entryPoint = "main";
                // start variable length WGPUConstantEntry[]
                size_t dawn_descriptor_fragmentN_constants_size =
                    command.devicecreaterenderpipelineasync().desc().fragment().constants().size();
                std::unique_ptr<WGPUConstantEntry[]> dawn_descriptor_fragmentN_constants(
                    new WGPUConstantEntry[dawn_descriptor_fragmentN_constants_size]);
                for (size_t i = 0; i < dawn_descriptor_fragmentN_constants_size; i++) {
                    // start structure WGPUConstantEntry
                    WGPUConstantEntry dawn_descriptor_fragment_constants;
                    memset(&dawn_descriptor_fragment_constants, 0,
                           sizeof(struct WGPUConstantEntry));

                    dawn_descriptor_fragment_constants.key = "main";
                    dawn_descriptor_fragment_constants.value =
                        command.devicecreaterenderpipelineasync()
                            .desc()
                            .fragment()
                            .constants(i)
                            .value();
                    // end structure WGPUConstantEntry
                    dawn_descriptor_fragmentN_constants[i] = dawn_descriptor_fragment_constants;
                }

                dawn_descriptor_fragment.constants = dawn_descriptor_fragmentN_constants.get();
                dawn_descriptor_fragment.constantCount =
                    command.devicecreaterenderpipelineasync().desc().fragment().constants().size();
                // end variablelength WGPUConstantEntry[]
                // start variable length WGPUColorTargetState[]
                size_t dawn_descriptor_fragmentN_targets_size =
                    command.devicecreaterenderpipelineasync().desc().fragment().targets().size();
                std::unique_ptr<WGPUColorTargetState[]> dawn_descriptor_fragmentN_targets(
                    new WGPUColorTargetState[dawn_descriptor_fragmentN_targets_size]);
                std::unique_ptr<WGPUBlendState[]> dawn_descriptor_fragmentN_targets_blend(
                    new WGPUBlendState[dawn_descriptor_fragmentN_targets_size]);
                for (size_t i = 0; i < dawn_descriptor_fragmentN_targets_size; i++) {
                    // start structure WGPUColorTargetState
                    WGPUColorTargetState dawn_descriptor_fragment_targets;
                    memset(&dawn_descriptor_fragment_targets, 0,
                           sizeof(struct WGPUColorTargetState));

                    dawn_descriptor_fragment_targets.format =
                        static_cast<WGPUTextureFormat>(command.devicecreaterenderpipelineasync()
                                                           .desc()
                                                           .fragment()
                                                           .targets(i)
                                                           .format());
                    // start structure WGPUBlendState
                    WGPUBlendState dawn_descriptor_fragment_targets_blend;
                    memset(&dawn_descriptor_fragment_targets_blend, 0,
                           sizeof(struct WGPUBlendState));
                    memset(&dawn_descriptor_fragmentN_targets_blend[i], 0,
                           sizeof(struct WGPUBlendState));

                    // start structure WGPUBlendComponent
                    WGPUBlendComponent dawn_descriptor_fragment_targets_blend_color;
                    memset(&dawn_descriptor_fragment_targets_blend_color, 0,
                           sizeof(struct WGPUBlendComponent));

                    dawn_descriptor_fragment_targets_blend_color.operation =
                        static_cast<WGPUBlendOperation>(command.devicecreaterenderpipelineasync()
                                                            .desc()
                                                            .fragment()
                                                            .targets(i)
                                                            .blend()
                                                            .color()
                                                            .operation());
                    dawn_descriptor_fragment_targets_blend_color.srcFactor =
                        static_cast<WGPUBlendFactor>(command.devicecreaterenderpipelineasync()
                                                         .desc()
                                                         .fragment()
                                                         .targets(i)
                                                         .blend()
                                                         .color()
                                                         .srcfactor());
                    dawn_descriptor_fragment_targets_blend_color.dstFactor =
                        static_cast<WGPUBlendFactor>(command.devicecreaterenderpipelineasync()
                                                         .desc()
                                                         .fragment()
                                                         .targets(i)
                                                         .blend()
                                                         .color()
                                                         .dstfactor());
                    // end structure WGPUBlendComponent
                    dawn_descriptor_fragment_targets_blend.color =
                        dawn_descriptor_fragment_targets_blend_color;
                    // start structure WGPUBlendComponent
                    WGPUBlendComponent dawn_descriptor_fragment_targets_blend_alpha;
                    memset(&dawn_descriptor_fragment_targets_blend_alpha, 0,
                           sizeof(struct WGPUBlendComponent));

                    dawn_descriptor_fragment_targets_blend_alpha.operation =
                        static_cast<WGPUBlendOperation>(command.devicecreaterenderpipelineasync()
                                                            .desc()
                                                            .fragment()
                                                            .targets(i)
                                                            .blend()
                                                            .alpha()
                                                            .operation());
                    dawn_descriptor_fragment_targets_blend_alpha.srcFactor =
                        static_cast<WGPUBlendFactor>(command.devicecreaterenderpipelineasync()
                                                         .desc()
                                                         .fragment()
                                                         .targets(i)
                                                         .blend()
                                                         .alpha()
                                                         .srcfactor());
                    dawn_descriptor_fragment_targets_blend_alpha.dstFactor =
                        static_cast<WGPUBlendFactor>(command.devicecreaterenderpipelineasync()
                                                         .desc()
                                                         .fragment()
                                                         .targets(i)
                                                         .blend()
                                                         .alpha()
                                                         .dstfactor());
                    // end structure WGPUBlendComponent
                    dawn_descriptor_fragment_targets_blend.alpha =
                        dawn_descriptor_fragment_targets_blend_alpha;
                    // end structure WGPUBlendState
                    dawn_descriptor_fragmentN_targets_blend[i] =
                        dawn_descriptor_fragment_targets_blend;
                    dawn_descriptor_fragment_targets.blend =
                        &dawn_descriptor_fragmentN_targets_blend[i];  // HARDCODED

                    int bitmask_upper = command.devicecreaterenderpipelineasync()
                                            .desc()
                                            .fragment()
                                            .targets(i)
                                            .writemask()
                                            .size();
                    for (int j = 0; j < bitmask_upper; j++) {
                        dawn_descriptor_fragment_targets.writeMask |=
                            static_cast<WGPUColorWriteMask>(
                                command.devicecreaterenderpipelineasync()
                                    .desc()
                                    .fragment()
                                    .targets(i)
                                    .writemask(j));
                    }
                    // end structure WGPUColorTargetState

                    dawn_descriptor_fragmentN_targets[i] = dawn_descriptor_fragment_targets;
                }

                dawn_descriptor_fragment.targets = dawn_descriptor_fragmentN_targets.get();
                dawn_descriptor_fragment.targetCount =
                    command.devicecreaterenderpipelineasync().desc().fragment().targets().size();
                // end variablelength WGPUColorTargetState[]
                // end structure WGPUFragmentState
                dawn_descriptor.fragment = &dawn_descriptor_fragment;  // HARDCODED
                // end structure WGPURenderPipelineDescriptor
                cmd.descriptor = &dawn_descriptor;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateSampler: {
                DeviceCreateSamplerCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateSamplerCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicecreatesampler().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUSamplerDescriptor
                WGPUSamplerDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUSamplerDescriptor));

                dawn_descriptor.addressModeU = static_cast<WGPUAddressMode>(
                    command.devicecreatesampler().desc().addressmodeu());
                dawn_descriptor.addressModeV = static_cast<WGPUAddressMode>(
                    command.devicecreatesampler().desc().addressmodev());
                dawn_descriptor.addressModeW = static_cast<WGPUAddressMode>(
                    command.devicecreatesampler().desc().addressmodew());
                dawn_descriptor.magFilter =
                    static_cast<WGPUFilterMode>(command.devicecreatesampler().desc().magfilter());
                dawn_descriptor.minFilter =
                    static_cast<WGPUFilterMode>(command.devicecreatesampler().desc().minfilter());
                dawn_descriptor.mipmapFilter = static_cast<WGPUFilterMode>(
                    command.devicecreatesampler().desc().mipmapfilter());
                dawn_descriptor.lodMinClamp = command.devicecreatesampler().desc().lodminclamp();
                dawn_descriptor.lodMaxClamp = command.devicecreatesampler().desc().lodmaxclamp();
                dawn_descriptor.compare = static_cast<WGPUCompareFunction>(
                    command.devicecreatesampler().desc().compare());
                dawn_descriptor.maxAnisotropy =
                    command.devicecreatesampler().desc().maxanisotropy();
                // end structure WGPUSamplerDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::Sampler].size() > SAMPLER_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::Sampler].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateShaderModule: {
                DeviceCreateShaderModuleCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateShaderModuleCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Device].Get(
                    command.devicecreateshadermodule().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUShaderModuleDescriptor
                WGPUShaderModuleDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUShaderModuleDescriptor));

                // HARDCODED
                WGPUShaderModuleWGSLDescriptor wgsl_desc = {};
                wgsl_desc.chain.sType = WGPUSType_ShaderModuleWGSLDescriptor;
                wgsl_desc.source = "@group(0) @binding(0) \
                var<storage, read_write> output: array<f32>; \
                @compute @workgroup_size(64) \
                fn main( \
                    @builtin(global_invocation_id) global_id : vec3<u32>, \
                    @builtin(local_invocation_id) local_id : vec3<u32>, \
                ) { \
                output[global_id.x] = \
                    f32(global_id.x) * 1000. + f32(local_id.x); \
                }";
                dawn_descriptor.nextInChain = reinterpret_cast<WGPUChainedStruct*>(&wgsl_desc);

                // end structure WGPUShaderModuleDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::ShaderModule].size() > SHADER_MODULE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::ShaderModule].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateSwapChain: {
                DeviceCreateSwapChainCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateSwapChainCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicecreateswapchain().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                ObjectId cmd_surface_id = gObjectStores[ObjectType::Surface].Get(
                    command.devicecreateswapchain().surface());

                if (cmd_surface_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.surface = reinterpret_cast<WGPUSurface>(cmd_surface_id);
                // start structure WGPUSwapChainDescriptor
                WGPUSwapChainDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUSwapChainDescriptor));

                int bitmap_upper = command.devicecreateswapchain().desc().usage().size();
                for (int i = 0; i < bitmap_upper; i++) {
                    dawn_descriptor.usage |= static_cast<WGPUTextureUsage>(
                        command.devicecreateswapchain().desc().usage(i));
                }
                dawn_descriptor.format =
                    static_cast<WGPUTextureFormat>(command.devicecreateswapchain().desc().format());
                dawn_descriptor.width = command.devicecreateswapchain().desc().width();
                dawn_descriptor.height = command.devicecreateswapchain().desc().height();
                dawn_descriptor.presentMode = static_cast<WGPUPresentMode>(
                    command.devicecreateswapchain().desc().presentmode());
                dawn_descriptor.implementation =
                    command.devicecreateswapchain().desc().implementation();
                // end structure WGPUSwapChainDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::SwapChain].size() > SWAP_CHAIN_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::SwapChain].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceCreateTexture: {
                DeviceCreateTextureCmd cmd;
                memset(&cmd, 0, sizeof(DeviceCreateTextureCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicecreatetexture().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                // start structure WGPUTextureDescriptor
                WGPUTextureDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUTextureDescriptor));

                int bitmap_upper = command.devicecreatetexture().desc().usage().size();
                for (int i = 0; i < bitmap_upper; i++) {
                    dawn_descriptor.usage |= static_cast<WGPUTextureUsage>(
                        command.devicecreatetexture().desc().usage(i));
                }
                dawn_descriptor.dimension = static_cast<WGPUTextureDimension>(
                    command.devicecreatetexture().desc().dimension());
                // start structure WGPUExtent3D
                WGPUExtent3D dawn_descriptor_size;
                memset(&dawn_descriptor_size, 0, sizeof(struct WGPUExtent3D));

                dawn_descriptor_size.width = command.devicecreatetexture().desc().size().width();
                dawn_descriptor_size.height = command.devicecreatetexture().desc().size().height();
                dawn_descriptor_size.depthOrArrayLayers =
                    command.devicecreatetexture().desc().size().depthorarraylayers();
                // end structure WGPUExtent3D
                dawn_descriptor.size = dawn_descriptor_size;
                dawn_descriptor.format =
                    static_cast<WGPUTextureFormat>(command.devicecreatetexture().desc().format());
                dawn_descriptor.mipLevelCount =
                    command.devicecreatetexture().desc().miplevelcount();
                dawn_descriptor.sampleCount = command.devicecreatetexture().desc().samplecount();
                // start variable length WGPUTextureFormat[]
                size_t dawn_descriptorN_viewformats_size =
                    command.devicecreatetexture().desc().viewformats().size();
                std::unique_ptr<WGPUTextureFormat[]> dawn_descriptorN_viewformats(
                    new WGPUTextureFormat[dawn_descriptorN_viewformats_size]);
                for (size_t i = 0; i < dawn_descriptorN_viewformats_size; i++) {
                    dawn_descriptorN_viewformats[i] = static_cast<WGPUTextureFormat>(
                        command.devicecreatetexture().desc().viewformats(i));
                }

                dawn_descriptor.viewFormats = dawn_descriptorN_viewformats.get();
                dawn_descriptor.viewFormatCount =
                    command.devicecreatetexture().desc().viewformats().size();
                // end variablelength WGPUTextureFormat[]
                // end structure WGPUTextureDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::Texture].size() > TEXTURE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::Texture].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceDestroy: {
                DeviceDestroyCmd cmd;
                memset(&cmd, 0, sizeof(DeviceDestroyCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicedestroy().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceForceLoss: {
                DeviceForceLossCmd cmd;
                memset(&cmd, 0, sizeof(DeviceForceLossCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.deviceforceloss().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                cmd.type = static_cast<WGPUDeviceLostReason>(command.deviceforceloss().type());
                cmd.message = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceGetAdapter: {
                DeviceGetAdapterCmd cmd;
                memset(&cmd, 0, sizeof(DeviceGetAdapterCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicegetadapter().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                if (gObjectStores[ObjectType::Adapter].size() > ADAPTER_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::Adapter].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceGetQueue: {
                DeviceGetQueueCmd cmd;
                memset(&cmd, 0, sizeof(DeviceGetQueueCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicegetqueue().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                if (gObjectStores[ObjectType::Queue].size() > QUEUE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::Queue].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceInjectError: {
                DeviceInjectErrorCmd cmd;
                memset(&cmd, 0, sizeof(DeviceInjectErrorCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.deviceinjecterror().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                cmd.type = static_cast<WGPUErrorType>(command.deviceinjecterror().type());
                cmd.message = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDevicePopErrorScope: {
                DevicePopErrorScopeCmd cmd;
                memset(&cmd, 0, sizeof(DevicePopErrorScopeCmd));

                cmd.deviceId =
                    gObjectStores[ObjectType::Device].Get(command.devicepoperrorscope().deviceid());
                cmd.requestSerial = command.devicepoperrorscope().requestserial();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDevicePushErrorScope: {
                DevicePushErrorScopeCmd cmd;
                memset(&cmd, 0, sizeof(DevicePushErrorScopeCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicepusherrorscope().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                cmd.filter = static_cast<WGPUErrorFilter>(command.devicepusherrorscope().filter());
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceSetLabel: {
                DeviceSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(DeviceSetLabelCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicesetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kDeviceTick: {
                DeviceTickCmd cmd;
                memset(&cmd, 0, sizeof(DeviceTickCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Device].Get(command.devicetick().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUDevice>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kExternalTextureDestroy: {
                ExternalTextureDestroyCmd cmd;
                memset(&cmd, 0, sizeof(ExternalTextureDestroyCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ExternalTexture].Get(
                    command.externaltexturedestroy().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUExternalTexture>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kExternalTextureSetLabel: {
                ExternalTextureSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(ExternalTextureSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ExternalTexture].Get(
                    command.externaltexturesetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUExternalTexture>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kInstanceCreateSurface: {
                InstanceCreateSurfaceCmd cmd;
                memset(&cmd, 0, sizeof(InstanceCreateSurfaceCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Instance].Get(command.instancecreatesurface().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUInstance>(cmd_self_id);
                // start structure WGPUSurfaceDescriptor
                WGPUSurfaceDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUSurfaceDescriptor));

                // end structure WGPUSurfaceDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::Surface].size() > SURFACE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::Surface].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kInstanceRequestAdapter: {
                InstanceRequestAdapterCmd cmd;
                memset(&cmd, 0, sizeof(InstanceRequestAdapterCmd));

                cmd.instanceId = INSTANCE_OBJECT_ID;  // HARDCODE INSTANCE
                cmd.requestSerial = command.instancerequestadapter().requestserial();
                if (gObjectStores[ObjectType::Adapter].size() > ADAPTER_LIMIT) {
                    break;
                }
                cmd.adapterObjectHandle = gObjectStores[ObjectType::Adapter].ReserveHandle();
                // start structure WGPURequestAdapterOptions
                WGPURequestAdapterOptions dawn_options;
                memset(&dawn_options, 0, sizeof(struct WGPURequestAdapterOptions));

                ObjectId dawn_options_compatiblesurface_id = gObjectStores[ObjectType::Surface].Get(
                    command.instancerequestadapter().options().compatiblesurface());

                if (dawn_options_compatiblesurface_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_options.compatibleSurface =
                    reinterpret_cast<WGPUSurface>(dawn_options_compatiblesurface_id);
                dawn_options.powerPreference = static_cast<WGPUPowerPreference>(
                    command.instancerequestadapter().options().powerpreference());
                dawn_options.forceFallbackAdapter =
                    command.instancerequestadapter().options().forcefallbackadapter();
                // end structure WGPURequestAdapterOptions
                cmd.options = &dawn_options;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kPipelineLayoutSetLabel: {
                PipelineLayoutSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(PipelineLayoutSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::PipelineLayout].Get(
                    command.pipelinelayoutsetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUPipelineLayout>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kQuerySetDestroy: {
                QuerySetDestroyCmd cmd;
                memset(&cmd, 0, sizeof(QuerySetDestroyCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::QuerySet].Get(command.querysetdestroy().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUQuerySet>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kQuerySetSetLabel: {
                QuerySetSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(QuerySetSetLabelCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::QuerySet].Get(command.querysetsetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUQuerySet>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kQueueCopyTextureForBrowser: {
                QueueCopyTextureForBrowserCmd cmd;
                memset(&cmd, 0, sizeof(QueueCopyTextureForBrowserCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::Queue].Get(
                    command.queuecopytextureforbrowser().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUQueue>(cmd_self_id);
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_source;
                memset(&dawn_source, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_source_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.queuecopytextureforbrowser().source().texture());

                if (dawn_source_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_source.texture = reinterpret_cast<WGPUTexture>(dawn_source_texture_id);
                dawn_source.mipLevel = command.queuecopytextureforbrowser().source().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_source_origin;
                memset(&dawn_source_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_source_origin.x = command.queuecopytextureforbrowser().source().origin().x();
                dawn_source_origin.y = command.queuecopytextureforbrowser().source().origin().y();
                dawn_source_origin.z = command.queuecopytextureforbrowser().source().origin().z();
                // end structure WGPUOrigin3D
                dawn_source.origin = dawn_source_origin;
                dawn_source.aspect = static_cast<WGPUTextureAspect>(
                    command.queuecopytextureforbrowser().source().aspect());
                // end structure WGPUImageCopyTexture
                cmd.source = &dawn_source;
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_destination;
                memset(&dawn_destination, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_destination_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.queuecopytextureforbrowser().destination().texture());

                if (dawn_destination_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_destination.texture =
                    reinterpret_cast<WGPUTexture>(dawn_destination_texture_id);
                dawn_destination.mipLevel =
                    command.queuecopytextureforbrowser().destination().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_destination_origin;
                memset(&dawn_destination_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_destination_origin.x =
                    command.queuecopytextureforbrowser().destination().origin().x();
                dawn_destination_origin.y =
                    command.queuecopytextureforbrowser().destination().origin().y();
                dawn_destination_origin.z =
                    command.queuecopytextureforbrowser().destination().origin().z();
                // end structure WGPUOrigin3D
                dawn_destination.origin = dawn_destination_origin;
                dawn_destination.aspect = static_cast<WGPUTextureAspect>(
                    command.queuecopytextureforbrowser().destination().aspect());
                // end structure WGPUImageCopyTexture
                cmd.destination = &dawn_destination;
                // start structure WGPUExtent3D
                WGPUExtent3D dawn_copysize;
                memset(&dawn_copysize, 0, sizeof(struct WGPUExtent3D));

                dawn_copysize.width = command.queuecopytextureforbrowser().copysize().width();
                dawn_copysize.height = command.queuecopytextureforbrowser().copysize().height();
                dawn_copysize.depthOrArrayLayers =
                    command.queuecopytextureforbrowser().copysize().depthorarraylayers();
                // end structure WGPUExtent3D
                cmd.copySize = &dawn_copysize;
                // start structure WGPUCopyTextureForBrowserOptions
                WGPUCopyTextureForBrowserOptions dawn_options;
                memset(&dawn_options, 0, sizeof(struct WGPUCopyTextureForBrowserOptions));

                dawn_options.flipY = command.queuecopytextureforbrowser().options().flipy();
                dawn_options.needsColorSpaceConversion =
                    command.queuecopytextureforbrowser().options().needscolorspaceconversion();
                dawn_options.srcAlphaMode = static_cast<WGPUAlphaMode>(
                    command.queuecopytextureforbrowser().options().srcalphamode());

                // HARDCODED
                std::unique_ptr<float[]> dawn_srctransferfunctionparameters(new float[7]);
                dawn_options.srcTransferFunctionParameters =
                    dawn_srctransferfunctionparameters.get();

                std::unique_ptr<float[]> dawn_conversionmatrix(new float[9]);
                dawn_options.conversionMatrix = dawn_conversionmatrix.get();

                std::unique_ptr<float[]> dawn_dsttransferfunctionparameters(new float[7]);
                dawn_options.dstTransferFunctionParameters =
                    dawn_dsttransferfunctionparameters.get();

                dawn_options.dstAlphaMode = static_cast<WGPUAlphaMode>(
                    command.queuecopytextureforbrowser().options().dstalphamode());
                dawn_options.internalUsage =
                    command.queuecopytextureforbrowser().options().internalusage();
                // end structure WGPUCopyTextureForBrowserOptions
                cmd.options = &dawn_options;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kQueueOnSubmittedWorkDone: {
                QueueOnSubmittedWorkDoneCmd cmd;
                memset(&cmd, 0, sizeof(QueueOnSubmittedWorkDoneCmd));

                cmd.queueId = gObjectStores[ObjectType::Queue].Get(
                    command.queueonsubmittedworkdone().queueid());
                cmd.signalValue = command.queueonsubmittedworkdone().signalvalue();
                cmd.requestSerial = command.queueonsubmittedworkdone().requestserial();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kQueueSetLabel: {
                QueueSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(QueueSetLabelCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Queue].Get(command.queuesetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUQueue>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kQueueSubmit: {
                QueueSubmitCmd cmd;
                memset(&cmd, 0, sizeof(QueueSubmitCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Queue].Get(command.queuesubmit().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUQueue>(cmd_self_id);
                // start variable length WGPUCommandBuffer[]
                size_t cmdN_commands_size = command.queuesubmit().commands().size();
                std::unique_ptr<WGPUCommandBuffer[]> cmdN_commands(
                    new WGPUCommandBuffer[cmdN_commands_size]);
                for (size_t i = 0; i < cmdN_commands_size; i++) {
                    ObjectId cmd_commands_id = gObjectStores[ObjectType::CommandBuffer].Get(
                        command.queuesubmit().commands(i));

                    if (cmd_commands_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    cmdN_commands[i] = reinterpret_cast<WGPUCommandBuffer>(cmd_commands_id);
                }

                cmd.commands = cmdN_commands.get();
                cmd.commandCount = command.queuesubmit().commands().size();
                // end variablelength WGPUCommandBuffer[]
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kQueueWriteBuffer: {
                QueueWriteBufferCmd cmd;
                memset(&cmd, 0, sizeof(QueueWriteBufferCmd));

                cmd.queueId =
                    gObjectStores[ObjectType::Queue].Get(command.queuewritebuffer().queueid());
                cmd.bufferId =
                    gObjectStores[ObjectType::Buffer].Get(command.queuewritebuffer().bufferid());
                cmd.bufferOffset = command.queuewritebuffer().bufferoffset();
                // start variable length uint8_t[]
                size_t cmdN_data_size = command.queuewritebuffer().data().size();
                std::unique_ptr<uint8_t[]> cmdN_data(new uint8_t[cmdN_data_size]);
                for (size_t i = 0; i < cmdN_data_size; i++) {
                    cmdN_data[i] = static_cast<uint8_t>(command.queuewritebuffer().data()[i]);
                }

                cmd.data = cmdN_data.get();
                cmd.size = command.queuewritebuffer().data().size();
                // end variablelength uint8_t[]
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kQueueWriteTexture: {
                QueueWriteTextureCmd cmd;
                memset(&cmd, 0, sizeof(QueueWriteTextureCmd));

                cmd.queueId =
                    gObjectStores[ObjectType::Queue].Get(command.queuewritetexture().queueid());
                // start structure WGPUImageCopyTexture
                WGPUImageCopyTexture dawn_destination;
                memset(&dawn_destination, 0, sizeof(struct WGPUImageCopyTexture));

                ObjectId dawn_destination_texture_id = gObjectStores[ObjectType::Texture].Get(
                    command.queuewritetexture().destination().texture());

                if (dawn_destination_texture_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                dawn_destination.texture =
                    reinterpret_cast<WGPUTexture>(dawn_destination_texture_id);
                dawn_destination.mipLevel = command.queuewritetexture().destination().miplevel();
                // start structure WGPUOrigin3D
                WGPUOrigin3D dawn_destination_origin;
                memset(&dawn_destination_origin, 0, sizeof(struct WGPUOrigin3D));

                dawn_destination_origin.x = command.queuewritetexture().destination().origin().x();
                dawn_destination_origin.y = command.queuewritetexture().destination().origin().y();
                dawn_destination_origin.z = command.queuewritetexture().destination().origin().z();
                // end structure WGPUOrigin3D
                dawn_destination.origin = dawn_destination_origin;
                dawn_destination.aspect = static_cast<WGPUTextureAspect>(
                    command.queuewritetexture().destination().aspect());
                // end structure WGPUImageCopyTexture
                cmd.destination = &dawn_destination;
                // start variable length uint8_t[]
                size_t cmdN_data_size = command.queuewritetexture().data().size();
                std::unique_ptr<uint8_t[]> cmdN_data(new uint8_t[cmdN_data_size]);
                for (size_t i = 0; i < cmdN_data_size; i++) {
                    cmdN_data[i] = static_cast<uint8_t>(command.queuewritetexture().data()[i]);
                }

                cmd.data = cmdN_data.get();
                cmd.dataSize = command.queuewritetexture().data().size();
                // end variablelength uint8_t[]
                // start structure WGPUTextureDataLayout
                WGPUTextureDataLayout dawn_datalayout;
                memset(&dawn_datalayout, 0, sizeof(struct WGPUTextureDataLayout));

                dawn_datalayout.offset = command.queuewritetexture().datalayout().offset();
                dawn_datalayout.bytesPerRow =
                    command.queuewritetexture().datalayout().bytesperrow();
                dawn_datalayout.rowsPerImage =
                    command.queuewritetexture().datalayout().rowsperimage();
                // end structure WGPUTextureDataLayout
                cmd.dataLayout = &dawn_datalayout;
                // start structure WGPUExtent3D
                WGPUExtent3D dawn_writeSize;
                memset(&dawn_writeSize, 0, sizeof(struct WGPUExtent3D));

                dawn_writeSize.width = command.queuewritetexture().writesize().width();
                dawn_writeSize.height = command.queuewritetexture().writesize().height();
                dawn_writeSize.depthOrArrayLayers =
                    command.queuewritetexture().writesize().depthorarraylayers();
                // end structure WGPUExtent3D
                cmd.writeSize = &dawn_writeSize;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderDraw: {
                RenderBundleEncoderDrawCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderDrawCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencoderdraw().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                cmd.vertexCount = command.renderbundleencoderdraw().vertexcount();
                cmd.instanceCount = command.renderbundleencoderdraw().instancecount();
                cmd.firstVertex = command.renderbundleencoderdraw().firstvertex();
                cmd.firstInstance = command.renderbundleencoderdraw().firstinstance();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderDrawIndexed: {
                RenderBundleEncoderDrawIndexedCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderDrawIndexedCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencoderdrawindexed().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                cmd.indexCount = command.renderbundleencoderdrawindexed().indexcount();
                cmd.instanceCount = command.renderbundleencoderdrawindexed().instancecount();
                cmd.firstIndex = command.renderbundleencoderdrawindexed().firstindex();
                cmd.baseVertex = command.renderbundleencoderdrawindexed().basevertex();
                cmd.firstInstance = command.renderbundleencoderdrawindexed().firstinstance();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderDrawIndexedIndirect: {
                RenderBundleEncoderDrawIndexedIndirectCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderDrawIndexedIndirectCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencoderdrawindexedindirect().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                ObjectId cmd_indirectbuffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.renderbundleencoderdrawindexedindirect().indirectbuffer());

                if (cmd_indirectbuffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.indirectBuffer = reinterpret_cast<WGPUBuffer>(cmd_indirectbuffer_id);
                cmd.indirectOffset =
                    command.renderbundleencoderdrawindexedindirect().indirectoffset();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderDrawIndirect: {
                RenderBundleEncoderDrawIndirectCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderDrawIndirectCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencoderdrawindirect().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                ObjectId cmd_indirectbuffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.renderbundleencoderdrawindirect().indirectbuffer());

                if (cmd_indirectbuffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.indirectBuffer = reinterpret_cast<WGPUBuffer>(cmd_indirectbuffer_id);
                cmd.indirectOffset = command.renderbundleencoderdrawindirect().indirectoffset();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderFinish: {
                RenderBundleEncoderFinishCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderFinishCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencoderfinish().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                // start structure WGPURenderBundleDescriptor
                WGPURenderBundleDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPURenderBundleDescriptor));

                // end structure WGPURenderBundleDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::RenderBundle].size() > RENDER_BUNDLE_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::RenderBundle].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderInsertDebugMarker: {
                RenderBundleEncoderInsertDebugMarkerCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderInsertDebugMarkerCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencoderinsertdebugmarker().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                cmd.markerLabel = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderPopDebugGroup: {
                RenderBundleEncoderPopDebugGroupCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderPopDebugGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencoderpopdebuggroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderPushDebugGroup: {
                RenderBundleEncoderPushDebugGroupCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderPushDebugGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencoderpushdebuggroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                cmd.groupLabel = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderSetBindGroup: {
                RenderBundleEncoderSetBindGroupCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderSetBindGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencodersetbindgroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                cmd.groupIndex = command.renderbundleencodersetbindgroup().groupindex();
                ObjectId cmd_group_id = gObjectStores[ObjectType::BindGroup].Get(
                    command.renderbundleencodersetbindgroup().group());

                if (cmd_group_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.group = reinterpret_cast<WGPUBindGroup>(cmd_group_id);
                // start variable length uint32_t[]
                size_t cmdN_dynamicoffsets_size =
                    command.renderbundleencodersetbindgroup().dynamicoffsets().size();
                std::unique_ptr<uint32_t[]> cmdN_dynamicoffsets(
                    new uint32_t[cmdN_dynamicoffsets_size]);
                for (size_t i = 0; i < cmdN_dynamicoffsets_size; i++) {
                    cmdN_dynamicoffsets[i] = static_cast<uint32_t>(
                        command.renderbundleencodersetbindgroup().dynamicoffsets(i));
                }

                cmd.dynamicOffsets = cmdN_dynamicoffsets.get();
                cmd.dynamicOffsetCount =
                    command.renderbundleencodersetbindgroup().dynamicoffsets().size();
                // end variablelength uint32_t[]
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderSetIndexBuffer: {
                RenderBundleEncoderSetIndexBufferCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderSetIndexBufferCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencodersetindexbuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                ObjectId cmd_buffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.renderbundleencodersetindexbuffer().buffer());

                if (cmd_buffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.buffer = reinterpret_cast<WGPUBuffer>(cmd_buffer_id);
                cmd.format = static_cast<WGPUIndexFormat>(
                    command.renderbundleencodersetindexbuffer().format());
                cmd.offset = command.renderbundleencodersetindexbuffer().offset();
                cmd.size = command.renderbundleencodersetindexbuffer().size();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderSetLabel: {
                RenderBundleEncoderSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencodersetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderSetPipeline: {
                RenderBundleEncoderSetPipelineCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderSetPipelineCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencodersetpipeline().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                ObjectId cmd_pipeline_id = gObjectStores[ObjectType::RenderPipeline].Get(
                    command.renderbundleencodersetpipeline().pipeline());

                if (cmd_pipeline_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.pipeline = reinterpret_cast<WGPURenderPipeline>(cmd_pipeline_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderBundleEncoderSetVertexBuffer: {
                RenderBundleEncoderSetVertexBufferCmd cmd;
                memset(&cmd, 0, sizeof(RenderBundleEncoderSetVertexBufferCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderBundleEncoder].Get(
                    command.renderbundleencodersetvertexbuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderBundleEncoder>(cmd_self_id);
                cmd.slot = command.renderbundleencodersetvertexbuffer().slot();
                ObjectId cmd_buffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.renderbundleencodersetvertexbuffer().buffer());

                if (cmd_buffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.buffer = reinterpret_cast<WGPUBuffer>(cmd_buffer_id);
                cmd.offset = command.renderbundleencodersetvertexbuffer().offset();
                cmd.size = command.renderbundleencodersetvertexbuffer().size();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderBeginOcclusionQuery: {
                RenderPassEncoderBeginOcclusionQueryCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderBeginOcclusionQueryCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderbeginocclusionquery().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.queryIndex = command.renderpassencoderbeginocclusionquery().queryindex();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderDraw: {
                RenderPassEncoderDrawCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderDrawCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderdraw().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.vertexCount = command.renderpassencoderdraw().vertexcount();
                cmd.instanceCount = command.renderpassencoderdraw().instancecount();
                cmd.firstVertex = command.renderpassencoderdraw().firstvertex();
                cmd.firstInstance = command.renderpassencoderdraw().firstinstance();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderDrawIndexed: {
                RenderPassEncoderDrawIndexedCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderDrawIndexedCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderdrawindexed().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.indexCount = command.renderpassencoderdrawindexed().indexcount();
                cmd.instanceCount = command.renderpassencoderdrawindexed().instancecount();
                cmd.firstIndex = command.renderpassencoderdrawindexed().firstindex();
                cmd.baseVertex = command.renderpassencoderdrawindexed().basevertex();
                cmd.firstInstance = command.renderpassencoderdrawindexed().firstinstance();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderDrawIndexedIndirect: {
                RenderPassEncoderDrawIndexedIndirectCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderDrawIndexedIndirectCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderdrawindexedindirect().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                ObjectId cmd_indirectbuffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.renderpassencoderdrawindexedindirect().indirectbuffer());

                if (cmd_indirectbuffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.indirectBuffer = reinterpret_cast<WGPUBuffer>(cmd_indirectbuffer_id);
                cmd.indirectOffset =
                    command.renderpassencoderdrawindexedindirect().indirectoffset();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderDrawIndirect: {
                RenderPassEncoderDrawIndirectCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderDrawIndirectCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderdrawindirect().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                ObjectId cmd_indirectbuffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.renderpassencoderdrawindirect().indirectbuffer());

                if (cmd_indirectbuffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.indirectBuffer = reinterpret_cast<WGPUBuffer>(cmd_indirectbuffer_id);
                cmd.indirectOffset = command.renderpassencoderdrawindirect().indirectoffset();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderEnd: {
                RenderPassEncoderEndCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderEndCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderend().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderEndOcclusionQuery: {
                RenderPassEncoderEndOcclusionQueryCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderEndOcclusionQueryCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderendocclusionquery().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderEndPass: {
                RenderPassEncoderEndPassCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderEndPassCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderendpass().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderExecuteBundles: {
                RenderPassEncoderExecuteBundlesCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderExecuteBundlesCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderexecutebundles().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                // start variable length WGPURenderBundle[]
                size_t cmdN_bundles_size =
                    command.renderpassencoderexecutebundles().bundles().size();
                std::unique_ptr<WGPURenderBundle[]> cmdN_bundles(
                    new WGPURenderBundle[cmdN_bundles_size]);
                for (size_t i = 0; i < cmdN_bundles_size; i++) {
                    ObjectId cmd_bundles_id = gObjectStores[ObjectType::RenderBundle].Get(
                        command.renderpassencoderexecutebundles().bundles(i));

                    if (cmd_bundles_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                        break;
                    }

                    cmdN_bundles[i] = reinterpret_cast<WGPURenderBundle>(cmd_bundles_id);
                }

                cmd.bundles = cmdN_bundles.get();
                cmd.bundleCount = command.renderpassencoderexecutebundles().bundles().size();
                // end variablelength WGPURenderBundle[]
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderInsertDebugMarker: {
                RenderPassEncoderInsertDebugMarkerCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderInsertDebugMarkerCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderinsertdebugmarker().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.markerLabel = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderPopDebugGroup: {
                RenderPassEncoderPopDebugGroupCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderPopDebugGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderpopdebuggroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderPushDebugGroup: {
                RenderPassEncoderPushDebugGroupCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderPushDebugGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderpushdebuggroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.groupLabel = "main";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetBindGroup: {
                RenderPassEncoderSetBindGroupCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetBindGroupCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetbindgroup().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.groupIndex = command.renderpassencodersetbindgroup().groupindex();
                ObjectId cmd_group_id = gObjectStores[ObjectType::BindGroup].Get(
                    command.renderpassencodersetbindgroup().group());

                if (cmd_group_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.group = reinterpret_cast<WGPUBindGroup>(cmd_group_id);
                // start variable length uint32_t[]
                size_t cmdN_dynamicoffsets_size =
                    command.renderpassencodersetbindgroup().dynamicoffsets().size();
                std::unique_ptr<uint32_t[]> cmdN_dynamicoffsets(
                    new uint32_t[cmdN_dynamicoffsets_size]);
                for (size_t i = 0; i < cmdN_dynamicoffsets_size; i++) {
                    cmdN_dynamicoffsets[i] = static_cast<uint32_t>(
                        command.renderpassencodersetbindgroup().dynamicoffsets(i));
                }

                cmd.dynamicOffsets = cmdN_dynamicoffsets.get();
                cmd.dynamicOffsetCount =
                    command.renderpassencodersetbindgroup().dynamicoffsets().size();
                // end variablelength uint32_t[]
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetBlendConstant: {
                RenderPassEncoderSetBlendConstantCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetBlendConstantCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetblendconstant().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                // start structure WGPUColor
                WGPUColor dawn_color;
                memset(&dawn_color, 0, sizeof(struct WGPUColor));

                dawn_color.r = command.renderpassencodersetblendconstant().color().r();
                dawn_color.g = command.renderpassencodersetblendconstant().color().g();
                dawn_color.b = command.renderpassencodersetblendconstant().color().b();
                dawn_color.a = command.renderpassencodersetblendconstant().color().a();
                // end structure WGPUColor
                cmd.color = &dawn_color;
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetIndexBuffer: {
                RenderPassEncoderSetIndexBufferCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetIndexBufferCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetindexbuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                ObjectId cmd_buffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.renderpassencodersetindexbuffer().buffer());

                if (cmd_buffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.buffer = reinterpret_cast<WGPUBuffer>(cmd_buffer_id);
                cmd.format = static_cast<WGPUIndexFormat>(
                    command.renderpassencodersetindexbuffer().format());
                cmd.offset = command.renderpassencodersetindexbuffer().offset();
                cmd.size = command.renderpassencodersetindexbuffer().size();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetLabel: {
                RenderPassEncoderSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetPipeline: {
                RenderPassEncoderSetPipelineCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetPipelineCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetpipeline().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                ObjectId cmd_pipeline_id = gObjectStores[ObjectType::RenderPipeline].Get(
                    command.renderpassencodersetpipeline().pipeline());

                if (cmd_pipeline_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.pipeline = reinterpret_cast<WGPURenderPipeline>(cmd_pipeline_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetScissorRect: {
                RenderPassEncoderSetScissorRectCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetScissorRectCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetscissorrect().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.x = command.renderpassencodersetscissorrect().x();
                cmd.y = command.renderpassencodersetscissorrect().y();
                cmd.width = command.renderpassencodersetscissorrect().width();
                cmd.height = command.renderpassencodersetscissorrect().height();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetStencilReference: {
                RenderPassEncoderSetStencilReferenceCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetStencilReferenceCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetstencilreference().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.reference = command.renderpassencodersetstencilreference().reference();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetVertexBuffer: {
                RenderPassEncoderSetVertexBufferCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetVertexBufferCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetvertexbuffer().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.slot = command.renderpassencodersetvertexbuffer().slot();
                ObjectId cmd_buffer_id = gObjectStores[ObjectType::Buffer].Get(
                    command.renderpassencodersetvertexbuffer().buffer());

                if (cmd_buffer_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.buffer = reinterpret_cast<WGPUBuffer>(cmd_buffer_id);
                cmd.offset = command.renderpassencodersetvertexbuffer().offset();
                cmd.size = command.renderpassencodersetvertexbuffer().size();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderSetViewport: {
                RenderPassEncoderSetViewportCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderSetViewportCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencodersetviewport().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                cmd.x = command.renderpassencodersetviewport().x();
                cmd.y = command.renderpassencodersetviewport().y();
                cmd.width = command.renderpassencodersetviewport().width();
                cmd.height = command.renderpassencodersetviewport().height();
                cmd.minDepth = command.renderpassencodersetviewport().mindepth();
                cmd.maxDepth = command.renderpassencodersetviewport().maxdepth();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPassEncoderWriteTimestamp: {
                RenderPassEncoderWriteTimestampCmd cmd;
                memset(&cmd, 0, sizeof(RenderPassEncoderWriteTimestampCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPassEncoder].Get(
                    command.renderpassencoderwritetimestamp().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPassEncoder>(cmd_self_id);
                ObjectId cmd_queryset_id = gObjectStores[ObjectType::QuerySet].Get(
                    command.renderpassencoderwritetimestamp().queryset());

                if (cmd_queryset_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.querySet = reinterpret_cast<WGPUQuerySet>(cmd_queryset_id);
                cmd.queryIndex = command.renderpassencoderwritetimestamp().queryindex();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPipelineGetBindGroupLayout: {
                RenderPipelineGetBindGroupLayoutCmd cmd;
                memset(&cmd, 0, sizeof(RenderPipelineGetBindGroupLayoutCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPipeline].Get(
                    command.renderpipelinegetbindgrouplayout().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPipeline>(cmd_self_id);
                cmd.groupIndex = command.renderpipelinegetbindgrouplayout().groupindex();
                if (gObjectStores[ObjectType::BindGroupLayout].size() > BIND_GROUP_LAYOUT_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::BindGroupLayout].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kRenderPipelineSetLabel: {
                RenderPipelineSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(RenderPipelineSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::RenderPipeline].Get(
                    command.renderpipelinesetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPURenderPipeline>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kSamplerSetLabel: {
                SamplerSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(SamplerSetLabelCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Sampler].Get(command.samplersetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUSampler>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kShaderModuleGetCompilationInfo: {
                ShaderModuleGetCompilationInfoCmd cmd;
                memset(&cmd, 0, sizeof(ShaderModuleGetCompilationInfoCmd));

                cmd.shaderModuleId = gObjectStores[ObjectType::ShaderModule].Get(
                    command.shadermodulegetcompilationinfo().shadermoduleid());
                cmd.requestSerial = command.shadermodulegetcompilationinfo().requestserial();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kShaderModuleSetLabel: {
                ShaderModuleSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(ShaderModuleSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::ShaderModule].Get(
                    command.shadermodulesetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUShaderModule>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kSwapChainConfigure: {
                SwapChainConfigureCmd cmd;
                memset(&cmd, 0, sizeof(SwapChainConfigureCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::SwapChain].Get(command.swapchainconfigure().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUSwapChain>(cmd_self_id);
                cmd.format = static_cast<WGPUTextureFormat>(command.swapchainconfigure().format());

                int bitmap_upper = command.swapchainconfigure().allowedusage().size();
                for (int i = 0; i < bitmap_upper; i++) {
                    cmd.allowedUsage |=
                        static_cast<WGPUTextureUsage>(command.swapchainconfigure().allowedusage(i));
                }
                cmd.width = command.swapchainconfigure().width();
                cmd.height = command.swapchainconfigure().height();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kSwapChainGetCurrentTextureView: {
                SwapChainGetCurrentTextureViewCmd cmd;
                memset(&cmd, 0, sizeof(SwapChainGetCurrentTextureViewCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::SwapChain].Get(
                    command.swapchaingetcurrenttextureview().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUSwapChain>(cmd_self_id);
                if (gObjectStores[ObjectType::TextureView].size() > TEXTURE_VIEW_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::TextureView].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kSwapChainPresent: {
                SwapChainPresentCmd cmd;
                memset(&cmd, 0, sizeof(SwapChainPresentCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::SwapChain].Get(command.swapchainpresent().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUSwapChain>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kTextureCreateView: {
                TextureCreateViewCmd cmd;
                memset(&cmd, 0, sizeof(TextureCreateViewCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Texture].Get(command.texturecreateview().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUTexture>(cmd_self_id);
                // start structure WGPUTextureViewDescriptor
                WGPUTextureViewDescriptor dawn_descriptor;
                memset(&dawn_descriptor, 0, sizeof(struct WGPUTextureViewDescriptor));

                dawn_descriptor.format =
                    static_cast<WGPUTextureFormat>(command.texturecreateview().desc().format());
                dawn_descriptor.dimension = static_cast<WGPUTextureViewDimension>(
                    command.texturecreateview().desc().dimension());
                dawn_descriptor.baseMipLevel = command.texturecreateview().desc().basemiplevel();
                dawn_descriptor.mipLevelCount = command.texturecreateview().desc().miplevelcount();
                dawn_descriptor.baseArrayLayer =
                    command.texturecreateview().desc().basearraylayer();
                dawn_descriptor.arrayLayerCount =
                    command.texturecreateview().desc().arraylayercount();
                dawn_descriptor.aspect =
                    static_cast<WGPUTextureAspect>(command.texturecreateview().desc().aspect());
                // end structure WGPUTextureViewDescriptor
                cmd.descriptor = &dawn_descriptor;
                if (gObjectStores[ObjectType::TextureView].size() > TEXTURE_VIEW_LIMIT) {
                    break;
                }
                cmd.result = gObjectStores[ObjectType::TextureView].ReserveHandle();
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kTextureDestroy: {
                TextureDestroyCmd cmd;
                memset(&cmd, 0, sizeof(TextureDestroyCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Texture].Get(command.texturedestroy().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUTexture>(cmd_self_id);
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kTextureSetLabel: {
                TextureSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(TextureSetLabelCmd));

                ObjectId cmd_self_id =
                    gObjectStores[ObjectType::Texture].Get(command.texturesetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUTexture>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            case fuzzing::Command::kTextureViewSetLabel: {
                TextureViewSetLabelCmd cmd;
                memset(&cmd, 0, sizeof(TextureViewSetLabelCmd));

                ObjectId cmd_self_id = gObjectStores[ObjectType::TextureView].Get(
                    command.textureviewsetlabel().self());

                if (cmd_self_id == static_cast<ObjectId>(INVALID_OBJECTID)) {
                    break;
                }

                cmd.self = reinterpret_cast<WGPUTextureView>(cmd_self_id);
                cmd.label = "label";
                serializer.SerializeCommand(cmd, provider);
                break;
            }
            default: {
                break;
            }
        }
    }
}  // NOLINT(readability/fn_size) manually unrolled autogen

}  // namespace dawn::wire
