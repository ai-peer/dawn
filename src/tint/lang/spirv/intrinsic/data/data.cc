// Copyright 2023 The Tint Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

////////////////////////////////////////////////////////////////////////////////
// File generated by 'tools/src/cmd/gen' using the template:
//   src/tint/lang/spirv/intrinsic/data/data.cc.tmpl
//
// To regenerate run: './tools/run gen'
//
//                       Do not modify this file directly
////////////////////////////////////////////////////////////////////////////////

#include <limits>
#include <string>

#include "src/tint/lang/core/intrinsic/data/type_matchers.h"
#include "src/tint/lang/spirv/intrinsic/data/data.h"
#include "src/tint/utils/text/string_stream.h"

namespace tint::spirv::intrinsic::data {

using namespace tint::core::intrinsic::data;  // NOLINT(build/namespaces)

namespace {

using ConstEvalFunctionIndex = tint::core::intrinsic::ConstEvalFunctionIndex;
using IntrinsicInfo = tint::core::intrinsic::IntrinsicInfo;
using MatchState = tint::core::intrinsic::MatchState;
using Number = tint::core::intrinsic::Number;
using NumberMatcher = tint::core::intrinsic::NumberMatcher;
using NumberMatcherIndex = tint::core::intrinsic::NumberMatcherIndex;
using NumberMatcherIndicesIndex = tint::core::intrinsic::NumberMatcherIndicesIndex;
using OverloadFlag = tint::core::intrinsic::OverloadFlag;
using OverloadFlags = tint::core::intrinsic::OverloadFlags;
using OverloadIndex = tint::core::intrinsic::OverloadIndex;
using OverloadInfo = tint::core::intrinsic::OverloadInfo;
using ParameterIndex = tint::core::intrinsic::ParameterIndex;
using ParameterInfo = tint::core::intrinsic::ParameterInfo;
using StringStream = tint::StringStream;
using TemplateNumberIndex = tint::core::intrinsic::TemplateNumberIndex;
using TemplateNumberInfo = tint::core::intrinsic::TemplateNumberInfo;
using TemplateTypeIndex = tint::core::intrinsic::TemplateTypeIndex;
using TemplateTypeInfo = tint::core::intrinsic::TemplateTypeInfo;
using Type = tint::core::type::Type;
using TypeMatcher = tint::core::intrinsic::TypeMatcher;
using TypeMatcherIndex = tint::core::intrinsic::TypeMatcherIndex;
using TypeMatcherIndicesIndex = tint::core::intrinsic::TypeMatcherIndicesIndex;

template <size_t N>
using TemplateNumberMatcher = tint::core::intrinsic::TemplateNumberMatcher<N>;

template <size_t N>
using TemplateTypeMatcher = tint::core::intrinsic::TemplateTypeMatcher<N>;

// clang-format off

/// TypeMatcher for 'type f32'
constexpr TypeMatcher kF32Matcher {
/* match */ [](MatchState& state, const Type* ty) -> const Type* {
    if (!MatchF32(state, ty)) {
      return nullptr;
    }
    return BuildF32(state);
  },
/* string */ [](MatchState*) -> std::string {
    return "f32";
  }
};


/// TypeMatcher for 'type f16'
constexpr TypeMatcher kF16Matcher {
/* match */ [](MatchState& state, const Type* ty) -> const Type* {
    if (!MatchF16(state, ty)) {
      return nullptr;
    }
    return BuildF16(state);
  },
/* string */ [](MatchState*) -> std::string {
    return "f16";
  }
};


/// TypeMatcher for 'type vec2'
constexpr TypeMatcher kVec2Matcher {
/* match */ [](MatchState& state, const Type* ty) -> const Type* {
  const Type* T = nullptr;
    if (!MatchVec2(state, ty, T)) {
      return nullptr;
    }
    T = state.Type(T);
    if (T == nullptr) {
      return nullptr;
    }
    return BuildVec2(state, T);
  },
/* string */ [](MatchState* state) -> std::string {
  const std::string T = state->TypeName();
    return "vec2<" + T + ">";
  }
};


/// TypeMatcher for 'type vec3'
constexpr TypeMatcher kVec3Matcher {
/* match */ [](MatchState& state, const Type* ty) -> const Type* {
  const Type* T = nullptr;
    if (!MatchVec3(state, ty, T)) {
      return nullptr;
    }
    T = state.Type(T);
    if (T == nullptr) {
      return nullptr;
    }
    return BuildVec3(state, T);
  },
/* string */ [](MatchState* state) -> std::string {
  const std::string T = state->TypeName();
    return "vec3<" + T + ">";
  }
};


/// TypeMatcher for 'type vec4'
constexpr TypeMatcher kVec4Matcher {
/* match */ [](MatchState& state, const Type* ty) -> const Type* {
  const Type* T = nullptr;
    if (!MatchVec4(state, ty, T)) {
      return nullptr;
    }
    T = state.Type(T);
    if (T == nullptr) {
      return nullptr;
    }
    return BuildVec4(state, T);
  },
/* string */ [](MatchState* state) -> std::string {
  const std::string T = state->TypeName();
    return "vec4<" + T + ">";
  }
};


/// TypeMatcher for 'type vec'
constexpr TypeMatcher kVecMatcher {
/* match */ [](MatchState& state, const Type* ty) -> const Type* {
  Number N = Number::invalid;
  const Type* T = nullptr;
    if (!MatchVec(state, ty, N, T)) {
      return nullptr;
    }
    N = state.Num(N);
    if (!N.IsValid()) {
      return nullptr;
    }
    T = state.Type(T);
    if (T == nullptr) {
      return nullptr;
    }
    return BuildVec(state, N, T);
  },
/* string */ [](MatchState* state) -> std::string {
  const std::string N = state->NumName();
  const std::string T = state->TypeName();
    StringStream ss;
    ss << "vec" << N << "<" << T << ">";
    return ss.str();
  }
};


/// TypeMatcher for 'match f32_f16'
constexpr TypeMatcher kF32F16Matcher {
/* match */ [](MatchState& state, const Type* ty) -> const Type* {
    if (MatchF32(state, ty)) {
      return BuildF32(state);
    }
    if (MatchF16(state, ty)) {
      return BuildF16(state);
    }
    return nullptr;
  },
/* string */ [](MatchState*) -> std::string {
    StringStream ss;
    // Note: We pass nullptr to the TypeMatcher::String() functions, as 'matcher's do not support
    // template arguments, nor can they match sub-types. As such, they have no use for the MatchState.
    ss << kF32Matcher.string(nullptr) << " or " << kF16Matcher.string(nullptr);
    return ss.str();
  }
};

/// Type and number matchers

/// The template types, types, and type matchers
constexpr TypeMatcher kTypeMatchers[] = {
  /* [0] */ TemplateTypeMatcher<0>::matcher,
  /* [1] */ kF32Matcher,
  /* [2] */ kF16Matcher,
  /* [3] */ kVec2Matcher,
  /* [4] */ kVec3Matcher,
  /* [5] */ kVec4Matcher,
  /* [6] */ kVecMatcher,
  /* [7] */ kF32F16Matcher,
};

/// The template numbers, and number matchers
constexpr NumberMatcher kNumberMatchers[] = {
  /* [0] */ TemplateNumberMatcher<0>::matcher,
};

constexpr TypeMatcherIndex kTypeMatcherIndices[] = {
  /* [0] */ TypeMatcherIndex(6),
  /* [1] */ TypeMatcherIndex(0),
};

static_assert(TypeMatcherIndex::CanIndex(kTypeMatcherIndices),
              "TypeMatcherIndex is not large enough to index kTypeMatcherIndices");

constexpr NumberMatcherIndex kNumberMatcherIndices[] = {
  /* [0] */ NumberMatcherIndex(0),
};

static_assert(NumberMatcherIndex::CanIndex(kNumberMatcherIndices),
              "NumberMatcherIndex is not large enough to index kNumberMatcherIndices");

constexpr ParameterInfo kParameters[] = {
  {
    /* [0] */
    /* usage */ core::ParameterUsage::kNone,
    /* type_matcher_indices */ TypeMatcherIndicesIndex(0),
    /* number_matcher_indices */ NumberMatcherIndicesIndex(0),
  },
  {
    /* [1] */
    /* usage */ core::ParameterUsage::kNone,
    /* type_matcher_indices */ TypeMatcherIndicesIndex(1),
    /* number_matcher_indices */ NumberMatcherIndicesIndex(/* invalid */),
  },
};

static_assert(ParameterIndex::CanIndex(kParameters),
              "ParameterIndex is not large enough to index kParameters");

constexpr TemplateTypeInfo kTemplateTypes[] = {
  {
    /* [0] */
    /* name */ "T",
    /* matcher_index */ TypeMatcherIndex(7),
  },
};

static_assert(TemplateTypeIndex::CanIndex(kTemplateTypes),
              "TemplateTypeIndex is not large enough to index kTemplateTypes");

constexpr TemplateNumberInfo kTemplateNumbers[] = {
  {
    /* [0] */
    /* name */ "N",
    /* matcher_index */ NumberMatcherIndex(/* invalid */),
  },
};

static_assert(TemplateNumberIndex::CanIndex(kTemplateNumbers),
              "TemplateNumberIndex is not large enough to index kTemplateNumbers");

constexpr OverloadInfo kOverloads[] = {
  {
    /* [0] */
    /* flags */ OverloadFlags(OverloadFlag::kIsBuiltin, OverloadFlag::kSupportsVertexPipeline, OverloadFlag::kSupportsFragmentPipeline, OverloadFlag::kSupportsComputePipeline),
    /* num_parameters */ 2,
    /* num_template_types */ 1,
    /* num_template_numbers */ 1,
    /* template_types */ TemplateTypeIndex(0),
    /* template_numbers */ TemplateNumberIndex(0),
    /* parameters */ ParameterIndex(0),
    /* return_type_matcher_indices */ TypeMatcherIndicesIndex(0),
    /* return_number_matcher_indices */ NumberMatcherIndicesIndex(0),
    /* const_eval_fn */ ConstEvalFunctionIndex(/* invalid */),
  },
};

static_assert(OverloadIndex::CanIndex(kOverloads),
              "OverloadIndex is not large enough to index kOverloads");

constexpr IntrinsicInfo kBuiltins[] = {
  {
    /* [0] */
    /* fn vector_times_scalar<T : f32_f16, N : num>(vec<N, T>, T) -> vec<N, T> */
    /* num overloads */ 1,
    /* overloads */ OverloadIndex(0),
  },
};

// clang-format on

}  // anonymous namespace

const core::intrinsic::TableData kData{
    /* template_types */ kTemplateTypes,
    /* template_numbers */ kTemplateNumbers,
    /* type_matcher_indices */ kTypeMatcherIndices,
    /* number_matcher_indices */ kNumberMatcherIndices,
    /* type_matchers */ kTypeMatchers,
    /* number_matchers */ kNumberMatchers,
    /* parameters */ kParameters,
    /* overloads */ kOverloads,
    /* const_eval_functions */ Empty,
    /* ctor_conv */ Empty,
    /* builtins */ kBuiltins,
    /* binary '+' */ tint::core::intrinsic::kNoOverloads,
    /* binary '-' */ tint::core::intrinsic::kNoOverloads,
    /* binary '*' */ tint::core::intrinsic::kNoOverloads,
    /* binary '/' */ tint::core::intrinsic::kNoOverloads,
    /* binary '%' */ tint::core::intrinsic::kNoOverloads,
    /* binary '^' */ tint::core::intrinsic::kNoOverloads,
    /* binary '&' */ tint::core::intrinsic::kNoOverloads,
    /* binary '|' */ tint::core::intrinsic::kNoOverloads,
    /* binary '&&' */ tint::core::intrinsic::kNoOverloads,
    /* binary '||' */ tint::core::intrinsic::kNoOverloads,
    /* binary '==' */ tint::core::intrinsic::kNoOverloads,
    /* binary '!=' */ tint::core::intrinsic::kNoOverloads,
    /* binary '<' */ tint::core::intrinsic::kNoOverloads,
    /* binary '>' */ tint::core::intrinsic::kNoOverloads,
    /* binary '<=' */ tint::core::intrinsic::kNoOverloads,
    /* binary '>=' */ tint::core::intrinsic::kNoOverloads,
    /* binary '<<' */ tint::core::intrinsic::kNoOverloads,
    /* binary '>>' */ tint::core::intrinsic::kNoOverloads,
    /* unary '!' */ tint::core::intrinsic::kNoOverloads,
    /* unary '~' */ tint::core::intrinsic::kNoOverloads,
    /* unary '-' */ tint::core::intrinsic::kNoOverloads,
};

}  // namespace tint::spirv::intrinsic::data
