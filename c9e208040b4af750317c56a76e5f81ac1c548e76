{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b9fa36f4_accfecda",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-12T03:07:15Z",
      "side": 1,
      "message": "PTAL\n\nI am not exactly sure about the correctness of CL theoretically. But the performance gain seems rather appealing. For the 7x7 Google meet sample(https://source.chromium.org/chromium/chromium/src/+/main:content/test/data/gpu/vc/webgpu_videos_mxn.html;l\u003d1?q\u003dwebgpu_videos\u0026sq\u003d\u0026ss\u003dchromium), the GPU usage can drop from 35% to 21% on my ADL ChromeOS device. I would really appreciate your perspective on this, Thanks!",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9d364bd3_6d607e59",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-12T03:14:59Z",
      "side": 1,
      "message": "The corresponding change required at chromium side is https://chromium-review.googlesource.com/c/chromium/src/+/3756645.",
      "parentUuid": "b9fa36f4_accfecda",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7d15f122_8f21bb26",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-12T12:41:09Z",
      "side": 1,
      "message": "The perf difference is impressive and it is totally worth looking at optimizing this. However I don\u0027t think this CL is correct because if the user of Dawn starts reusing the SharedImage then we didn\u0027t make a memory barrier that prevents read from Dawn from happening after the writes of whoever is reusing the SharedImage.\n\nThat\u0027s why I think we need to keep the semaphore being exported but avoid the need for empty submits (and ideally avoid the need for having 49 different semaphores).\n\nThe problem here is actually very similar to this TODO: https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/vulkan/SwapChainVk.cpp;drc\u003d7e74c218738e637d4e9fdaff9dd5c38ca92ed1c3;l\u003d566 We are making empty submissions just to do a memory barrier, when we could in most cases eagerly transition and signal semaphores.\n\nSo the idea would be to detect in \"HandleTransitionSpecialCases\" that the resource needs to be eagerly transitioned / have a semaphore associated with it. Then at the end of the submit we would insert the transitions / special semaphores and update the state of the texture. This way we might create too many semaphores but at least there is no extra submits.\n\nAs a second part we could then have some kind of RefCounted semaphore wrapper so that external resources can all share the same \"export semaphore\" such that we only create at most one per submit. WDYT?",
      "parentUuid": "9d364bd3_6d607e59",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4a854d2e_0a53f735",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-13T02:05:53Z",
      "side": 1,
      "message": "Thanks, Corentin.\nI have been thinking over a solution to still keep the signal semaphores to ensure the correctness as long as it is clean and simple. Your idea of deferring to next submit is inspiring.\n\u003e Then at the end of the submit we would insert the transitions / special semaphores and update the state of the texture.\n\nMy concern here is that the texture could have been destroyed by its client already before the submit. When it comes to lifetime issues, we should always be very careful. Another potential side effect worth to mention is that I\u0027ve run into the GPU process crash issue many times for unknown reason if dawn returns un-submitted signal semaphores to chromium. Not sure whether there will be any pitfalls.\n\nAnyway we don\u0027t need to be perfect if it\u0027s really unnecessary, right?\nFor nv12 SharedImage, the only writer is the VAAPI. GL compositor and Vulkan WebGPU are merely readers. I\u0027ve been digging around for a while to understand the   synchronization between the writer and readers. But to my surprise a little bit, if I understand correctly, GPUFence(signal semaphore) is only used to synchronize between GL and Vulkan, and for VAAPI decoder synchronization, only SyncToken(command buffer level) is used which seems not sufficient to prevent the hazard of write-before-read-is-done. I happened to find the doc which partially confirms my understanding. https://docs.google.com/document/d/1-JQkhkz4ace8toR5saN7jezIDxwvVhsxHi-nLTW_JwA/edit#heading\u003dh.88fenkxl4wcf\n\u003e\u003e I don’t believe any other work is needed for synchronization with video buffers. However, do note that we currently mark VideoFrames going to the client with read lock fences enabled (see this) which means we should only get the frame back from the client once it’s not being used anymore, i.e., compositing is done (module a SyncToken, I think). Our video drivers don’t support explicit fences, so at least for video, there’s not much of a benefit in plumbing them.\n\nAlso SharedImageRepresentationVaapi is not actually being used for now. It seems there has been some suspended work for that support.\nSo in case of all these, probably we really don\u0027t need the signal semaphores to merely synchronize with GL compositor because both it and WebGPU vulkan are just readers, while the only writer VAAPI is ignoring semaphores.",
      "parentUuid": "7d15f122_8f21bb26",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10cb4f11_4dafdaee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-13T02:32:51Z",
      "side": 1,
      "message": "Just realized I had been in chromium context all the time. For dawn, we may need to change the API to allow clients choose not to use signal semaphores.",
      "parentUuid": "4a854d2e_0a53f735",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b57c2d3_98042b33",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-13T11:26:42Z",
      "side": 1,
      "message": "\u003e My concern here is that the texture could have been destroyed by its client already before the submit. When it comes to lifetime issues, we should always be very careful. Another potential side effect worth to mention is that I\u0027ve run into the GPU process crash issue many times for unknown reason if dawn returns un-submitted signal semaphores to chromium. Not sure whether there will be any pitfalls.\n\nThe idea would be that as soon as the texture has been used at least once by Dawn, then it would have a valid, signaled `VkSemaphore`. When exporting the texture we give back a vector\u003cfd\u003e it should work to return nothing, and then the user of Dawn has to synchronize with whatever previous to Dawn was using the texture.\n\nMy understanding is that the FD for VkSemaphores exported by Dawn are put in the SharedImageBackingOzone and should be use to synchronize everything else:\nhttps://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image_representation_dawn_ozone.cc;drc\u003d8a2381542cc9e9f208f138d546dd8443a8924093;l\u003d151\nhttps://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image_backing_ozone.cc;drc\u003da6fe0210768868959ac7e8d0e04eaf771e83e524;l\u003d456\n\nI don\u0027t know what happens for the compositing on ChromeOS though. Maybe there are enough implicit flushes around that no ordering on the GPU is needed, just proper CPU ordering.\n\nIn all cases, as discussed today, I still believe we should make a best effort to provide a correct API at the Dawn level. By eagerly transitioning and signaling in the submits I think we can get to great performance.",
      "parentUuid": "10cb4f11_4dafdaee",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c49355f_544238ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-13T12:06:00Z",
      "side": 1,
      "message": "\u003e\u003e The idea would be that as soon as the texture has been used at least once by Dawn, then it would have a valid, signaled  VkSemaphore . When exporting the texture we give back a vector\u003cfd\u003e it should work to return nothing, and then the user of Dawn has to synchronize with whatever previous to Dawn was using the texture.\n\nSorry, unable to exactly understand this.\nFirstly, are we going to have the CL specific for multi-planar video frames?\n\n\u003e\u003e it would have a valid, signaled  VkSemaphore \nWhat\u0027s this VkSemaphore for?\n\n\u003e\u003e When exporting the texture we give back a vector\u003cfd\u003e it should work to return nothing\nDoes this mean the returned \"vector\u003cfd\u003e\" can be empty?\n\n\u003e\u003e then the user of Dawn has to synchronize with whatever previous to Dawn was using the texture.\nWhen the user of Dawn should do that? Any representation like Dawn or Skia, of the SharedImageOzoneBacking runs BeginAccess if the returned vector\u003cfd\u003e was empty?",
      "parentUuid": "9b57c2d3_98042b33",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5eb574c8_a786731b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-13T12:12:19Z",
      "side": 1,
      "message": "\u003e Sorry, unable to exactly understand this.\n\u003e Firstly, are we going to have the CL specific for multi-planar video frames?\n\nThe CL I was thinking about wouldn\u0027t be specific to multi-planar video frames no.\n\n\u003e What\u0027s this VkSemaphore for?\n\nSo that the user of Dawn can synchronize follow-up accesses to the texture by waiting on the semaphore.\n\n\u003e Does this mean the returned \"vector\u003cfd\u003e\" can be empty?\n\nPotentially, for example if you never used the texture. This means that the SharedImage representation should know to inject back the previous semaphores if Dawn didn\u0027t give any back.",
      "parentUuid": "2c49355f_544238ce",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29b30b6e_4be469df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-13T12:44:03Z",
      "side": 1,
      "message": "\u003e then it would have a valid, signaled  VkSemaphore . \nSo it should have been un-signaled, as waiting on a signaled semaphore just makes no sense, right?\n\nStill not quite clear about the idea.\n@Austin, I would really appreciate it if you could help understand this?",
      "parentUuid": "5eb574c8_a786731b",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95d3810a_5c219cc2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-13T12:47:42Z",
      "side": 1,
      "message": "Or just a brand new VkSemaphore.\n\nWhat I mean is that:\n\n```\nif (the texture was used at least once in Dawn) {\n  the export info will contain one semaphore\n  that semaphore will have been signaled (that addresses the concern that there\u0027s problems with waiting on unsignaled semaphores)\n} else {\n  the export info will contain 0 semaphores\n}\n```",
      "parentUuid": "29b30b6e_4be469df",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c55f18d3_e79704ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-07-21T17:57:42Z",
      "side": 1,
      "message": "Sorry for the delay in reviewing this. This is an amazing optimization!\n\nHere are my thoughts on the current `LazySignalSemaphore` approach.\n\n1. Right now, it looks like we don\u0027t create or export any semaphore if the execution serial has passed. I\u0027m not sure if that\u0027s correct. The completed execution serial is incremented based on querying VkFence. Is it correct synchronization to exporting and therefore skip waiting the semaphore in these situations? VkFence is for GPU-CPU synchronization whereas VkSemaphore is for GPU-GPU synchronization - so I\u0027m not sure.\n2. Right now, when we ExportVulkanImage, we don\u0027t create or submit any semaphores yet. It only happens later when you call Resolve(). Two concerns with this:\n  - this could be submitting the semaphores later than we could. Consider for example if you (a) ExportVulkanImage, (b) call device.Tick() implicitly or explicitly, (c) then enqueue some more work, then (d) call Resolve(). The semaphores could be submitted inside (b) instead of at (d).\n  - This still has the problem where we make multiple semaphores when we could make just one. Consider if there are two external images and we call ExportVulkanImage for both of them back-to-back. They should be able to share the same semaphore.\n  \nHere\u0027s my idea about how to resolve these issues.\n - inside Texture::ExportExternalTexture, we GetOrCreate an external semaphore and from the `recordingContext`. We do *not* submit pending commands. The only difference between this and the current top-of-tree code is that we GetOrCreate a semaphore instead of using `TextureVk::mSignalSemaphore` and we remove the code to `SubmitPendingCommands`. This addresses (2) by putting the semaphore on the pending recording context as soon as Dawn is done using it so it is signaled as early as possible on the next submit. It also addresses (1) by making sure that a VkSemaphore is always signaled instead of looking at the execution serials.\n - ExportExternalTexture will also store the semaphore that was GetOrCreate\u0027d into `LazySignalSemaphore`. I think this would need to be done perhaps by `dup`-ing file descriptor since we could be exporting the same semaphore for multiple external textures, and on the Chromium-side they would be separately owned by base::ScopedFD.\n - The `Resolve` operation on `LazySignalSemaphore` would do `SubmitPendingCommands` on the device to ensure that the signals are submitted. We may need to have LazySignalSemaphore ref a wrapper around the GetOrCreate\u0027d semaphore so we can avoid submitting more than once.",
      "parentUuid": "95d3810a_5c219cc2",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5692d3f_db94f28e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-22T13:34:24Z",
      "side": 1,
      "message": "1) unfortunately when we export, even if commands are completed, we still must transition to a foreign queue for correctness. AFAIK this can cause decompression of some planes to happen etc, so we need the semaphore even if we know the commands complete.\n\nThe ideas Austin gave are a great improvement IMHO and make the code a lot more tight wrt to memory dependencies, and more correct.\n\nHowever the interface exposed to Chromium is much more complicated and means that the various backings start having to track Dawn lazy semaphores instead of just FD. By eagerly transitioning to the foreign queue on submits that use the external textures, we\u0027d be able to keep the same FD-based interface with the optimization. The only downside I can see is that sometimes an external resource could be used in multiple submits, but that should be really rare (WebGPU guidelines are to minimize the number of submits, in most cases it will be just 1). Maybe I\u0027m missing something else?\n\nThe same dup()ing can allow creating a single exportable VkSemaphore for all the external resources used on a submit, then each one gets its own FD.\n\nI really think we\u0027ll eventually gain that eager transition logic, if only because it\u0027s useful to swapchains as well. But for now if you\u0027re ready to make the SharedImage logic more complicated, we could go with Austin\u0027s improvements.",
      "parentUuid": "c55f18d3_e79704ef",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb67a44f_5f4582a3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-24T13:50:31Z",
      "side": 1,
      "message": "I basically made the Austin\u0027s improvement work with the latest PS.\nOverall my thoughts are:\na) It\u0027s almost impossible for me to find a new solution of implementation without changing the current Dawn API, that would have no correctness or potential performance downside. I would really appreciate it and be glad to try if you could propose one.\nb) The introduction of LazySignalSemaphore may be the least intrusive one I\u0027ve been able to come up with. With the adapter class GPUFenceOzone(probably should be renamed to GPUFenceDawnAdpater), Clients just need to do one more step -- \u0027Resolve\u0027, before use the fd. If this still seems not easy and straight enough, I am open to a simpler one if any.",
      "parentUuid": "d5692d3f_db94f28e",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efdcb14e_e61aaaa3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-25T10:17:45Z",
      "side": 1,
      "message": "a) An approach like https://dawn-review.googlesource.com/c/dawn/+/97004 could work without changing the API no? What do you see as correctness or performance downsides with it (assuming external textures get used in a single submit in most cases).\nb) The problem with resolving before using the FD in Chromium is that if I understand correctly, it means that every SharedImageBacking that manipulates DawnVulkan now needs to start knowing about multiple types of external semaphores, instead of just FD / Zircon handles. It\u0027s not horrible, but still additional complexity and implementation details that leak.\n\nIf you really don\u0027t feel like going the direction of eager transitions, we can do the LazySemaphore but personally I feel like this is a shorter-term fix that will need to be revisited and that the eager transitions are not much more complicated. But I may be missing stuff.",
      "parentUuid": "fb67a44f_5f4582a3",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0458f4d1_dca3d9e0",
        "filename": "src/dawn/native/vulkan/TextureVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 871,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-12T03:12:17Z",
      "side": 1,
      "message": "The thing that is actually at stake seems to be this submit. Doing this for the NV12 even without the barrier could lead to significant GPU usage increasing.",
      "range": {
        "startLine": 871,
        "startChar": 8,
        "endLine": 871,
        "endChar": 50
      },
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}