{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b9fa36f4_accfecda",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-12T03:07:15Z",
      "side": 1,
      "message": "PTAL\n\nI am not exactly sure about the correctness of CL theoretically. But the performance gain seems rather appealing. For the 7x7 Google meet sample(https://source.chromium.org/chromium/chromium/src/+/main:content/test/data/gpu/vc/webgpu_videos_mxn.html;l\u003d1?q\u003dwebgpu_videos\u0026sq\u003d\u0026ss\u003dchromium), the GPU usage can drop from 35% to 21% on my ADL ChromeOS device. I would really appreciate your perspective on this, Thanks!",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9d364bd3_6d607e59",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-12T03:14:59Z",
      "side": 1,
      "message": "The corresponding change required at chromium side is https://chromium-review.googlesource.com/c/chromium/src/+/3756645.",
      "parentUuid": "b9fa36f4_accfecda",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7d15f122_8f21bb26",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-12T12:41:09Z",
      "side": 1,
      "message": "The perf difference is impressive and it is totally worth looking at optimizing this. However I don\u0027t think this CL is correct because if the user of Dawn starts reusing the SharedImage then we didn\u0027t make a memory barrier that prevents read from Dawn from happening after the writes of whoever is reusing the SharedImage.\n\nThat\u0027s why I think we need to keep the semaphore being exported but avoid the need for empty submits (and ideally avoid the need for having 49 different semaphores).\n\nThe problem here is actually very similar to this TODO: https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/vulkan/SwapChainVk.cpp;drc\u003d7e74c218738e637d4e9fdaff9dd5c38ca92ed1c3;l\u003d566 We are making empty submissions just to do a memory barrier, when we could in most cases eagerly transition and signal semaphores.\n\nSo the idea would be to detect in \"HandleTransitionSpecialCases\" that the resource needs to be eagerly transitioned / have a semaphore associated with it. Then at the end of the submit we would insert the transitions / special semaphores and update the state of the texture. This way we might create too many semaphores but at least there is no extra submits.\n\nAs a second part we could then have some kind of RefCounted semaphore wrapper so that external resources can all share the same \"export semaphore\" such that we only create at most one per submit. WDYT?",
      "parentUuid": "9d364bd3_6d607e59",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4a854d2e_0a53f735",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-13T02:05:53Z",
      "side": 1,
      "message": "Thanks, Corentin.\nI have been thinking over a solution to still keep the signal semaphores to ensure the correctness as long as it is clean and simple. Your idea of deferring to next submit is inspiring.\n\u003e Then at the end of the submit we would insert the transitions / special semaphores and update the state of the texture.\n\nMy concern here is that the texture could have been destroyed by its client already before the submit. When it comes to lifetime issues, we should always be very careful. Another potential side effect worth to mention is that I\u0027ve run into the GPU process crash issue many times for unknown reason if dawn returns un-submitted signal semaphores to chromium. Not sure whether there will be any pitfalls.\n\nAnyway we don\u0027t need to be perfect if it\u0027s really unnecessary, right?\nFor nv12 SharedImage, the only writer is the VAAPI. GL compositor and Vulkan WebGPU are merely readers. I\u0027ve been digging around for a while to understand the   synchronization between the writer and readers. But to my surprise a little bit, if I understand correctly, GPUFence(signal semaphore) is only used to synchronize between GL and Vulkan, and for VAAPI decoder synchronization, only SyncToken(command buffer level) is used which seems not sufficient to prevent the hazard of write-before-read-is-done. I happened to find the doc which partially confirms my understanding. https://docs.google.com/document/d/1-JQkhkz4ace8toR5saN7jezIDxwvVhsxHi-nLTW_JwA/edit#heading\u003dh.88fenkxl4wcf\n\u003e\u003e I don’t believe any other work is needed for synchronization with video buffers. However, do note that we currently mark VideoFrames going to the client with read lock fences enabled (see this) which means we should only get the frame back from the client once it’s not being used anymore, i.e., compositing is done (module a SyncToken, I think). Our video drivers don’t support explicit fences, so at least for video, there’s not much of a benefit in plumbing them.\n\nAlso SharedImageRepresentationVaapi is not actually being used for now. It seems there has been some suspended work for that support.\nSo in case of all these, probably we really don\u0027t need the signal semaphores to merely synchronize with GL compositor because both it and WebGPU vulkan are just readers, while the only writer VAAPI is ignoring semaphores.",
      "parentUuid": "7d15f122_8f21bb26",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10cb4f11_4dafdaee",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-13T02:32:51Z",
      "side": 1,
      "message": "Just realized I had been in chromium context all the time. For dawn, we may need to change the API to allow clients choose not to use signal semaphores.",
      "parentUuid": "4a854d2e_0a53f735",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b57c2d3_98042b33",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-13T11:26:42Z",
      "side": 1,
      "message": "\u003e My concern here is that the texture could have been destroyed by its client already before the submit. When it comes to lifetime issues, we should always be very careful. Another potential side effect worth to mention is that I\u0027ve run into the GPU process crash issue many times for unknown reason if dawn returns un-submitted signal semaphores to chromium. Not sure whether there will be any pitfalls.\n\nThe idea would be that as soon as the texture has been used at least once by Dawn, then it would have a valid, signaled `VkSemaphore`. When exporting the texture we give back a vector\u003cfd\u003e it should work to return nothing, and then the user of Dawn has to synchronize with whatever previous to Dawn was using the texture.\n\nMy understanding is that the FD for VkSemaphores exported by Dawn are put in the SharedImageBackingOzone and should be use to synchronize everything else:\nhttps://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image_representation_dawn_ozone.cc;drc\u003d8a2381542cc9e9f208f138d546dd8443a8924093;l\u003d151\nhttps://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image_backing_ozone.cc;drc\u003da6fe0210768868959ac7e8d0e04eaf771e83e524;l\u003d456\n\nI don\u0027t know what happens for the compositing on ChromeOS though. Maybe there are enough implicit flushes around that no ordering on the GPU is needed, just proper CPU ordering.\n\nIn all cases, as discussed today, I still believe we should make a best effort to provide a correct API at the Dawn level. By eagerly transitioning and signaling in the submits I think we can get to great performance.",
      "parentUuid": "10cb4f11_4dafdaee",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c49355f_544238ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-13T12:06:00Z",
      "side": 1,
      "message": "\u003e\u003e The idea would be that as soon as the texture has been used at least once by Dawn, then it would have a valid, signaled  VkSemaphore . When exporting the texture we give back a vector\u003cfd\u003e it should work to return nothing, and then the user of Dawn has to synchronize with whatever previous to Dawn was using the texture.\n\nSorry, unable to exactly understand this.\nFirstly, are we going to have the CL specific for multi-planar video frames?\n\n\u003e\u003e it would have a valid, signaled  VkSemaphore \nWhat\u0027s this VkSemaphore for?\n\n\u003e\u003e When exporting the texture we give back a vector\u003cfd\u003e it should work to return nothing\nDoes this mean the returned \"vector\u003cfd\u003e\" can be empty?\n\n\u003e\u003e then the user of Dawn has to synchronize with whatever previous to Dawn was using the texture.\nWhen the user of Dawn should do that? Any representation like Dawn or Skia, of the SharedImageOzoneBacking runs BeginAccess if the returned vector\u003cfd\u003e was empty?",
      "parentUuid": "9b57c2d3_98042b33",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5eb574c8_a786731b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-07-13T12:12:19Z",
      "side": 1,
      "message": "\u003e Sorry, unable to exactly understand this.\n\u003e Firstly, are we going to have the CL specific for multi-planar video frames?\n\nThe CL I was thinking about wouldn\u0027t be specific to multi-planar video frames no.\n\n\u003e What\u0027s this VkSemaphore for?\n\nSo that the user of Dawn can synchronize follow-up accesses to the texture by waiting on the semaphore.\n\n\u003e Does this mean the returned \"vector\u003cfd\u003e\" can be empty?\n\nPotentially, for example if you never used the texture. This means that the SharedImage representation should know to inject back the previous semaphores if Dawn didn\u0027t give any back.",
      "parentUuid": "2c49355f_544238ce",
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0458f4d1_dca3d9e0",
        "filename": "src/dawn/native/vulkan/TextureVk.cpp",
        "patchSetId": 1
      },
      "lineNbr": 871,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-07-12T03:12:17Z",
      "side": 1,
      "message": "The thing that is actually at stake seems to be this submit. Doing this for the NV12 even without the barrier could lead to significant GPU usage increasing.",
      "range": {
        "startLine": 871,
        "startChar": 8,
        "endLine": 871,
        "endChar": 50
      },
      "revId": "c9e208040b4af750317c56a76e5f81ac1c548e76",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}