{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "47e9e1f0_fbc51c32",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "can we also validate that the d3d11device has multithread protected enabled? it is not safe to wrap devices that may be used externally on another thread\n\nsecondly, now that we pass the device into Dawn, do we still need `\nDAWN_NATIVE_EXPORT Microsoft::WRL::ComPtr\u003cID3D11Device\u003e GetD3D11Device(WGPUDevice device);`\nmaybe it can be removed in a follow-up.",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88c50fa2_b6328a59",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "ANGLE and Graphite are on the same thread. SO we don\u0027t need thread protection for this case. However media may use the same d3d11 device context for media decoding. So I think it is not necessary to check thread protection for all the cases.\n\nWe will remove it if using the same d3d11 device can improve graphite performance and stability.",
      "parentUuid": "47e9e1f0_fbc51c32",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5beab5b_51b6fc4e",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-30T22:52:11Z",
      "side": 1,
      "message": "so I\u0027m understanding, you\u0027re saying there are always two separate devices?\n - shared between Graphite-Dawn and ANGLE: does not need multithread protection\n - shared between Graphite-Dawn and media: needs multithread protection\n\n?",
      "parentUuid": "88c50fa2_b6328a59",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42f48477_32daab89",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-31T19:43:24Z",
      "side": 1,
      "message": "ANGLE, Graphite-Dawn and Media will use the same device. So the thread protection is needed for chrome. However it is the implementation detail of chrome. But from dawn point of view, the assumption is not necessary. Dawn doesn\u0027t need to know all those implementation detail. So I think validating multithread protection is not really necessary in dawn.\n\nFor example, if hardware accelerated decoding is not supported, then multithread protection is not necessary.",
      "parentUuid": "a5beab5b_51b6fc4e",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0a8d8db_e6999032",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-31T20:11:53Z",
      "side": 1,
      "message": "I\u0027m confused; because they all share the same device, I would think thread protection **should** be required since Media is operating on a separate thread.\n\nFrom the Dawn point of view, I think it would be better if we could **always** require thread protection to be enabled if you\u0027re passing in an ID3D11Device. Dawn has no idea what else the application is going to do with the device, and we cannot enforce how it is used. Thus, isn\u0027t it better if shared devices require multithread protection?",
      "parentUuid": "42f48477_32daab89",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e18be15e_840bfa43",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-31T20:51:37Z",
      "side": 1,
      "message": "FYI, We enable thread protection at [1].  Dawn doesn\u0027t need the external d3d11 device be thread safe. Dawn will make it thread safe, if the Feature::D3D11MultithreadProtected is requested. However even if we validate the external d3d11 device, the application can still reset the d3d11 device back to non-thread-safe. So I think the validation is not really necessary or important.\n\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp;l\u003d65;drc\u003d9fc872d7a2507b4685051bd6a0d93349f668e6f8",
      "parentUuid": "42f48477_32daab89",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13a64074_96c864c3",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2023-10-31T21:50:17Z",
      "side": 1,
      "message": "I don\u0027t have a strong opinion either way, but wanted to list the alternatives:\n\n1) Dawn doesn\u0027t validate multi-thread protected about the passed in D3D11 device and it is up to the client to set the correct state.\n\n2) Same as above, but we allow the existing D3D11MultithreadProtected feature to set the multithread protected state even for the passed in device.\n\n3) Dawn requires that the passed in device already has multithread protected set. This has the drawback of disallowing purely single threaded mode of operation which doesn\u0027t need thread protection.\n\n4) Same as above, but only if the D3D11MultithreadProtected feature is requested - so maybe this feature should be handled at the adapter layer?\n\nIn any of these options, Dawn can retrieve the multithread protection state via GetMultithreadProtected and call Enter/Leave based on that if that wasn\u0027t passed in explicitly by the client.\n\nAlso, a small correction to an earlier comment - we do need multithread protection for Graphite even in the absence of HW video decoding since the viz thread needs it for mapping buffers.",
      "parentUuid": "e18be15e_840bfa43",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9531f892_b3e81c6b",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-31T22:00:05Z",
      "side": 1,
      "message": "Right now there are various ways to pass things around and toggle things, and I think it would be better if we can make setting the state and the layering as simple as possible. There are currently 4 things:\n 1. export the d3d11 device from Dawn with dawn::native::d3d11::GetD3D11Device\n 2. pass the d3d11 device into Dawn with wgpu::RequestAdapterOptionsD3D11Device\n 3. set multithread mode with ID3D11Multithread::SetMultithreadProtected\n 4. set multithread mode with wgpu::FeatureName::D3D11MultithreadProtected\n\nGraphite is always sharing the d3d11 device and always needs multithread protected mode. So I think it is the simplest option to pass in a d3d11device that must always have multithreading enabled. The layering is unnecessarily complex if Chrome passes in a d3d11 device, then asks Dawn to make it multithreaded by using a particular wgpu::FeatureName.\n\nThere doesn\u0027t seem to be a real use case for Chrome to use a device without multithread protection enabled, so I don\u0027t think we should allow a path to do so. Dawn\u0027s internals are also far safer if we require shared devices to have multithread mode. This eliminates the possibility that there are unexpected races occurring.\n\n\u003e the application can still reset the d3d11 device back to non-thread-safe \n\nI think we could validate that GetMultithreadProtected is true right after we do ID3D11Multithread::Enter. Presumably once we\u0027ve called Enter, disabling multithread mode will block until Dawn calls ID3D11Multithread::Leave. Thus Dawn\u0027s usage of the context will error if multithread protection ever becomes disabled. I\u0027ve emailed folks at Microsoft asking about this.",
      "parentUuid": "e18be15e_840bfa43",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2338c78d_06469195",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-11-01T15:40:15Z",
      "side": 1,
      "message": "I think dawn shouldn\u0027t assume how an application use the API and the shared d3d11 device. (An application could be just use the dawn and the shared d3d11 device in one thread.), It is better to use Feature::D3D11MultithreadProtected to tell dawn about the application\u0027s behavior.  And will chrome be the only client of the dawn d3d11 backend? Should we consider other third party applications? If not, probably making assumption and adding the validation is fine.",
      "parentUuid": "9531f892_b3e81c6b",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1119e971_87299f6e",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2023-11-01T21:14:31Z",
      "side": 1,
      "message": "Regarding the below:\n\u003e Presumably once we\u0027ve called Enter, disabling multithread mode will block until Dawn calls ID3D11Multithread::Leave.\n\nYes, this is correct.\n\nDoes Dawn, itself, need the D3D11 device to be multi-thread protected in order to do its job? If not, seems fine to me to have it accept devices which are not multi-thread protected. If it DOES need it to do its job, then Dawn should call `SetMultithreadProtected` right when it receives the device from Chromium. \n\nAs with any global state, there needs to be sanity amongst components to prevent one from disabling required features out from under the other one.",
      "parentUuid": "2338c78d_06469195",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63a3d543_6bd55d53",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-11-02T15:39:45Z",
      "side": 1,
      "message": "Dawn doesn\u0027t require the D3D11 device to be multithreaded in normal operation because we (will) have our own locks to guard things.\n\nDawn does require the D3D11 device to be multithreaded if you\u0027re sharing that d3d11 device externally because our own locks can\u0027t synchronize with external ones (though there is opportunity for optimization to merge them into one lock).\n\nAgree about global state and sanity; that\u0027s why I think we should remove FeatureName::D3D11MultithreadProtected to minimize the number of things used to toggle the multithreading state. Chrome can turn this on itself.\n\nLastly, I still believe we should validate the d3d11 device passed in has MultithreadProtected enabled. It is easy to loosen validation in the future. It is difficult to remove features that developers are already using. It would be better to make it strict and add in more ways to control the behavior later if other developers really need it.",
      "parentUuid": "2338c78d_06469195",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10ea0d5a_0fa8782d",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-11-02T15:53:46Z",
      "side": 1,
      "message": "Does dawn itself really need the the ID3D11DeviceContext to be thread safe? I though it is only needed, if dawn is used in multithread application like graphite.",
      "parentUuid": "63a3d543_6bd55d53",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c778cce_1126f1ad",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-11-02T15:56:14Z",
      "side": 1,
      "message": "We are in the process of implementing this, but yes. Every operation on the queue must be internally synchronized by Dawn. The application expects to be able to do two queue.Submits racing on multiple threads without issue.\n\nThis means that Dawn either:\n - brings its own locks\n - uses multithread protected\n \nIn practice, we will need a combination of the two because there are other state bits that need synchronization.",
      "parentUuid": "10ea0d5a_0fa8782d",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f069de5_9869187a",
        "filename": "src/dawn/native/d3d11/BackendD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 65,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-11-02T16:15:30Z",
      "side": 1,
      "message": "Do you mean wgpu::Queue will be thread safe by default in future? If that is the case, we should always validate thread protection is enabled, or allow passing in a d3d11 device without thread protection but dawn will always enable the thread protection in dawn by default.",
      "parentUuid": "3c778cce_1126f1ad",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b39d5fc_6c3278c4",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 58,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "do we need to store the bool as a member variable? we can swap in the constructor if true. Then we can swap back if mPreviousState is not null. Don\u0027t need to store the bool I think",
      "range": {
        "startLine": 58,
        "startChar": 8,
        "endLine": 58,
        "endChar": 25
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0122bd5c_1f68ae36",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 58,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5b39d5fc_6c3278c4",
      "range": {
        "startLine": 58,
        "startChar": 8,
        "endLine": 58,
        "endChar": 25
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7fcf581b_42fcaa68",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 59,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "nit: this bool could be cached on the command context",
      "range": {
        "startLine": 59,
        "startChar": 18,
        "endLine": 59,
        "endChar": 88
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "88e03a02_7af68e27",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 59,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7fcf581b_42fcaa68",
      "range": {
        "startLine": 59,
        "startChar": 18,
        "endLine": 59,
        "endChar": 88
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc34d016_0f4c7ea0",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "this should check that \u0026other !\u003d this",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0f6dcfdf_5c5f9407",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "This method has been removed.",
      "parentUuid": "cc34d016_0f4c7ea0",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edbc5e4d_5ccc13df",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "could we pass D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED since we manage our state behind a lock?",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a8828d25_f0bc0cc7",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "The dawn lock can only protect device context used within dawn. ANGLE and media code can still use the context with holding the lock in dawn.",
      "parentUuid": "edbc5e4d_5ccc13df",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9733b2b8_0b1944fb",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-30T22:52:11Z",
      "side": 1,
      "message": "when we are creating the context state here, isn\u0027t it used exclusively by Dawn, and not shared with ANGLE/media? The context itself yes is shared, but when Dawn is using the context, we lock it and swap in our own single-threaded state.",
      "parentUuid": "a8828d25_f0bc0cc7",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd0880ff_4c68cd7c",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-31T19:43:24Z",
      "side": 1,
      "message": "But the media code is not protected with the lock in dawn. and the media code could use the ID3D11DeviceContext which has been swapped with the context state in dawn.",
      "parentUuid": "9733b2b8_0b1944fb",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b33c3aa_8be6bfe3",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-31T20:11:53Z",
      "side": 1,
      "message": "isn\u0027t this type of race guarded by mMultithread-\u003eEnter/Leave ?",
      "parentUuid": "bd0880ff_4c68cd7c",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e2307fc_be6dd149",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-31T20:51:37Z",
      "side": 1,
      "message": "I am not sure. Both [1] and [2] don\u0027t mention this use case. I feel if a single threaded context state is used, probably thread protection will be disabled immediately. And calling D3D11 API from other thread will not be guarded.\n\n[1] https://learn.microsoft.com/en-us/windows/win32/api/d3d11_4/nf-d3d11_4-id3d11multithread-enter\n[2] https://learn.microsoft.com/en-us/windows/win32/api/d3d11_1/ne-d3d11_1-d3d11_1_create_device_context_state_flag",
      "parentUuid": "8b33c3aa_8be6bfe3",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7e30bcc_b60762ed",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2023-10-31T21:50:17Z",
      "side": 1,
      "message": "It\u0027s unclear what the meaning of this flag is. D3D11 default behavior is that resource creation methods (on ID3D11Device) are reentrant thread-safe whereas immediate context operations require synchronization. On top of this we get some flexibility:\n\n1) You can promise to call all methods (incl. resource creation) from the same thread when creating the device (D3D11_CREATE_DEVICE_SINGLETHREADED).\n\n2) You can make the immediate context operations thread-safe via ID3D11MultithreadProtected.\n\nMy reading of the above docs is that you have to use D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED only if your device was also created with D3D11_CREATE_DEVICE_SINGLETHREADED. Some points supporting this interpretation:\n\n1) D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED was added in D3D 11.1 at which time ID3D11MultithreadProtected didn\u0027t exist (until 11.4) so immediate context operations always required external synchronization at that time. It doesn\u0027t make sense to have a special single-threaded mode if that\u0027s already the default behavior.\n\n2) D3D11_CREATE_DEVICE_SINGLETHREADED likely removes all locks from the ID3D11Device even for internal usage via the immediate context. Setting D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED is probably needed to have the same behavior when using the immediate context with a custom context state object.\n\n3) The references to D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED usually also talk about D3D11_CREATE_DEVICE_SINGLETHREADED. The suffix \"SINGLETHREADED\" is also the same - just a heuristic which suggests they were meant to be used together :-)",
      "parentUuid": "6e2307fc_be6dd149",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ffdef130_d3c2caff",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-31T22:00:05Z",
      "side": 1,
      "message": "I\u0027ve emailed folks at Microsoft asking about this.",
      "parentUuid": "f7e30bcc_b60762ed",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "159f13b9_893f5f2e",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2023-11-01T21:14:31Z",
      "side": 1,
      "message": "Per the documentation in https://learn.microsoft.com/en-us/windows/win32/api/d3d11_1/nf-d3d11_1-id3d11device1-createdevicecontextstate, you must create device context state objects with the `D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED` flag if the device was created with the `D3D11_CREATE_DEVICE_SINGLETHREADED` flag. You can query an existing device for its creation flags by calling `ID3D11Device::GetCreationFlags`.\n\nIf you use `D3D11_CREATE_DEVICE_SINGLETHREADED` that means you can only use the device from one thread at a time. Up to you to make that happen. If you leave it off, then only certain resource creation API calls (like CreateTexture) are thread safe. \n\nCalling `SetMultithreadProtected` additionally guarantees two threads won\u0027t race within an API call on the immediate context. It\u0027s best used for submitting video work on background threads which doesn\u0027t really use the set+submit pattern. \n\nThe purpose of D3D11 device context state objects is to keep state from different components nicely separated from each other. Direct2D, for instance, uses them to keep its own D3D immediate context state separate from the D3D immediate context state the application uses for its own purposes. It fits nicely in Chromium when multiple components in different repositories are partying on the same D3D11 device context. \n\n(I spent some time discussing the overall plan with my D3D contact)\n\nUnfortunately, D3D11 is not very parallelizable like D3D12 is. If multiple threads are doing mostly D3D work, you\u0027re better off serializing that work on one thread and use the immediate context. If multiple threads are mostly doing non-D3D work with some D3D work sprinkled in, deferred contexts is an option. They\u0027re about parallelizing _your own code_, not D3D. Deferred contexts are not widely used but they exist and work. There are limitations around resource upload and mapping things to keep in mind.\n\nDawn is unique in that it performs its OWN command list serialization which (I believe??) is mandatory. In that case, deferred contexts may not provide much value since they\u0027re effectively doing the same thing Dawn already does. \n\nDoes converting Dawn command lists to D3D calls happen as a relatively atomic operation, or is it interleaved with other command list generating work like Skia?  If the former, replaying them to the immediate context (with a device context state object like we\u0027re doing here) seems like the best approach.",
      "parentUuid": "ffdef130_d3c2caff",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a308d10a_75306d32",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2023-11-01T21:24:58Z",
      "side": 1,
      "message": "D3D context state objects also let you have mismatched feature levels from the host. If ANGLE (or whatever) creates a D3D11 device of feature level 10_1, Dawn can make a device context state object on that device with feature level 11_1 and use compute shaders.",
      "parentUuid": "159f13b9_893f5f2e",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5c9a946_3bb5a8bf",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2023-11-01T23:24:29Z",
      "side": 1,
      "message": "\u003e Does converting Dawn command lists to D3D calls happen as a relatively atomic operation, or is it interleaved with other command list generating work like Skia? If the former, replaying them to the immediate context (with a device context state object like we\u0027re doing here) seems like the best approach.\n\nMostly yes - the only immediate context operation which happens out of band with Graphite is buffer mapping on the viz thread. Everything else is serialized internally in Graphite recordings which playback Dawn commands on the GPU process main thread and the Dawn commands get transformed to D3D11 commands in Dawn queue submit.",
      "parentUuid": "a308d10a_75306d32",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6bf60354_b5ef69f8",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.cpp",
        "patchSetId": 9
      },
      "lineNbr": 137,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-11-02T15:39:45Z",
      "side": 1,
      "message": "Thank you for the feedback Rafael, the context is helpful!\n\nOne follow-on question then:\n - if I make a device *without* D3D11_CREATE_DEVICE_SINGLETHREADED\n - and use a device context with SetMultithreadProtected(true)\n - is there any point in then using a device context state *with*  D3D11_1_CREATE_DEVICE_CONTEXT_STATE_SINGLETHREADED ?",
      "parentUuid": "d5c9a946_3bb5a8bf",
      "range": {
        "startLine": 137,
        "startChar": 16,
        "endLine": 137,
        "endChar": 28
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32bed658_aacf5127",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 46,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "are there methods that strictly may be called when the device context is swapped? If so, it would be preferable to have two separate classes. like ScopedContext and ScopedContextState where ScopedContextState extends ScopedContext.\n\nThen, ScopedContextState can provide the additional methods that are allowed when the state is swapped in",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 46,
        "endChar": 86
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2007fc33_4ee8215e",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 46,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "It is hard to do that. the d3d11 backend needs access ID3D11DeviceContext to either update resource content or modify context state. We cannot only allow updating resources but not modifying context state.",
      "parentUuid": "32bed658_aacf5127",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 46,
        "endChar": 86
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50830be1_f215f11c",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 46,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-30T22:52:11Z",
      "side": 1,
      "message": "Can we add helper methods to proxy the UpdateSubresource calls, etc. to the context state?\n\nRight now, the burden is on the developer to not use certain functions if they pass `false` for swapContextState. This seems like a fragile solution. You might get the scoped context and pass it into a function where it\u0027s hard to tell whether the context has a swapped state or not. If we could have a proxy which only allows certain methods to be called when the context state is not swapped, then it would be a lot safer. We can more carefully review when proxy methods are added to be sure they are actually OK thread-safe.\nAlternatively - we could always swap the state - but I imagine the performance of this would not be desirable.",
      "parentUuid": "2007fc33_4ee8215e",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 46,
        "endChar": 86
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "94fb3308_ef6393d8",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 46,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-31T19:43:24Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "50830be1_f215f11c",
      "range": {
        "startLine": 46,
        "startChar": 0,
        "endLine": 46,
        "endChar": 86
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b007efa6_193ea05d",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 49,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "could it be NonMovable? what do you need these for?",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 49,
        "endChar": 56
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6d0b15ab_6f063f4c",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 49,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b007efa6_193ea05d",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 49,
        "endChar": 56
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f9f19fa_e7fe4884",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 53,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "nit: even though these definitions are small, still prefer to put them in the .cpp file\n\nthe linker can take care of link-time optimization to inline",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1b9a4a5f_fd6d1cbd",
        "filename": "src/dawn/native/d3d11/CommandRecordingContextD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 53,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "Really? Can linker inline a method defined in .cpp file but used in other .cpp file? I thought the linker can only inline a method defined and used in the same .cpp file.\n\nDone",
      "parentUuid": "5f9f19fa_e7fe4884",
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb6e16af_d86f3454",
        "filename": "src/dawn/native/d3d11/PhysicalDeviceD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 56,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-10-27T02:36:39Z",
      "side": 1,
      "message": "nit: casing as \"D3D11Device\" to match",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 56,
        "endChar": 69
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7962481b_576a3735",
        "filename": "src/dawn/native/d3d11/PhysicalDeviceD3D11.h",
        "patchSetId": 9
      },
      "lineNbr": 56,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-10-27T14:28:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cb6e16af_d86f3454",
      "range": {
        "startLine": 56,
        "startChar": 0,
        "endLine": 56,
        "endChar": 69
      },
      "revId": "f19fa9c3a5c8ad4865dc6e29c96946ca00f50aa5",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}