{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "672d436b_03326efe",
        "filename": "src/dawn_native/CommandBufferStateTracker.cpp",
        "patchSetId": 7
      },
      "lineNbr": 236,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-04T22:08:57Z",
      "side": 1,
      "message": "nit: chances are, we\u0027re going to want to inline these simple getters",
      "range": {
        "startLine": 230,
        "startChar": 4,
        "endLine": 236,
        "endChar": 5
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "337b3613_56ba49e6",
        "filename": "src/dawn_native/CommandBufferStateTracker.cpp",
        "patchSetId": 7
      },
      "lineNbr": 236,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-05T13:39:09Z",
      "side": 1,
      "message": "I\u0027d still like us to be able to somehow tag for LTO forceinline instead of putting getters in the headers. I\u0027m not sure who our LLVM people are, but it might be possible to motivate adding this?",
      "parentUuid": "672d436b_03326efe",
      "range": {
        "startLine": 230,
        "startChar": 4,
        "endLine": 236,
        "endChar": 5
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "033d8a23_bc9874ba",
        "filename": "src/dawn_native/CommandBufferStateTracker.cpp",
        "patchSetId": 7
      },
      "lineNbr": 236,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-06T11:50:52Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "337b3613_56ba49e6",
      "range": {
        "startLine": 230,
        "startChar": 4,
        "endLine": 236,
        "endChar": 5
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7e52427_c2e41455",
        "filename": "src/dawn_native/ComputePassEncoder.cpp",
        "patchSetId": 7
      },
      "lineNbr": 123,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-04T22:08:57Z",
      "side": 1,
      "message": "It\u0027s kind of weird how we\u0027re modifying mBindGroups used inside UseBindGroupsInDispatch, but writing out to the |scope| variable, but then passing the |scope| results back to update mUsageTracker.\n\n- bitset manipulations in UseBindGroupsInDispatch look inefficient. We can simply directly OR in layout-\u003eGetBindGroupLayoutsMask().\n- perhaps the bitset can be an output variable as well. This way mutations happen in the same way, instead of one mutation happening to this-\u003emUsedBindGroups inside the member function, and one in the \u0026scope output var.\n- alternatively, just pull out updating mUsedBindGroups to here, so the mUsageTracker and mUsedBindGroups mutations happen next to each other:\n  mUsedBindGroups |\u003d\n    mCommandBufferState.GetPipelineLayout()-\u003eGetBindGroupLayoutsMask();\n- or maybe just return a SyncScopeUsageTracker from UseBindGroupsInDispatch",
      "range": {
        "startLine": 120,
        "startChar": 12,
        "endLine": 123,
        "endChar": 69
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07b94a39_d3c34d99",
        "filename": "src/dawn_native/ComputePassEncoder.cpp",
        "patchSetId": 7
      },
      "lineNbr": 123,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-05T13:39:09Z",
      "side": 1,
      "message": "I went with the approach returning the SyncScopeUsageTracker, (and the |\u003d, not sure why I didn\u0027t do that in the first place). Let me know if this looks ok.",
      "parentUuid": "f7e52427_c2e41455",
      "range": {
        "startLine": 120,
        "startChar": 12,
        "endLine": 123,
        "endChar": 69
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f3d9919_0d05ee60",
        "filename": "src/dawn_native/ComputePassEncoder.cpp",
        "patchSetId": 7
      },
      "lineNbr": 170,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-04T22:08:57Z",
      "side": 1,
      "message": "okay so, IIUC, if you call SetBindGroup with the same index multiple times, without calling Dispatch, then because you might be replacing the set bind group, we take the previous one and move it to the unused set.\n\nthen if you do call Dispatch, mBindGroupsUsed gets populated, so if you call SetBindGroup after that, we reset the index in mBindGroupsUsed.. is this because its the first replacement, so it\u0027s not \"kicking out\" the previous bind group into the unused set?\n\nFollowing this logic, if I got it right, was a bit confusing. Would it be simpler if instead of having an unused set, we simply had a single set of bind groups to check IsValidForSubmit? Right now we have that check split between ValidateSyncScopeUsedInSubmit and the loop over unusedTextures/unusedBuffers. This single set of resources would contain both used/unused resources and we wouldn\u0027t need ValidateSyncScopeUsedInSubmit***.\n\nAlso, I don\u0027t think the current unused list strictly means these resources are unused - which can be a bit confusing.\nsetBindGroup(0, bg1);\nsetBindGroup(0, bg2);\nsetBindGroup(0, bg1);\nwill get resources from both bg1 and bg2 into the \"unused\" list, but then following that I could do:\nsetBindGroup(1, bg1);\nsetBindGroup(2, bg2);\ndispatch(1);\nand all of those resources would actually be used.",
      "range": {
        "startLine": 162,
        "startChar": 12,
        "endLine": 170,
        "endChar": 13
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c9797e5_0524b7ec",
        "filename": "src/dawn_native/ComputePassEncoder.cpp",
        "patchSetId": 7
      },
      "lineNbr": 170,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-05T13:39:09Z",
      "side": 1,
      "message": "\u003e okay so, IIUC, if you call SetBindGroup with the same index multiple times, without calling Dispatch, then because you might be replacing the set bind group, we take the previous one and move it to the unused set.\n\nYes, with the caveat that you noted that it\u0027s more like a \"maybeUnused\" set.\n\n\u003e Following this logic, if I got it right, was a bit confusing. Would it be simpler if instead of having an unused set, we simply had a single set of bind groups to check IsValidForSubmit? Right now we have that check split between ValidateSyncScopeUsedInSubmit and the loop over unusedTextures/unusedBuffers. This single set of resources would contain both used/unused resources and we wouldn\u0027t need ValidateSyncScopeUsedInSubmit***.\n\nJust so I understand, this would add a set\u003cBindGroupBase*\u003e to ComputePassResourceUsage that would later be checked in ValidateSubmit? That would work. What I\u0027m trying to optimize for is the case where all bindgroups are used, wouldn\u0027t checking a set\u003cBindGroupBase*\u003e be slower in that case?\n\nActually, now that I think about it, we should probably just have a list of all used buffers and textures on the ComputePassResourceUsage that would become:\n\n struct ComputePassResourceUsage {\n   vector\u003cSyncScopeResourceUsage\u003e dispatchUsages;\n\n   // These are all the resources \n   set\u003cBufferBase*\u003e usedBuffers;\n   set\u003cTextureBase*\u003e usedTextures;\n }\n\nAlthough everything is in O(sum for each dispatch (resources used by the dispatch)) with hash sets anyway so IDK.",
      "parentUuid": "4f3d9919_0d05ee60",
      "range": {
        "startLine": 162,
        "startChar": 12,
        "endLine": 170,
        "endChar": 13
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f23b649_c9e53e12",
        "filename": "src/dawn_native/ComputePassEncoder.cpp",
        "patchSetId": 7
      },
      "lineNbr": 170,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-05T15:03:28Z",
      "side": 1,
      "message": "Yea.. idk - iteration of the std::vector will be much faster for sure. But at the same time we have std::vector\u003cSyncScopeResourceUsage\u003e and each sync scope has std::vector\u003cBuffer*\u003e. There\u0027s no deduplication so we\u0027ll check some resources more times than necessary.\n\nI do think that having a set would be more clear to understand than the way the CL currently attempts to maintain a definitelyUsed list and maybeUnused set.\nFor now though, I\u0027d be okay as long as the name/comment clarifies that the resources are maybeUnused and may be checked in duplicate.\n\nWe can do some better testing of perf whenever we start using absl::flat_hash_set",
      "parentUuid": "6c9797e5_0524b7ec",
      "range": {
        "startLine": 162,
        "startChar": 12,
        "endLine": 170,
        "endChar": 13
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0097aec5_a2c7b06c",
        "filename": "src/dawn_native/ComputePassEncoder.cpp",
        "patchSetId": 7
      },
      "lineNbr": 170,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-06T11:50:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7f23b649_c9e53e12",
      "range": {
        "startLine": 162,
        "startChar": 12,
        "endLine": 170,
        "endChar": 13
      },
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5766f883_eadf939a",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 7
      },
      "lineNbr": 230,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-04T22:08:57Z",
      "side": 1,
      "message": "nit: maybe add a note that the usages won\u0027t ever contain RenderAttachment usage inside a Dispatch call - otherwise it kind of looks like we could accidentally skip the subresource initialization for a texture with RenderAttachment usage.",
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94c650bb_be2b5162",
        "filename": "src/dawn_native/vulkan/CommandBufferVk.cpp",
        "patchSetId": 7
      },
      "lineNbr": 151,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-05-04T22:08:57Z",
      "side": 1,
      "message": "ditto: comment about RenderAttachment in Dispatch",
      "revId": "2946cb0d0c7e5d4ad6731d4208eeef79dfcd56bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}