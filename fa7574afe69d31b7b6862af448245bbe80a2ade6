{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e29db229_aec13527",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2023-04-26T12:40:06Z",
      "side": 1,
      "message": "Thanks for reviewing!",
      "revId": "fa7574afe69d31b7b6862af448245bbe80a2ade6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4d873e8_a192fc3d",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 464,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-04-26T14:17:29Z",
      "side": 1,
      "message": "It may increase copy size, if the `data`\u0027s size is smaller than the adjusted size, will it cause problem?\nMaybe we should just DAWN_ASSERT() it, make sure caller always passed in right size? Or we have to use a temp aligned buffer here.",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 47
      },
      "revId": "fa7574afe69d31b7b6862af448245bbe80a2ade6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08be0c1b_02e9fe03",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 464,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-26T15:08:39Z",
      "side": 1,
      "message": "I\u0027m not sure we can make this ASSERT about dstBox.left. In WebGPU, the buffer offset for writeBuffer must be aligned to 4 bytes, so the application can easily send writeBuffers that aren\u0027t aligned.\n\nThis could be a may be a good reason for us to implement the DynamicUploader class in Dawn using buffers with D3D11_USAGE_DYNAMIC. writeBuffer will write into that buffer, and then CopySubresourceRegion into the destination.\n\nwe\u0027ll have to use this fallback mechanism whenever the sizes are not nicely aligned, or `UpdateSubresource1` is not supported by the driver.",
      "parentUuid": "c4d873e8_a192fc3d",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 47
      },
      "revId": "fa7574afe69d31b7b6862af448245bbe80a2ade6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4e3f7e0_e6a8d657",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 464,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-04-26T16:04:11Z",
      "side": 1,
      "message": "`DynamicUploader` assumes the backend can use unmapped buffers as copy source. However it is not allowed with D3D11. If we want to use `CopySubresourceRegioin()`, we have to implement another DynaimcUploader inside d3d11 backend. And `Map` \u0026 `Unmap` are not threadsafe, will DynamicUploader be used off the GPU main thread?\n\n``` Note  D3D11_USAGE_DYNAMIC resources consume specific hardware capabilities. Therefore, use them sparingly. ``` Seems it consumes limited GPU resources, over allocating dynamic resources will affect system performance? I think dynamic resources are not designed for staging usage?\n\nThe simplest way is just split this upload to two UpdateSubresource() calls if the data size is not 16 bytes aligned. One for `[0, Align(size - 16, 16))`, and one for `[Align(size - 16, 16), Align(size - 16, 16) + 16)` with a 16 bytes temp buffer.",
      "parentUuid": "08be0c1b_02e9fe03",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 47
      },
      "revId": "fa7574afe69d31b7b6862af448245bbe80a2ade6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6067cdb4_cbbe7666",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 464,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-26T16:11:28Z",
      "side": 1,
      "message": "we\u0027d just have one or a couple D3D11_USAGE_DYNAMIC so I\u0027m not that worried. But yes the usage pattern is slightly different for d3d11 because of the map contraints.\nit would also be fine to use a staging buffer, but the microsoft folks suggested DYNAMIC could be could for MapWrite|CopySrc which is the use case here.\nThese uploads happen in WriteBuffer/WriteTexture which is an \"Execution\" concept. So it would have acquired the lock for that already.\n\n\u003e The simplest way is just split this upload to two UpdateSubresource() calls\n\nI don\u0027t understand - how do you write region [4, 24) ?\nIf I\u0027m understanding the docs right, BOTH the offset and offset+size need to be 16-byte aligned.",
      "parentUuid": "b4e3f7e0_e6a8d657",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 47
      },
      "revId": "fa7574afe69d31b7b6862af448245bbe80a2ade6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fcdea322_2af6371c",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 464,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-04-26T16:33:01Z",
      "side": 1,
      "message": "I thought this problem again. I think we need to force the callers to use offset and size with right alignment for uniform buffers for below reasons:\n1. If the it is not aligned, we have to add padding to the source data. But the padding data will overwrite part of uniform buffer. Those area of the uniform could be meaningful to shaders.\n2. Even if we use `CopySubresourceRegion()`, it still requires the offset and size alignment. it will overwrite padding area as well.\n3. Otherwise, we have to readback padding area first.",
      "parentUuid": "6067cdb4_cbbe7666",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 47
      },
      "revId": "fa7574afe69d31b7b6862af448245bbe80a2ade6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5df8dec_42f45f44",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 464,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2023-04-27T03:11:22Z",
      "side": 1,
      "message": "Maybe we can just keep a copy of the uniform buffer in the system memory. Every time when there is a buffer write, we write to the copy first and then update the buffer\u0027s minimal aligned sub region from copy. So we won\u0027t need to bother with readback.",
      "parentUuid": "fcdea322_2af6371c",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 47
      },
      "revId": "fa7574afe69d31b7b6862af448245bbe80a2ade6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7162b034_3fac2010",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 5
      },
      "lineNbr": 110,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2023-04-26T14:17:29Z",
      "side": 1,
      "message": "nit: should we add `DAWN_ASSERT((Align(binding.size)+ offset) \u003c\u003d binding.buffer-\u003eGetAllocatedSize());`",
      "range": {
        "startLine": 110,
        "startChar": 58,
        "endLine": 110,
        "endChar": 81
      },
      "revId": "fa7574afe69d31b7b6862af448245bbe80a2ade6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}