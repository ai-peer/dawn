{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "01385198_0ba02891",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-06-02T21:31:03Z",
      "side": 1,
      "message": "LGTM",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4aa3426_c6bc29e5",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-02T19:13:21Z",
      "side": 1,
      "message": "I think we need to add alignedOffset here, but also the D3D12 drivers doesn\u0027t do the same RequiredBytesInCopy computation that we do here. Instead it does\n\n alignedOffset + copy.bufferSize.width * copy.bufferSize.height * copyBufferSize.depthOrArrayLayers * textureSpec.texelBlockSizeInBytes\n \nSo I think that\u0027s what we should use for bufferSizeForFootprint.",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb470f9b_a7af998b",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-03T05:39:44Z",
      "side": 1,
      "message": "Considering compressed formats, the computation you proposed should be:\n\nalignedOffset + widthInBlocksForFootprint * heightInBlocksForFootprint * copyBufferSize.depthOrArrayLayers * textureSpec.texelBlockSizeInBytes - Let\u0027s say it is [1]).\n\nOtherwise, some compressed unittest will fail. For example, textureSpec \u003d {0, 0, 0, 4, 4, 1, 8, 4, 4}, which means copyOrigin is {0, 0, 0}, and copySize is {4, 4, 1} and blockInfo is {8, 4, 4}. Note that copySize is just one pixel for this compressed format. So you previous computation will be: 0 + 4 * 4 * 1 * 8 \u003d 128. While the updated one I wrote above is 0 + 1 * 1 * 1 * 8 \u003d 8. And minimunBufferSize is 8. \n\nHowever, I think this computation is not the maximum pixel\u0027s ending location (or bufferSizeForFootprint). I feel like the correct one should be \n\ncopySize.alignedOffset + utils::RequiredBytesInCopy(....) - Let\u0027s say it is [2]. \n\nI did miss alignedOffset in my previous patchset (as you pointed out). \n\nExample: textureSpec \u003d {origin: {0, 0, 0}, copySize: {4, 5, 3}, blockInfo: {4, 1, 1}} and bufferSpec is {offset: 0, bytesPerRow: 256, rowsPerImage: 5}.\n\ncopy.bufferSize will be {4, 5, 3}, it is a pretty easy split. \n\nEquation [1] will be: 0 + 4 * 5 * 3 * 4 \u003d 240. \nEquation [2] will be: 0 + 256 * (5 * 3 - 1) + 4 * 4, it is much bigger than 240. \n\nFor equation [1], every row length is shorten to 4 (copySize.width) * 4 (textureSpec.texelBlockSizeInBytes) \u003d 16 bytes. \nFor equation [2], every row length but the last one is 256 (bytesPerRow) bytes, the last one is 4 * 4 \u003d 16 bytes, though. \nAnd the result of equation [2] equals to minimumBufferSize. So I chose equation [2] for comparison, WDYT?\n\nIn addition, the current unittest can only ensure its correctness for 2D non-array textures (at least for this new added test code snippet). See the comment I added.",
      "parentUuid": "d4aa3426_c6bc29e5",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20f9fa60_e3a49af0",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-03T08:42:03Z",
      "side": 1,
      "message": "Ah yes I forgot to take rowPitch and compressed textures into account (again \u003e_\u003e) \n\nThe overall comment is not about a specific expression, but that we need to have an invariant that all of the buffer\u0027s footprint given to D3D must be in bounds of the buffer, not just the texels copied. This is something that D3D12 validates (with the debug device it produces a validation error, in release mode it produces an error on commandList.Close()). So we need to have it as an invariant. For example this is why we need to split the very last row in the 3D split.\n\nWith your comments the expression [1] should become:\n  alignedOffset + rowPitch * heightInBlocksForFootprint * copyBufferSize.depthOrArrayLayers * textureSpec.texelBlockSizeInBytes\n\nWhich gives:  \n 0 + 256 * 5 * 3 * 4\n \nThe difference is that [1] uses 256 - 4*4 more bytes than [2].",
      "parentUuid": "eb470f9b_a7af998b",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1539aa7a_807b0075",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-03T15:27:58Z",
      "side": 1,
      "message": "I should have talked about this and pointed out that this is incorrect because I actually have already tried that expression you said: \n  alignedOffset + rowPitch * heightInBlocksForFootprint * copyBufferSize.depthOrArrayLayers * textureSpec.texelBlockSizeInBytes\n\nIt should be (considering compressed formats): \n  alignedOffset + (rowPitch / textureSpec.blockWidth) * heightInBlocksForFootprint * copyBufferSize.depthOrArrayLayers * textureSpec.texelBlockSizeInBytes. \n  \nHowever, take copySize \u003d {4, 5, 3} as an example. The mininumBufferSize is \n  0 + 256 * (5 * 3 - 1) + 4 * 4. \n  \nThe updated expression [1] will be greater than minimunBufferSize. The test will fail. You can try to run unittest, there are lots of failures (no matter it is one single row copy, one single slice copy, or multiple slices copy) if you use expression [1] or my updated version for compressed formats. \n\nI think D3D12\u0027s validation code doesn\u0027t require the last row to be aligned with rowPitch. It can calculate the exact location for the last pixel: the last pixel will never exceed the 4th pixel of the last row in my example. it is not standing on the 64th pixel of the last row. The last pixel can be prior to the 4th pixel of the last row in copy (but it will never exceed that location)\n\nSo, I still think expression [2] is the correct one and the current comparison makes sense. \n\nNote that textureSpec.offset (can be at anywhere) and copy.alignedOffset (should be 512B aligned) are different in many cases, so are the other values for calculating minimumBufferSize and bufferSizeForFootprint. the example of copySize \u003d {4, 5, 3} and bufferSpec.offset \u003d 0 is one of the simplest case in order to discuss the calculated result for different expressions, and all parameters have the same values for calculating minimumBufferSize and bufferSizeForFootprint for this special example.",
      "parentUuid": "20f9fa60_e3a49af0",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfb8b2ca_c03ca841",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-03T15:41:14Z",
      "side": 1,
      "message": "by the way, when we are handling the \"first empty row\" issue for 3D texture copy split, we need 3 copy regions and we have a separate copy region for the last row of the last depth slice, the reason is that:\n  if we use a copy region for the last row of all depth slices, the \"last row\" of each depth slice is not at the last row of the copy region because of alignment adjustment. So there will be one more row at least added into the copy region (it means that the copied \"last row\" is at the location of the last but one row in the copy region due to alignment adjustment). The out-of-bound one more row is not a problem if it is in the middle of a depth slice. But if it is at the last depth slice, it will be OOB. \n\nI mean, the OOB issue is caused by one more row, it is not cause by \"the last row need to be aligned with rowPitch\". This is my understanding. WDYT?",
      "parentUuid": "1539aa7a_807b0075",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0bb9746_e46c45ab",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-03T15:51:48Z",
      "side": 1,
      "message": "Some further discussion if you want to know: the copy region number for handling \"empty first row\" issue of 3D texture copy splitter can be 2 (not 3) for some cases: \n  when we are using the 2nd copy region to copy the last row of all depth slices, if the last row can sit on the last row of this copy region after 512B alignment adjustment (no extra row is added at the end of the copy region), it is done. We don\u0027t need one more copy for the last row of the last depth slice. The copy region number will be 2 (not 3) for this case. \n  \nThat is a minor optimization we can do, we can discuss it in the other patch.",
      "parentUuid": "cfb8b2ca_c03ca841",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "90816b1d_95eaa476",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2021-06-03T17:17:42Z",
      "side": 1,
      "message": "Thank you for the explanation offline, it makes sense: the D3D12 driver correctly computes the last texel of the buffer footprint. The issue is that in the very-last row issue that row is not the last one of the buffer footprint so the total buffer footprint can go past the end of the buffer.",
      "parentUuid": "f0bb9746_e46c45ab",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab0bd391_abe24982",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-03T17:50:50Z",
      "side": 1,
      "message": "Ack!",
      "parentUuid": "90816b1d_95eaa476",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38db3394_d56258f7",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 249,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-02T17:38:33Z",
      "side": 1,
      "message": "I feel like that bytesPerRow of 512 and 768 are not well tested. Both of them are greater than 256 (the minimum allowed bytesPerRow), and one is 512B-aligned, the other is not. \n\nIn addition, when bytesPerRow is 256/512/768, multiple rows and multiple depth or array slices are not well tested. \n\nSo I added a few more tests for these situations.",
      "range": {
        "startLine": 243,
        "startChar": 1,
        "endLine": 249,
        "endChar": 0
      },
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "324924b8_32f802fe",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 249,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-02T19:13:21Z",
      "side": 1,
      "message": "Great!",
      "parentUuid": "38db3394_d56258f7",
      "range": {
        "startLine": 243,
        "startChar": 1,
        "endLine": 249,
        "endChar": 0
      },
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}