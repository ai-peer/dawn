{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "01385198_0ba02891",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-06-02T21:31:03Z",
      "side": 1,
      "message": "LGTM",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4aa3426_c6bc29e5",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-02T19:13:21Z",
      "side": 1,
      "message": "I think we need to add alignedOffset here, but also the D3D12 drivers doesn\u0027t do the same RequiredBytesInCopy computation that we do here. Instead it does\n\n alignedOffset + copy.bufferSize.width * copy.bufferSize.height * copyBufferSize.depthOrArrayLayers * textureSpec.texelBlockSizeInBytes\n \nSo I think that\u0027s what we should use for bufferSizeForFootprint.",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb470f9b_a7af998b",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-03T05:39:44Z",
      "side": 1,
      "message": "Considering compressed formats, the computation you proposed should be:\n\nalignedOffset + widthInBlocksForFootprint * heightInBlocksForFootprint * copyBufferSize.depthOrArrayLayers * textureSpec.texelBlockSizeInBytes - Let\u0027s say it is [1]).\n\nOtherwise, some compressed unittest will fail. For example, textureSpec \u003d {0, 0, 0, 4, 4, 1, 8, 4, 4}, which means copyOrigin is {0, 0, 0}, and copySize is {4, 4, 1} and blockInfo is {8, 4, 4}. Note that copySize is just one pixel for this compressed format. So you previous computation will be: 0 + 4 * 4 * 1 * 8 \u003d 128. While the updated one I wrote above is 0 + 1 * 1 * 1 * 8 \u003d 8. And minimunBufferSize is 8. \n\nHowever, I think this computation is not the maximum pixel\u0027s ending location (or bufferSizeForFootprint). I feel like the correct one should be \n\ncopySize.alignedOffset + utils::RequiredBytesInCopy(....) - Let\u0027s say it is [2]. \n\nI did miss alignedOffset in my previous patchset (as you pointed out). \n\nExample: textureSpec \u003d {origin: {0, 0, 0}, copySize: {4, 5, 3}, blockInfo: {4, 1, 1}} and bufferSpec is {offset: 0, bytesPerRow: 256, rowsPerImage: 5}.\n\ncopy.bufferSize will be {4, 5, 3}, it is a pretty easy split. \n\nEquation [1] will be: 0 + 4 * 5 * 3 * 4 \u003d 240. \nEquation [2] will be: 0 + 256 * (5 * 3 - 1) + 4 * 4, it is much bigger than 240. \n\nFor equation [1], every row length is shorten to 4 (copySize.width) * 4 (textureSpec.texelBlockSizeInBytes) \u003d 16 bytes. \nFor equation [2], every row length but the last one is 256 (bytesPerRow) bytes, the last one is 4 * 4 \u003d 16 bytes, though. \nAnd the result of equation [2] equals to minimumBufferSize. So I chose equation [2] for comparison, WDYT?\n\nIn addition, the current unittest can only ensure its correctness for 2D non-array textures (at least for this new added test code snippet). See the comment I added.",
      "parentUuid": "d4aa3426_c6bc29e5",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20f9fa60_e3a49af0",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 68,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-03T08:42:03Z",
      "side": 1,
      "message": "Ah yes I forgot to take rowPitch and compressed textures into account (again \u003e_\u003e) \n\nThe overall comment is not about a specific expression, but that we need to have an invariant that all of the buffer\u0027s footprint given to D3D must be in bounds of the buffer, not just the texels copied. This is something that D3D12 validates (with the debug device it produces a validation error, in release mode it produces an error on commandList.Close()). So we need to have it as an invariant. For example this is why we need to split the very last row in the 3D split.\n\nWith your comments the expression [1] should become:\n  alignedOffset + rowPitch * heightInBlocksForFootprint * copyBufferSize.depthOrArrayLayers * textureSpec.texelBlockSizeInBytes\n\nWhich gives:  \n 0 + 256 * 5 * 3 * 4\n \nThe difference is that [1] uses 256 - 4*4 more bytes than [2].",
      "parentUuid": "eb470f9b_a7af998b",
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38db3394_d56258f7",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 249,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-02T17:38:33Z",
      "side": 1,
      "message": "I feel like that bytesPerRow of 512 and 768 are not well tested. Both of them are greater than 256 (the minimum allowed bytesPerRow), and one is 512B-aligned, the other is not. \n\nIn addition, when bytesPerRow is 256/512/768, multiple rows and multiple depth or array slices are not well tested. \n\nSo I added a few more tests for these situations.",
      "range": {
        "startLine": 243,
        "startChar": 1,
        "endLine": 249,
        "endChar": 0
      },
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "324924b8_32f802fe",
        "filename": "src/tests/unittests/d3d12/CopySplitTests.cpp",
        "patchSetId": 7
      },
      "lineNbr": 249,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-02T19:13:21Z",
      "side": 1,
      "message": "Great!",
      "parentUuid": "38db3394_d56258f7",
      "range": {
        "startLine": 243,
        "startChar": 1,
        "endLine": 249,
        "endChar": 0
      },
      "revId": "f00bc1cc243fba6cd2d69bf30900c51fc48df1b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}