{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e505b432_8771e527",
        "filename": "src/dawn_native/d3d12/D3D11on12Util.cpp",
        "patchSetId": 22
      },
      "lineNbr": 132,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-07-21T09:09:13Z",
      "side": 1,
      "message": "const_cast is something that we like to avoid in general? Is there any way to not do it while still keeping the keys as values (compared to unique_ptr previsouly?)\n\nIf not, feel free to close this.",
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "167b354b_afa17c26",
        "filename": "src/dawn_native/d3d12/D3D11on12Util.cpp",
        "patchSetId": 22
      },
      "lineNbr": 132,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2021-07-21T18:09:03Z",
      "side": 1,
      "message": "Can we eliminate the const_cast by making GetDXGIKeyedMutex a const method?",
      "parentUuid": "e505b432_8771e527",
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "861042c7_6a13132c",
        "filename": "src/dawn_native/d3d12/D3D11on12Util.cpp",
        "patchSetId": 22
      },
      "lineNbr": 132,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2021-07-21T19:32:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "167b354b_afa17c26",
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb561b7d_ca44783b",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 22
      },
      "lineNbr": 603,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2021-07-21T18:09:03Z",
      "side": 1,
      "message": "(Apologies for not opening this issue earlier)\n\nIf the ExternalImage object outlives the Dawn device, then then the code you added in this CL to Flush the 11on12 device upon ExternalImage destruction should avoid memory leaks. I don\u0027t think we need this particular piece of code for that case.\n\nFrom Corentin\u0027s comment in https://bugs.chromium.org/p/dawn/issues/detail?id\u003d625#c62, the reason we need this particular flush is the case is when the ExternalImage object gets destroyed but there are still references to the D3D resource in Dawn\u0027s internal data structures. In that case, we will hold onto the D3D12 resource all the way until the Dawn device gets destroyed, which might be much later in the case where videos textures, canvas elements and other shared images come and go.\n\nTo mitigate this, would it be possible to make ExternalImageDXGI (or an internal object of some sort) to be a reference counted object? If we do that, we can make the DawnTexture object hold a reference to this internal object and, then, only when the internal object\u0027s reference count goes to zero do we perform the flush. I think this should solve cases where ExternalObject outlasts Dawn devices and vice versa.",
      "range": {
        "startLine": 602,
        "startChar": 1,
        "endLine": 603,
        "endChar": 26
      },
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38db4d47_a4a9f7b6",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 22
      },
      "lineNbr": 603,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2021-07-21T19:32:02Z",
      "side": 1,
      "message": "I\u0027m confused. I did not add this code for the case when ExternalImage destruction occurs so I could not follow your comment. I understood c62 to be when the WGPUTexture gets destroyed, not the external image, and it\u0027s also referring to the flush on ~Device case. What am I missing?",
      "parentUuid": "bb561b7d_ca44783b",
      "range": {
        "startLine": 602,
        "startChar": 1,
        "endLine": 603,
        "endChar": 26
      },
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e137d60_74230339",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 22
      },
      "lineNbr": 603,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2021-07-21T20:08:18Z",
      "side": 1,
      "message": "There\u0027s three cases that I think are relevant:\n\n1) *ExternalImage gets destroyed BEFORE Dawn gets destroyed*. In this case, your CL will Flush the 11on12device as well as release the ID3D12Resource. No memory leaks.Yay!\n\n2) *ExternalImage gets destroyed AFTER Dawn gets destroyed*.The ExternalImage will continue to hold onto the ID3D12Resource like it did before your CL. The IDXGIKeyedMutex just points to the same piece of memory that the ID3D12Resource does. When the ExternalImage eventually gets destroyed, it will clean everything up (including all of the 11on12devices it caches) and avoid memory leaks. I\u0027m failing to see the need for flushing in the destructor of the Dawn device in this case. Sure, it will make the 11on12 device release its reference but the ExternalImage is still keeping the resource alive by holding onto a reference via ID3D12Resource. \n\n3) *ExternalImage gets destroyed first but Dawn still has references to the Dawn texture via internal objects*. Here ExternalImage will release a reference (but not the last reference) to the ID3D12Resource. The other reference is held by the Dawn texture. While Externalimage does flush the 11on12Device upon destruction, Dawn will cause the 11on12 device to re-attach itself when Dawn calls ReleaseKeyedMutex.  Yes, your code here in the destructor will cause Dawn to release the last reference to the resource but that will happen when Dawn gets destroyed. Dawn destruction might happen long after the ExternalImage gets destroyed. This is a new problem with your change. Before your change, when the Dawn texture got freed, it released the last reference to the ID3D12Resource AND told the 11on12device to also release its references. \n\nI think we can fix #3 with my proposal above.",
      "parentUuid": "38db4d47_a4a9f7b6",
      "range": {
        "startLine": 602,
        "startChar": 1,
        "endLine": 603,
        "endChar": 26
      },
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c17d0f18_b9bda760",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 22
      },
      "lineNbr": 603,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2021-07-21T21:44:01Z",
      "side": 1,
      "message": "Thanks, RC. That was helpful. But I need more clarification.\n\n\u003e Sure, it will make the 11on12 device release its reference but the ExternalImage is still keeping the resource alive\n\nSeems bad to keep a bunch of no-longer-needed references on the 11on12 device around forever. No concern there?\n\n\u003e Dawn will cause the 11on12 device to re-attach itself when Dawn calls ReleaseKeyedMutex. \n\nIn this CL, Dawn does not call ReleaseKeyedMutex anymore so how does the 11on12 device re-attach itself once the ExternalImage gets destroyed?",
      "parentUuid": "6e137d60_74230339",
      "range": {
        "startLine": 602,
        "startChar": 1,
        "endLine": 603,
        "endChar": 26
      },
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e594fa0b_851f9a17",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 22
      },
      "lineNbr": 603,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2021-07-21T23:27:01Z",
      "side": 1,
      "message": "\u003e Seems bad to keep a bunch of no-longer-needed references on the 11on12 device around forever. No concern there?\n\nThis situation can happen if there are one or more 2D canvas elements or videos on the page who\u0027s shared images outlast the Dawn device on account of garbage collection. \n\n\u003e In this CL, Dawn does not call ReleaseKeyedMutex anymore so how does the 11on12 device re-attach itself once the ExternalImage gets destroyed?\n\nApologies for being unclear. By \"release keyed mutex\", I mean that Dawn calls AcquireSync or ReleaseSync on the mutex.\n\nIf the web developer imports (via zero copy) a shared image into Dawn and holds a reference to the Dawn texture while the video or 2D canvas gets garbage collected, the ExternalImage will be destroyed while Dawn still holds a reference to the underlying ID3D12Resource and ID3D11KeyedMutex. Garbage collection can happen at any time in the render process when V8 detects a particular object no longer has any roots. \n\nIn this case, Dawn will release the ID3D11Resource and ID3D11KeyedMutex when the texture is destroyed at the end of the frame but the 11on12 device inside of Dawn will hold onto the reference for the lifetime of the Dawn device.",
      "parentUuid": "c17d0f18_b9bda760",
      "range": {
        "startLine": 602,
        "startChar": 1,
        "endLine": 603,
        "endChar": 26
      },
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85b1c639_ff3b641a",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 22
      },
      "lineNbr": 603,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2021-07-22T17:20:58Z",
      "side": 1,
      "message": "Thanks, Rafael. That makes sense to me and is a very good observation \u003d). I reverted back to shared_ptr which does eliminate my concern to Flush on ~Device.",
      "parentUuid": "e594fa0b_851f9a17",
      "range": {
        "startLine": 602,
        "startChar": 1,
        "endLine": 603,
        "endChar": 26
      },
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "17bb64eb_10a90608",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 22
      },
      "lineNbr": 603,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2021-07-22T18:05:53Z",
      "side": 1,
      "message": "Would it be heretical to suggest that we make ExternalImageDXGI be reference counted and have both Dawn (via DawnTexture) and Chromium (via SharedImage) keep a reference? When the last component releases the object, it releases the ID3D12Resouce and flushes the references from the 11on12 Device.",
      "parentUuid": "85b1c639_ff3b641a",
      "range": {
        "startLine": 602,
        "startChar": 1,
        "endLine": 603,
        "endChar": 26
      },
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "680f3e83_3ea9b50d",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 22
      },
      "lineNbr": 603,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2021-07-22T23:05:56Z",
      "side": 1,
      "message": "I could follow-up but ExternalImage is not being shared atm (I made it unique) so I opt\u0027d to share these (internal) cache entries instead. This also allows me to use RefCounted which I don\u0027t know if we can use with ExternalImage.",
      "parentUuid": "17bb64eb_10a90608",
      "range": {
        "startLine": 602,
        "startChar": 1,
        "endLine": 603,
        "endChar": 26
      },
      "revId": "f60e89e9668ef15eff86fe433bd8ecf85383547d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}