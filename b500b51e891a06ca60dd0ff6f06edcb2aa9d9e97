{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ed207959_29ee65f1",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-12-03T09:14:47Z",
      "side": 1,
      "message": "This is a great find that the extra padding at the end of the bound memory is what is causing the issue here. I dug a bit in the Vulkan spec and it seems to be an Nvidia driver bug maybe? It seems that robustBufferAccess should take into account the size of the buffer, not its bound size.\n\nMaybe it is worth filing an issue on https://github.com/KhronosGroup/Vulkan-Docs to clarify that (by saying VkBufferCreateInfo::size explicitly?)\n\nhttps://www.khronos.org/registry/vulkan/specs/1.2/html/vkspec.html#:~:text\u003drobustBufferAccess%20specifies%20that%20accesses%20to%20buffers%20are%20bounds%2Dchecked%20against%20the%20range%20of%20the%20buffer%20descriptor%20(as%20determined%20by%20VkDescriptorBufferInfo%3A%3Arange%2C%20VkBufferViewCreateInfo%3A%3Arange%2C%20or%20the%20size%20of%20the%20buffer).\n\nIn all cases as a workaround, or if the size is turns out to be the bound size, then this fix looks like it is in the correct direction, but has a hidden assumption that the memory requirements of the larger buffer will be the same as the original one. However there is no guarantee for this in the list of guarantees from vkGetBufferMemoryRequirements.\n\nhttps://www.khronos.org/registry/vulkan/specs/1.2/html/vkspec.html#:~:text\u003dThe%20implementation%20guarantees%20certain%20properties%20about%20the%20memory%20requirements%20returned%20by%20vkGetBufferMemoryRequirements%20and%20vkGetImageMemoryRequirements%3A\n\nI think that it is a fair assumption though. I tried to look for Vulkan spec text that describes how buffers are laid out in memory, and the memory aliasing section say that that buffers are host-accessible resources (they are linear) so I think they are specced to purely represent a range of memory and so we could have that guarantee. But it\u0027s worth opening an issue on the Vulkan spec too.\n\nHowever we can\u0027t really wait for the Vulkan spec clarifications on this and for the drivers to be fixed. So I think we should move ahead with this CL. Can we have a Debug-only code path that checks that the memory requirements of the new buffer are the same as the previous one? (Only the size needs to be checked, the rest is guaranteed) as well as a test that tries to stress-test this code path by creating buffers with many size alignments and many combinations of usages?\n\nIn the future if it is an Nvidia-specific bug we could add a Toggle etc.",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e0a53142_7ebe3d88",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2021-12-06T19:22:24Z",
      "side": 1,
      "message": "So actually, I don\u0027t think that it is necessarily an Nvidia issue only. I believe that the spec cited:\n\n```\nrobustBufferAccess specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by VkDescriptorBufferInfo::range, VkBufferViewCreateInfo::range, or the size of the buffer).\n```\n\nholds true, however, a bit further down, the actual return value when the access is OOB is described:\n\n```\nIf a vertex input attribute is out of bounds, it will be assigned one of the following values:\n\n(1) Values from anywhere within the memory range(s) bound to the buffer, converted according to the format of the attribute.\n(2) Zero values, format converted according to the format of the attribute.\n(3) Zero values, or (0,0,0,x) vectors, as described above.\n```\n\nSo what I think is happening is that we *are* OOB, however we are returning (1) something in the bound memory range (not the buffer descriptor size range).\n\nI will file an issue nonetheless indicating the issue and how we are planning to work around it and see if we get any good responses.\n\nI also agree that, unfortunately, we are making some assumptions about the second handle and its memory requirements for this to work, so I did add the debug code-path for now.",
      "parentUuid": "ed207959_29ee65f1",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c897a314_1fea7c1f",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2021-12-06T23:25:31Z",
      "side": 1,
      "message": "Hmm actually, it seems like with the debug code-path, I actually see that the size values can actually be different for the original and the new buffer handles...",
      "parentUuid": "e0a53142_7ebe3d88",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47c6d0a7_059297bf",
        "filename": "src/tests/white_box/BufferAllocatedSizeTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-12-03T09:14:47Z",
      "side": 1,
      "message": "Maybe instead the test needs to be updated to get the allocation size for kMinBufferSize, then do allocationSize + 1 and check it is still aligned, etc.",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9f8e6df1_3a42b866",
        "filename": "src/tests/white_box/BufferAllocatedSizeTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2021-12-06T19:22:24Z",
      "side": 1,
      "message": "Hmm I just tried this but this has some issues when the requiredBufferAlignment is actually 1, since IIUC, we are pretty much assuming the actual returned size to be the alignment criteria, but we are not asking for a buffer of size 1 so there is no way to know. I will keep this as is for now until we can find a better way to do it.",
      "parentUuid": "47c6d0a7_059297bf",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}