{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ed207959_29ee65f1",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-12-03T09:14:47Z",
      "side": 1,
      "message": "This is a great find that the extra padding at the end of the bound memory is what is causing the issue here. I dug a bit in the Vulkan spec and it seems to be an Nvidia driver bug maybe? It seems that robustBufferAccess should take into account the size of the buffer, not its bound size.\n\nMaybe it is worth filing an issue on https://github.com/KhronosGroup/Vulkan-Docs to clarify that (by saying VkBufferCreateInfo::size explicitly?)\n\nhttps://www.khronos.org/registry/vulkan/specs/1.2/html/vkspec.html#:~:text\u003drobustBufferAccess%20specifies%20that%20accesses%20to%20buffers%20are%20bounds%2Dchecked%20against%20the%20range%20of%20the%20buffer%20descriptor%20(as%20determined%20by%20VkDescriptorBufferInfo%3A%3Arange%2C%20VkBufferViewCreateInfo%3A%3Arange%2C%20or%20the%20size%20of%20the%20buffer).\n\nIn all cases as a workaround, or if the size is turns out to be the bound size, then this fix looks like it is in the correct direction, but has a hidden assumption that the memory requirements of the larger buffer will be the same as the original one. However there is no guarantee for this in the list of guarantees from vkGetBufferMemoryRequirements.\n\nhttps://www.khronos.org/registry/vulkan/specs/1.2/html/vkspec.html#:~:text\u003dThe%20implementation%20guarantees%20certain%20properties%20about%20the%20memory%20requirements%20returned%20by%20vkGetBufferMemoryRequirements%20and%20vkGetImageMemoryRequirements%3A\n\nI think that it is a fair assumption though. I tried to look for Vulkan spec text that describes how buffers are laid out in memory, and the memory aliasing section say that that buffers are host-accessible resources (they are linear) so I think they are specced to purely represent a range of memory and so we could have that guarantee. But it\u0027s worth opening an issue on the Vulkan spec too.\n\nHowever we can\u0027t really wait for the Vulkan spec clarifications on this and for the drivers to be fixed. So I think we should move ahead with this CL. Can we have a Debug-only code path that checks that the memory requirements of the new buffer are the same as the previous one? (Only the size needs to be checked, the rest is guaranteed) as well as a test that tries to stress-test this code path by creating buffers with many size alignments and many combinations of usages?\n\nIn the future if it is an Nvidia-specific bug we could add a Toggle etc.",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e0a53142_7ebe3d88",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2021-12-06T19:22:24Z",
      "side": 1,
      "message": "So actually, I don\u0027t think that it is necessarily an Nvidia issue only. I believe that the spec cited:\n\n```\nrobustBufferAccess specifies that accesses to buffers are bounds-checked against the range of the buffer descriptor (as determined by VkDescriptorBufferInfo::range, VkBufferViewCreateInfo::range, or the size of the buffer).\n```\n\nholds true, however, a bit further down, the actual return value when the access is OOB is described:\n\n```\nIf a vertex input attribute is out of bounds, it will be assigned one of the following values:\n\n(1) Values from anywhere within the memory range(s) bound to the buffer, converted according to the format of the attribute.\n(2) Zero values, format converted according to the format of the attribute.\n(3) Zero values, or (0,0,0,x) vectors, as described above.\n```\n\nSo what I think is happening is that we *are* OOB, however we are returning (1) something in the bound memory range (not the buffer descriptor size range).\n\nI will file an issue nonetheless indicating the issue and how we are planning to work around it and see if we get any good responses.\n\nI also agree that, unfortunately, we are making some assumptions about the second handle and its memory requirements for this to work, so I did add the debug code-path for now.",
      "parentUuid": "ed207959_29ee65f1",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c897a314_1fea7c1f",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2021-12-06T23:25:31Z",
      "side": 1,
      "message": "Hmm actually, it seems like with the debug code-path, I actually see that the size values can actually be different for the original and the new buffer handles...",
      "parentUuid": "e0a53142_7ebe3d88",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d549218b_8c437ad8",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-12-07T09:10:06Z",
      "side": 1,
      "message": "Re-reading the spec I think I agree with your interpretation.\n\nCan we have another Vulkan-Docs issue for the addition of a new vkGetBufferMemoryRequirements guarantee so that drivers are forced to give us the same size for both handles?\n\nDo you have an example of when the debug code-path triggers and what the sizes are?\n\nAlso this can kind be a security issue but luckily it only happens on Nvidia Vulkan and we only ship by default on ChromeOS that doesn\u0027t have Nvidia GPUs. Can we also have a Dawn end2end test that repros this failure on its own so we can check if other GPUs have the same issue? (just they don\u0027t show it with this particular example) For example:\n - Allocated a large buffer and fill it with 1s.\n - Deallocates it.\n - Wait for GPU command completion and ticks the device multiple time to make sure it actually freed the space in the sub allocator.\n - Allocates a smaller buffer, zeroes it.\n - Sample the buffer OOB like in the test that was failing and check the value is 0.\n\nThe only proper fix I can see right now if requirements.size !\u003d newRequirements.size is to use the new buffer to do a fillBuffer operation on exactly the extra bytes mark the created buffer as \"last used with TransferDst\" so that the correct pipeline barrier is added on first use to see the written padding. This requires over-allocating the memory given to the suballocator though even a buffer placed at the very end of it can have a bigger buffer created to fill the padding. Ew.",
      "parentUuid": "c897a314_1fea7c1f",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88707752_e32548f9",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2021-12-08T20:20:46Z",
      "side": 1,
      "message": "```\nCan we have another Vulkan-Docs issue for the addition of a new vkGetBufferMemoryRequirements guarantee so that drivers are forced to give us the same size for both handles?\n\u0027\u0027\u0027\nSure, I will file one.\n\n```\nDo you have an example of when the debug code-path triggers and what the sizes are?\n```\nI just saw failures when running CQ. I will repro and try to get concrete numbers.\n\n```\nCan we also have a Dawn end2end test that repros this failure\n```\nWill do along with the other fixes.\n\n```\nThe only proper fix I can see right now ...\n```\nI am a bit confused about the wording of the suggested fix. Can you elaborate a bit?\n\nAlternatively, this is what I was thinking and maybe you can correct/update on what parts of it could be improved:\n\n- Allocate buffer handle 1\n- Get requirements for handle 1\n- Allocate buffer handle 2 using size in requirements for handle 1\n- Get requirements for handle 2 (If different...)\n- Allocate actual memory based on requirements for handle 2\n- Bind memory to handle 2 and zero out region up to req.size for handle 1\n- (Optionally?) Unbind memory from handle 2, and bind to handle 1.",
      "parentUuid": "d549218b_8c437ad8",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a68ef51e_b8ecebe1",
        "filename": "src/dawn_native/vulkan/BufferVk.cpp",
        "patchSetId": 2
      },
      "lineNbr": 208,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2021-12-08T20:23:53Z",
      "side": 1,
      "message": "Ugh.. sorry the formatting got really messed up... Since there\u0027s no way to edit here is a revised version of the comment:\n\n```\nCan we have another Vulkan-Docs issue for the addition of a new vkGetBufferMemoryRequirements guarantee so that drivers are forced to give us the same size for both handles?\n```\n\nSure, I will file one.\n\n```\nDo you have an example of when the debug code-path triggers and what the sizes are?\n```\n\nI just saw failures when running CQ. I will repro and try to get concrete numbers.\n\n```\nCan we also have a Dawn end2end test that repros this failure\n```\n\nWill do along with the other fixes.\n\n```\nThe only proper fix I can see right now ...\n```\n\nI am a bit confused about the wording of the suggested fix. Can you elaborate a bit?\n\nAlternatively, this is what I was thinking and maybe you can correct/update on what parts of it could be improved:\n- Allocate buffer handle 1\n- Get requirements for handle 1\n- Allocate buffer handle 2 using size in requirements for handle 1\n- Get requirements for handle 2 (If different...)\n- Allocate actual memory based on requirements for handle 2\n- Bind memory to handle 2 and zero out region up to req.size for handle 1\n- (Optionally?) Unbind memory from handle 2, and bind to handle 1.",
      "parentUuid": "88707752_e32548f9",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47c6d0a7_059297bf",
        "filename": "src/tests/white_box/BufferAllocatedSizeTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-12-03T09:14:47Z",
      "side": 1,
      "message": "Maybe instead the test needs to be updated to get the allocation size for kMinBufferSize, then do allocationSize + 1 and check it is still aligned, etc.",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9f8e6df1_3a42b866",
        "filename": "src/tests/white_box/BufferAllocatedSizeTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2021-12-06T19:22:24Z",
      "side": 1,
      "message": "Hmm I just tried this but this has some issues when the requiredBufferAlignment is actually 1, since IIUC, we are pretty much assuming the actual returned size to be the alignment criteria, but we are not asking for a buffer of size 1 so there is no way to know. I will keep this as is for now until we can find a better way to do it.",
      "parentUuid": "47c6d0a7_059297bf",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f1bca95d_b931214e",
        "filename": "src/tests/white_box/BufferAllocatedSizeTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-12-07T09:10:06Z",
      "side": 1,
      "message": "In Vulkan we still require an alignment of 4, it\u0027s just that it can be larger, so wouldn\u0027t changing the logic to be in terms of alignment instead of exact size make this work?",
      "parentUuid": "9f8e6df1_3a42b866",
      "revId": "b500b51e891a06ca60dd0ff6f06edcb2aa9d9e97",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}