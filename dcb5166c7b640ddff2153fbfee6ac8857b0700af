{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0f7e6762_9769e659",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-01-05T10:46:44Z",
      "side": 1,
      "message": "PTAL, thanks!",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "385435f4_a67db9f5",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 25,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "Can we have a TODO to have a FakeWorkerPool for UWP? You can\u0027t create threads in UWP apparently, and I\u0027m sure people will eventually start using Dawn there.",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "262f733d_24aa6878",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 28,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "nit: since we declare the class in this .cpp file we can declare all of the implementation inline.",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4b0d9dc_56143112",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 54,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "nit: IsComplete may be a better name",
      "range": {
        "startLine": 54,
        "startChar": 29,
        "endLine": 54,
        "endChar": 36
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66709b66_a32f9d34",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 55,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "Do we ever expect to call IsReady? My understanding is that the CreateReadyPipeline task would \"push\" to the device it\u0027s result. If we don\u0027t expect to call it, then we could remove mMutex. Alternatively we could set an atomic\u003cbool\u003e from inside the lambda in the std::async.",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63829b85_7ed1e951",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 74,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "could we construct the event with the future instead of setting it later?",
      "range": {
        "startLine": 71,
        "startChar": 8,
        "endLine": 74,
        "endChar": 19
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29975a38_f1552d8b",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 74,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "This could be done by passing the Closure to the constructor of AsyncWaitableEvent.",
      "parentUuid": "63829b85_7ed1e951",
      "range": {
        "startLine": 71,
        "startChar": 8,
        "endLine": 74,
        "endChar": 19
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ed341a1_012d9043",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 82,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "what is this lock for?",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 71
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fbc4090_2c82ed0e",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "why not have:\n\nvirtual WorkerThreadPool* dawn_platform::Platform::CreateThreadPool() ?\n\nThen Chromium can override that to implement its own pool, and Dawn can provide a simple default implementation with async/futures.",
      "range": {
        "startLine": 90,
        "startChar": 4,
        "endLine": 97,
        "endChar": 5
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49f95af2_5a1c809d",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-01-06T02:05:05Z",
      "side": 1,
      "message": "Now I mainly use the implementation in ANGLE as my reference. In ANGLE the Chromium just provides an API called postWorkerTask(), and ANGLE does its wrapper on this external function by implementing a DelegateWorkerThread(). I once planned to add a similar wrapper in Dawn after the related code in Chromium for Dawn is ready, what do you think?\n\nhttps://source.chromium.org/chromium/chromium/src/+/master:ui/gl/angle_platform_impl.cc;l\u003d132\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/angle/src/libANGLE/WorkerThread.cpp;l\u003d322",
      "parentUuid": "5fbc4090_2c82ed0e",
      "range": {
        "startLine": 90,
        "startChar": 4,
        "endLine": 97,
        "endChar": 5
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d2a0297_8f75b8d4",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T02:15:39Z",
      "side": 1,
      "message": "I see that. Maybe it\u0027s because ANGLE is using a list of function pointers for the platform members instead of a virtual interface that the embedder overrides.\n\nI think we could also have\n\nWorkerThreadPool* CreateThreadPool() and a\n\nvirtual void WorkerThreadPool::postWorkerTask(task, ...) \u003d 0;\n\nwhich Chrome implements. It would give us a similar API using virtual classes instead.\n\nPersonally I think the virtual class approach is cleaner, provides more type safety, and is the \"C++ way\" to do it. The ANGLE approach is more C-style, but maybe Corentin knows more about the motivations there. FWIW, the virtual approach is the way the rest of the dawn_platform stuff works today and would be better for consistency to continue doing it like that unless there\u0027s a good reason to switch.",
      "parentUuid": "49f95af2_5a1c809d",
      "range": {
        "startLine": 90,
        "startChar": 4,
        "endLine": 97,
        "endChar": 5
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d75015bb_b94173b4",
        "filename": "src/common/WorkerThread.cpp",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "The reason for the C API in ANGLE is because it is a shared library loaded at runtime so the only safe interface is through the C API. (We run into many many problems when sharing C++ objects, like having different std::string implementation, different instance of the same memory allocator, ...). +1 to Austin\u0027s suggestion of having a C++ API between Dawn and Chromium.",
      "parentUuid": "3d2a0297_8f75b8d4",
      "range": {
        "startLine": 90,
        "startChar": 4,
        "endLine": 97,
        "endChar": 5
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78b60d40_42b7f50c",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 26,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "nit: this is in common/ so there should be no namespace. One day we should move everything in common/ into a dawn:: namespace.",
      "range": {
        "startLine": 26,
        "startChar": 10,
        "endLine": 26,
        "endChar": 21
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6290d394_e005c0cb",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 46,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "nit: probably give these their own headers as NonCopyable in particular could be useful for other classes.",
      "range": {
        "startLine": 30,
        "startChar": 4,
        "endLine": 46,
        "endChar": 0
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0729fd5_7b2c1190",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "nit: Wait",
      "range": {
        "startLine": 56,
        "startChar": 55,
        "endLine": 56,
        "endChar": 59
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6b8ae4d_eb6da20b",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "nit: put implementations in the .cpp",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26ca8766_4037dbbe",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "Can we use Ref\u003cT\u003e and Dawn\u0027s RefCounted class?",
      "range": {
        "startLine": 63,
        "startChar": 8,
        "endLine": 63,
        "endChar": 23
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68167e93_5c990a04",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 68,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "nit: Maybe \"WorkerTaskPool\" as it could be implemented with only a single thread",
      "range": {
        "startLine": 68,
        "startChar": 10,
        "endLine": 68,
        "endChar": 26
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1fac5984_090f464e",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 70,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "ditto",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3140ba17_8c3cd40d",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 80,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "nit: This is the task count, not the thread count",
      "range": {
        "startLine": 80,
        "startChar": 17,
        "endLine": 80,
        "endChar": 39
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4f9ef91_d6f95007",
        "filename": "src/common/WorkerThread.h",
        "patchSetId": 3
      },
      "lineNbr": 83,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "This is mRunningTasks.",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fc419aa_9c8a048d",
        "filename": "src/tests/unittests/WorkerThreadTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "nit: why is this called \"waitableLock\" ?",
      "range": {
        "startLine": 40,
        "startChar": 40,
        "endLine": 40,
        "endChar": 52
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8634cc4e_8fc339cf",
        "filename": "src/tests/unittests/WorkerThreadTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 109,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "We Tick only after waiting all tasks. Maybe instead of this logic we could just check that mTaskResultQueue has all the values we care about?",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1393c88a_2f1ce645",
        "filename": "src/tests/unittests/WorkerThreadTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T00:59:37Z",
      "side": 1,
      "message": "nit: std::atomic\u003cuint32_t\u003e\n\nwe had an issue where the atomic_uint32_t alias wasn\u0027t defined for MSVC",
      "range": {
        "startLine": 127,
        "startChar": 13,
        "endLine": 127,
        "endChar": 28
      },
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37a495c6_f47de1c4",
        "filename": "src/tests/unittests/WorkerThreadTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 130,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-01-06T13:59:25Z",
      "side": 1,
      "message": "It seems that we split Tracker in two to workaround definition order issues? Maybe we could declare SimpleTask first, then define Tracker then define SimpleTask?",
      "revId": "dcb5166c7b640ddff2153fbfee6ac8857b0700af",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}