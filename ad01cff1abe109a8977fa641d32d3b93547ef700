{
  "comments": [
    {
      "key": {
        "uuid": "fba48d29_6a2d9f97",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "This could fail if we have two heaps that we reuse, A and B, and that we roll-over twice so we use heaps in this order: A B A. If the bindgroup was populated on A, then not used until the third step, this check will succeed even if we should re-record the bindgroup.\n\nI suggest using a Serial that\u0027s incremented on a heap switch, and storing that serial in the bindgroup. (not sure if we want one combined serial for both the sampler and cbvSrvUav heap or two serials).\n\nActually I\u0027m worried that the 2048 limit for sampler heaps will mean we\u0027ll need to cycle the sampler heap way more often than the other :/",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "958c1169_2bc8fb63",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "\u003e This could fail if we have two heaps that we reuse, A and B, and that we roll-over twice\n\nUnless I\u0027m missing something obvious, I don\u0027t think that\u0027s possible. The bindgroup allocation (originally encoded in heap A) should be be re-encoded on heap B (according to the BGL). The heap serial is not needed because we only care if it\u0027s resident in the currently bound heap or not - heap A is no longer used once switched.\n\n\u003e Actually I\u0027m worried that the 2048 limit for sampler heaps will mean we\u0027ll need to cycle the sampler heap way more often than the other :/\n\nThere does exist static samplers that do not count toward the limit. However, these are unchanging which is a departure from the current model.",
      "parentUuid": "fba48d29_6a2d9f97",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f86e383e_0c8e8c15",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-12T17:59:21Z",
      "side": 1,
      "message": "BindGroup 1 --\u003e on heap A\n...\nBindGroup 2 --\u003e allocating causes heap switch --\u003e on heap B\n...\nBindGroup 3 --\u003e allocating causes heap switch --\u003e on heap A (in the same memory as BindGroup 1)\n\nNow, BindGroup 1 and 3 alias the same memory and are both on the current active heap A.\n\n\nRe: samplers\nMaybe we can track and cycle the two heaps separately. Or somehow detect when we should use static samplers? Rather not make this CL more complex though.",
      "parentUuid": "958c1169_2bc8fb63",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba602527_44dca4e0",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T19:12:38Z",
      "side": 1,
      "message": "\u003e Now, BindGroup 1 and 3 alias the same memory and are both on the current active heap A.\n\nI\u0027m still confused \u003d( How could heap A remain currently bound after BindGroup 2 causes a heap  switch from heap A to heap B? I would expect BindGroup 1 to be allocated on heap A then again on heap B upon the switch. If so, BindGroup 3 could only be allocated from heap B and so on.\n\nCould you please point to the error in this reasoning?",
      "parentUuid": "f86e383e_0c8e8c15",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f62abc7_e7bb9ff6",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-12T19:18:27Z",
      "side": 1,
      "message": "Whoops. I looked again and was wrong. I was under the impression that the DescriptorHeapAllocator could reuse old heaps, but now see that we just create a new one every time. So I think this part should be okay.\n\nDo you ever forsee us recycling heaps? Perhaps the D3D12 driver already does this internally or creating/destroying them is relatively cheap.",
      "parentUuid": "ba602527_44dca4e0",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c626b89a_8a674b2e",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-13T15:18:45Z",
      "side": 1,
      "message": "Even if we don\u0027t recycle heaps we need a serial. For example:\n\nbindgroup1 -\u003e heap A1 at offset 0\n// stuff that causes rollover and to use heap B\n// heap A is no longer in use and given back to the driver\n\n// Rollover, driver gives us a new heap that happens to have the same pointer as heap A1\nbindgroup2 -\u003e heap A2 at offset 0\nbindgroup1 -\u003e Hey that\u0027s the same pointer so I don\u0027t need to populate, I\u0027m at heap A2 offset 0 too.",
      "parentUuid": "3f62abc7_e7bb9ff6",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e3eb2ce_c80a1262",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-13T19:30:10Z",
      "side": 1,
      "message": "\u003e Even if we don\u0027t recycle heaps we need a serial. For example:\n\nIn that example, BG1 (the very last step) would be re-encoded in A2 at offset 0 and BG2 would be encoded in A2 at offset 1. Even if the pointer happens to point to the old heap, it still re-encodes ALL BGs from the start again upon switching heaps - ensuring no conflicts.\n\n\u003e Do you ever forsee us recycling heaps? Perhaps the D3D12 driver already does this internally or creating/destroying them is relatively cheap.\n\nNo plans. I wouldn\u0027t expect the D3D12/driver to do such management. Ideally, the same GPU heaps remain bound (due to the cost of switching).",
      "parentUuid": "c626b89a_8a674b2e",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5366f94f_a9dd0d43",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-13T22:29:54Z",
      "side": 1,
      "message": "BG2 --\u003e new heap A2 --\u003e encoded for the first time at offset 0\nBG1 --\u003e happened to already be recorded at A2 offset 0 in the past. It is not re-encoded",
      "parentUuid": "0e3eb2ce_c80a1262",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a951c10_1ee08ce4",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-13T23:46:21Z",
      "side": 1,
      "message": "\u003e happened to already be recorded at A2 offset 0 in the past\n\nHow? This part confuses me.\n\nBG1 and BG2 can\u0027t share the same offset in A2 - it\u0027s not allowed by the allocator. Either BG1 was from A1 then re-encoded to A2 offset \u003d 1 OR BG1 was already from A2 offset \u003d 0 then BG2 will be offset \u003d 1.\n\nCan\u0027t tell if the logic is flawed or if this is an extra precaution.",
      "parentUuid": "5366f94f_a9dd0d43",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "189d8633_cde5abed",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-15T22:25:18Z",
      "side": 1,
      "message": "Our point is that the logic to know if we can skip the encoding is flawed and BG1 will think we are still using A1 because the pointer is the same as A2, so it will happily not reencode and start using A2 offset 0",
      "parentUuid": "7a951c10_1ee08ce4",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa72d3b2_26b822b2",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-16T19:20:53Z",
      "side": 1,
      "message": "Okay. I think I\u0027ve come up with a more concrete example:\n\n1. BG1 was allocated in A2 offset \u003d 0, serial N.\n2. Tick(N+1). // BG1\u0027s allocation gets de-allocated.\n3. BG2 is allocated in A2 offset \u003d 0 (same as BG1), serial N+1.\n\nBG1 now has a dangling pointer since nether heap gets invalidated after step (2). If this is correct, then I agree the serial check is needed.",
      "parentUuid": "189d8633_cde5abed",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c67f196c_3c463845",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 85,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "That\u0027s probably something to optimize in our BitSetIterator. Can you open a bug about the BitSetIterator and block dawn:304 on it?",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4041660_4f6c0c1d",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 85,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c67f196c_3c463845",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e47584c3_3dc4e06c",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 88,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "Mmmh here we allocated potentially more data than we need if the bindgroups can be reused. There should be an elegant way to phrase it as a recursive algorithm for the case where we need to cycle the heaps.\n\nSomething like\n\n MaybeError Apply -\u003e call ApplyInternal with isNewDescriptorHeapAllocation to false.\n\n MaybeError ApplyInternal(CommandRecordingContext* commandContext, bool isNewDescriptorHeapAllocation) {\n   for (bindgroup in dirtyBindGroups) {\n     bool outOfSpace;\n     DAWN_TRY_ASSIGN(outOfSpace, TryAllocateBindGroupIfNeeded(bindGroup));\n     if (outOfSpace) {\n       if (isNewDescriptorHeapAllocation) {\n         ASSERT(false); // We should never fail to allocate on a new heap allocation. Maybe we could find a different way to do this so we don\u0027t have to pipe the boolean argument.\n       }\n       dirtyBindGroups \u003d allBindGroups;\n       cycle descriptor heaps\n       return ApplyInternal(commandContext, true);\n     }\n   }\n }",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db4ee81c_139943dc",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 88,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-12T17:59:21Z",
      "side": 1,
      "message": "This is mostly what happens at [1]. The difference is that your suggestion is one-by-one allocation and the code at [1] allocates all of them at once -- and sometimes overcounts.\n\nI don\u0027t think counting correctly would be slow since there\u0027s only 4 bind groups and would only check the heapSerial. I think this makes it much more clear that cycling the heaps can happen strictly once.",
      "parentUuid": "e47584c3_3dc4e06c",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "859f5b35_f8186101",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 88,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-16T19:20:53Z",
      "side": 1,
      "message": "+1 AE. The bigger downside of the new approach is computing the counts for the infrequent case of spilling/overflow (vs no counts and allocating bindgroup-by-bindgroup). I prefer not to thrash until we have more data where the pre-pass is removed.",
      "parentUuid": "db4ee81c_139943dc",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "25048eaf_e52e8509",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 127,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-12T17:59:21Z",
      "side": 1,
      "message": "[1]",
      "range": {
        "startLine": 112,
        "startChar": 16,
        "endLine": 127,
        "endChar": 17
      },
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc130daa_23db67ae",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 202,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "This could probably be simplified by assuming we always have the two heaps.",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3cc74b3_7c59830e",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 202,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dc130daa_23db67ae",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    }
  ]
}