{
  "comments": [
    {
      "key": {
        "uuid": "fba48d29_6a2d9f97",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "This could fail if we have two heaps that we reuse, A and B, and that we roll-over twice so we use heaps in this order: A B A. If the bindgroup was populated on A, then not used until the third step, this check will succeed even if we should re-record the bindgroup.\n\nI suggest using a Serial that\u0027s incremented on a heap switch, and storing that serial in the bindgroup. (not sure if we want one combined serial for both the sampler and cbvSrvUav heap or two serials).\n\nActually I\u0027m worried that the 2048 limit for sampler heaps will mean we\u0027ll need to cycle the sampler heap way more often than the other :/",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "958c1169_2bc8fb63",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "\u003e This could fail if we have two heaps that we reuse, A and B, and that we roll-over twice\n\nUnless I\u0027m missing something obvious, I don\u0027t think that\u0027s possible. The bindgroup allocation (originally encoded in heap A) should be be re-encoded on heap B (according to the BGL). The heap serial is not needed because we only care if it\u0027s resident in the currently bound heap or not - heap A is no longer used once switched.\n\n\u003e Actually I\u0027m worried that the 2048 limit for sampler heaps will mean we\u0027ll need to cycle the sampler heap way more often than the other :/\n\nThere does exist static samplers that do not count toward the limit. However, these are unchanging which is a departure from the current model.",
      "parentUuid": "fba48d29_6a2d9f97",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c67f196c_3c463845",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 85,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "That\u0027s probably something to optimize in our BitSetIterator. Can you open a bug about the BitSetIterator and block dawn:304 on it?",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4041660_4f6c0c1d",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 85,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c67f196c_3c463845",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e47584c3_3dc4e06c",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 88,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "Mmmh here we allocated potentially more data than we need if the bindgroups can be reused. There should be an elegant way to phrase it as a recursive algorithm for the case where we need to cycle the heaps.\n\nSomething like\n\n MaybeError Apply -\u003e call ApplyInternal with isNewDescriptorHeapAllocation to false.\n\n MaybeError ApplyInternal(CommandRecordingContext* commandContext, bool isNewDescriptorHeapAllocation) {\n   for (bindgroup in dirtyBindGroups) {\n     bool outOfSpace;\n     DAWN_TRY_ASSIGN(outOfSpace, TryAllocateBindGroupIfNeeded(bindGroup));\n     if (outOfSpace) {\n       if (isNewDescriptorHeapAllocation) {\n         ASSERT(false); // We should never fail to allocate on a new heap allocation. Maybe we could find a different way to do this so we don\u0027t have to pipe the boolean argument.\n       }\n       dirtyBindGroups \u003d allBindGroups;\n       cycle descriptor heaps\n       return ApplyInternal(commandContext, true);\n     }\n   }\n }",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc130daa_23db67ae",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 202,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "This could probably be simplified by assuming we always have the two heaps.",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3cc74b3_7c59830e",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 202,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dc130daa_23db67ae",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    }
  ]
}