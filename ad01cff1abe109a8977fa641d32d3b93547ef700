{
  "comments": [
    {
      "key": {
        "uuid": "fba48d29_6a2d9f97",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "This could fail if we have two heaps that we reuse, A and B, and that we roll-over twice so we use heaps in this order: A B A. If the bindgroup was populated on A, then not used until the third step, this check will succeed even if we should re-record the bindgroup.\n\nI suggest using a Serial that\u0027s incremented on a heap switch, and storing that serial in the bindgroup. (not sure if we want one combined serial for both the sampler and cbvSrvUav heap or two serials).\n\nActually I\u0027m worried that the 2048 limit for sampler heaps will mean we\u0027ll need to cycle the sampler heap way more often than the other :/",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "958c1169_2bc8fb63",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "\u003e This could fail if we have two heaps that we reuse, A and B, and that we roll-over twice\n\nUnless I\u0027m missing something obvious, I don\u0027t think that\u0027s possible. The bindgroup allocation (originally encoded in heap A) should be be re-encoded on heap B (according to the BGL). The heap serial is not needed because we only care if it\u0027s resident in the currently bound heap or not - heap A is no longer used once switched.\n\n\u003e Actually I\u0027m worried that the 2048 limit for sampler heaps will mean we\u0027ll need to cycle the sampler heap way more often than the other :/\n\nThere does exist static samplers that do not count toward the limit. However, these are unchanging which is a departure from the current model.",
      "parentUuid": "fba48d29_6a2d9f97",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f86e383e_0c8e8c15",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-12T17:59:21Z",
      "side": 1,
      "message": "BindGroup 1 --\u003e on heap A\n...\nBindGroup 2 --\u003e allocating causes heap switch --\u003e on heap B\n...\nBindGroup 3 --\u003e allocating causes heap switch --\u003e on heap A (in the same memory as BindGroup 1)\n\nNow, BindGroup 1 and 3 alias the same memory and are both on the current active heap A.\n\n\nRe: samplers\nMaybe we can track and cycle the two heaps separately. Or somehow detect when we should use static samplers? Rather not make this CL more complex though.",
      "parentUuid": "958c1169_2bc8fb63",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba602527_44dca4e0",
        "filename": "src/dawn_native/d3d12/BindGroupD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 40,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T19:12:38Z",
      "side": 1,
      "message": "\u003e Now, BindGroup 1 and 3 alias the same memory and are both on the current active heap A.\n\nI\u0027m still confused \u003d( How could heap A remain currently bound after BindGroup 2 causes a heap  switch from heap A to heap B? I would expect BindGroup 1 to be allocated on heap A then again on heap B upon the switch. If so, BindGroup 3 could only be allocated from heap B and so on.\n\nCould you please point to the error in this reasoning?",
      "parentUuid": "f86e383e_0c8e8c15",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c67f196c_3c463845",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 85,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "That\u0027s probably something to optimize in our BitSetIterator. Can you open a bug about the BitSetIterator and block dawn:304 on it?",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4041660_4f6c0c1d",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 85,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c67f196c_3c463845",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e47584c3_3dc4e06c",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 88,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "Mmmh here we allocated potentially more data than we need if the bindgroups can be reused. There should be an elegant way to phrase it as a recursive algorithm for the case where we need to cycle the heaps.\n\nSomething like\n\n MaybeError Apply -\u003e call ApplyInternal with isNewDescriptorHeapAllocation to false.\n\n MaybeError ApplyInternal(CommandRecordingContext* commandContext, bool isNewDescriptorHeapAllocation) {\n   for (bindgroup in dirtyBindGroups) {\n     bool outOfSpace;\n     DAWN_TRY_ASSIGN(outOfSpace, TryAllocateBindGroupIfNeeded(bindGroup));\n     if (outOfSpace) {\n       if (isNewDescriptorHeapAllocation) {\n         ASSERT(false); // We should never fail to allocate on a new heap allocation. Maybe we could find a different way to do this so we don\u0027t have to pipe the boolean argument.\n       }\n       dirtyBindGroups \u003d allBindGroups;\n       cycle descriptor heaps\n       return ApplyInternal(commandContext, true);\n     }\n   }\n }",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db4ee81c_139943dc",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 88,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-12T17:59:21Z",
      "side": 1,
      "message": "This is mostly what happens at [1]. The difference is that your suggestion is one-by-one allocation and the code at [1] allocates all of them at once -- and sometimes overcounts.\n\nI don\u0027t think counting correctly would be slow since there\u0027s only 4 bind groups and would only check the heapSerial. I think this makes it much more clear that cycling the heaps can happen strictly once.",
      "parentUuid": "e47584c3_3dc4e06c",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "25048eaf_e52e8509",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 127,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-12T17:59:21Z",
      "side": 1,
      "message": "[1]",
      "range": {
        "startLine": 112,
        "startChar": 16,
        "endLine": 127,
        "endChar": 17
      },
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc130daa_23db67ae",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 202,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-10T17:27:45Z",
      "side": 1,
      "message": "This could probably be simplified by assuming we always have the two heaps.",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3cc74b3_7c59830e",
        "filename": "src/dawn_native/d3d12/CommandBufferD3D12.cpp",
        "patchSetId": 19
      },
      "lineNbr": 202,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2019-12-12T01:11:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dc130daa_23db67ae",
      "revId": "ad01cff1abe109a8977fa641d32d3b93547ef700",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    }
  ]
}