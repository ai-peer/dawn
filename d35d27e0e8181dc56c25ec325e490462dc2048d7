{
  "comments": [
    {
      "key": {
        "uuid": "3d57ecfd_75f126e1",
        "filename": "src/common/LinkedList.h",
        "patchSetId": 7
      },
      "lineNbr": 1,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-02-04T21:58:13Z",
      "side": 1,
      "message": "This is a near direct copy/paste of chromium/src/base/containers/linked_list.h",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04c4e37f_99ea6063",
        "filename": "src/dawn_native/d3d12/HeapD3D12.cpp",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-02-04T22:06:17Z",
      "side": 1,
      "message": "This is a particularly unsafe function - because someone could try to use it when the (dawn)Heap represents a directly allocated function, and try to use a ID3D12Resource as if it\u0027s a ID3D12Heap. I considered adding AllocationMethod to the constructor, but the member would only be used to ASSERT here. WDYT?",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2076208c_39264e04",
        "filename": "src/dawn_native/d3d12/HeapD3D12.cpp",
        "patchSetId": 7
      },
      "lineNbr": 32,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-02-04T22:50:52Z",
      "side": 1,
      "message": "How about additionally passing the d3d heap in the ctor then using GetD3D12Pageable() directly?\n\nOptionally, ASSERT(heap \u003d\u003d nullptr \u0026\u0026 pagable !\u003d nullptr) OR ASSERT(heap-\u003eGetPageable() \u003d\u003d mPageable) for direct allocation or sub-allocation, respectively.",
      "parentUuid": "04c4e37f_99ea6063",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86ff5a8d_456e3c58",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 41,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-02-05T18:21:24Z",
      "side": 1,
      "message": "What happens if a buffer tries to map an evicted resource\u0027s heap?",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6469a4a_f479f2cf",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 41,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-02-05T18:52:00Z",
      "side": 1,
      "message": "Don\u0027t know, but I\u0027d bet we crash. Anytime we try to access a heap there needs to be a call to EnsureHeapIsResident. I\u0027ve only covered the cases possible in the allocators and within a CommandEncoder. I\u0027ll need to read through the API to try and find anything outside of those (i.e. MapAsync).",
      "parentUuid": "86ff5a8d_456e3c58",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e709e56_a00f5c67",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-02-04T21:58:13Z",
      "side": 1,
      "message": "Only part of this design I\u0027m not a fan of is this member. I had to find some way to keep a directly-allocated dawn_native::d3d12::Heap alive, and this was the simplest option at the cost of unused bits in the suballocated case.",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08bc187e_18b8efd1",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-02-05T18:21:24Z",
      "side": 1,
      "message": "ResourceMemoryAllocation already stores a Heap. For direct allocation, it would be the empty Heap object (no d3d12 heap). Unlike sub-allocated heaps, the committed resource must own its committed memory and cannot be shared.",
      "parentUuid": "5e709e56_a00f5c67",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26d39e84_a221d1dc",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-02-05T18:52:00Z",
      "side": 1,
      "message": "It does, but it\u0027s just stored as a simple pointer type. You can see I do still pass the heap through the constructor and it\u0027s stored as on the ResourceMemoryAllocation. \n\nThe reason I added the mImplicitHeap shared_ptr was to keep a (dawn)Heap alive for the duration of a directly-allocated resourceHeapAllocation. \n\nI understand that the current allocation scheme creates no (dawn)Heap nor a (d3d12)Heap in the case of direct allocation, however I have changed this in this current patch set so there is a (dawn)Heap to represent a directly allocated resource. I think the residency code has been much simplified if an LRUEntry can just represent a (dawn)Heap instead of both a Heap and RMA.\n\nI know Dawn\u0027s allocation scheme is designed to mimic D3D12\u0027s, but if you look at CreateCommittedResource [1], note the description: \"Creates both a resource and an implicit heap, such that the heap is big enough to contain the entire resource, and the resource is mapped to the heap.\" Dawn currently doesn\u0027t acknowledge this \"implicit heap\" - and I\u0027m just trying to integrate it somehow - because the residency code is much simpler when I do.\n\n[1] https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource",
      "parentUuid": "08bc187e_18b8efd1",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afd35272_aafd1468",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-02-05T22:32:16Z",
      "side": 1,
      "message": "The issue becomes lifetime tracking for direct allocations is currently via the d3d resource; however, the LRU likes heaps. Maybe using the RHA could resolve that without adding another means of controlling ownership. \n\nOtherwise, what happens if buffer.Destory() is called? The resource is .Reset() without the LRU knowing any better, two-way communication is now required.",
      "parentUuid": "26d39e84_a221d1dc",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5be0d437_1ca8ab20",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-02-06T21:17:15Z",
      "side": 1,
      "message": "\u003e\u003e what happens if buffer.Destory() is called?\n\nBut isn\u0027t the RHA destroyed when this occurs? When the RHA is destroyed, then the shared_ptr keeping the accompanying (dawn)Heap alive is destroyed -\u003e this invokes the (dawn)Heap\u0027s destructor that will remove its entry from the LRU.",
      "parentUuid": "afd35272_aafd1468",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9fedad25_e39216e0",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-02-06T22:05:52Z",
      "side": 1,
      "message": "Nope. Buffer.Destroy() does not destroy the RHA but only relinquishes its ownership of the resource. The resource itself is used for controlling its lifetime, not the RHA.",
      "parentUuid": "5be0d437_1ca8ab20",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d33e2963_be0c1a0a",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-02-06T22:12:23Z",
      "side": 1,
      "message": "Okay. In that case - we could just add this to RHA::Invalidate():\n\nif(GetInfo().mMethod \u003d\u003d kDirect) {\n    mImplicitHeap.reset();\n}\n\nThis would invoke the Heap destructor and remove it from the LRU.",
      "parentUuid": "9fedad25_e39216e0",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5df5fd7_c82bdd23",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-02-10T20:42:52Z",
      "side": 1,
      "message": "Yup. That would resolve the bug. But I wonder if we could do away with mImplicitHeap and do the suggested with RHA\u0027s resourceHeap directly. I don\u0027t think the LRU needs to control the lifetime of the RHA so long as it\u0027s notified when it\u0027s invalidated.",
      "parentUuid": "d33e2963_be0c1a0a",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0319ee61_4c3fab9c",
        "filename": "src/dawn_native/d3d12/ResourceHeapAllocationD3D12.h",
        "patchSetId": 7
      },
      "lineNbr": 46,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2020-02-11T18:24:56Z",
      "side": 1,
      "message": "Yesterday we talked about moving the call to TrackResidentAllocation earlier when doing direct allocations - however this also doesn\u0027t solve the problem. My LRU doesn\u0027t store a smart pointer, and even if it did - the LRUEntry could eventually be evicted, and nothing would be referencing it - then the (dawn)Heap would be destroyed.\n\nThe options I see are:\n1) Keep it as is, keeping mImplicitHeap.\n2) Create the (dawn)Heap like now, but instead of storing on the RHA, I could just add a vector onto ResourceAllocatorManager that stores the smart pointers, and then destroy it when the RHA is invalidated. RHA would not have to have an added member this way.\n3) Don\u0027t make a smart pointer during (dawn)Heap creation - and manage the (dawn)Heap manually.  I could simply store the pointer at RMA::mResourceHeap, then cast back to a (dawn)Heap and delete when the RHA is invalidated. I expect push back on this because there\u0027s manual memory management involved.",
      "parentUuid": "b5df5fd7_c82bdd23",
      "revId": "d35d27e0e8181dc56c25ec325e490462dc2048d7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}