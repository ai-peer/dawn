{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "dc15ef83_cfcb4508",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 856,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-29T02:14:23Z",
      "side": 0,
      "message": "my current understanding:\n\nmResourceAllocatorManager-\u003eDestroyPool()\n-\u003e ResourceAllocatorManager::DestroyPool\n-\u003e PooledResourceMemoryAllocator::DestroyPool for all heap types\n-\u003e d31d2::HeapAllocator::DeallocateResourceHeap(std::move(resourceHeap));\n-\u003e mDevice-\u003eReferenceUntilUnused(heap);\n-\u003e mUsedComObjectRefs.Enqueue(heap, GetPendingCommandSerial());\n\nso all the heaps are in mUsedComObjectRefs\nwhich then gets cleared with the max serial - clearing everything\n\nthis is *theoretically* supposed to free all the memory, but evidently you\u0027ve found it is not; do you know where it\u0027s going wrong? is there a ComPtr that\u0027s not getting moved correctly and thus leaking somewhere?",
      "range": {
        "startLine": 850,
        "startChar": 4,
        "endLine": 856,
        "endChar": 78
      },
      "revId": "be2ed98e0594b44b14764d6cb53cb89915e94693",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7052e6d3_08829a5d",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 856,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2022-11-29T02:37:53Z",
      "side": 0,
      "message": "@Austin, when I debugged this locally, the allocation ended up getting left behind in mResourceAllocationManager.mAllocationsToDelete. Deleting the allocation manager released the final reference due to ResourceHeapAllocation using a ComPtr internally.\n\nThe ResourceAllocationManager also has quite a bit of heap allocated on account of the std::vector in BuddyMemoryAllocator. We end up freeing that memory as well.",
      "parentUuid": "dc15ef83_cfcb4508",
      "range": {
        "startLine": 850,
        "startChar": 4,
        "endLine": 856,
        "endChar": 78
      },
      "revId": "be2ed98e0594b44b14764d6cb53cb89915e94693",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f006b21b_15999bf2",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 856,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-29T02:51:05Z",
      "side": 0,
      "message": "Ah I see, thanks for explaining! because the zero buffer needs to first its reference cleared out of mAllocationsToDelete AND also have its heap reference dropped - i.e. heap has no more suballocations, then the heap can be freed.\n\nwe could do something like:\n    \n```\n+   // make sure the zero buffer can be deleted\n+   mResourceAllocatorManager-\u003eTick(std::numeric_limits\u003cExecutionSerial\u003e::max());\n\n    // Release recycled resource heaps.\n    if (mResourceAllocatorManager !\u003d nullptr) {\n        mResourceAllocatorManager-\u003eDestroyPool();\n    }\n\n    // We need to handle clearing up com object refs that were enqeued after TickImpl\n    mUsedComObjectRefs.ClearUpTo(std::numeric_limits\u003cExecutionSerial\u003e::max());\n\n+   // free tracking data structures\n+   // mResourceAllocatorManager.reset();\n```\n\nto make sure the destruction order of allocations and heaps happens exactly as they normally would for other resources - but that\u0027s probably a bit unnecessary.\n\nUnless! does D3D12 require you to release all placed resources before releasing the heap? That could be a problem if there are placed resources living in mUsedComObjectRefs and `mResourceAllocatorManager.reset(nullptr)` releases all the heaps.",
      "parentUuid": "7052e6d3_08829a5d",
      "range": {
        "startLine": 850,
        "startChar": 4,
        "endLine": 856,
        "endChar": 78
      },
      "revId": "be2ed98e0594b44b14764d6cb53cb89915e94693",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00a5eb5d_7ba8c3fe",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 856,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2022-11-29T17:43:03Z",
      "side": 0,
      "message": "@Austin, if we want an orderly shutdown that matches normal shutdown, we should write the code you suggested in the destructor of the resource allocation manager and make `DestroyPool` be a private method. There\u0027s value in having objects know how to shut themselves down.\n\nI would still like for the Dawn Device to actually free the allocation manager so that all of the heap allocation memory it holds can also go away.",
      "parentUuid": "f006b21b_15999bf2",
      "range": {
        "startLine": 850,
        "startChar": 4,
        "endLine": 856,
        "endChar": 78
      },
      "revId": "be2ed98e0594b44b14764d6cb53cb89915e94693",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}