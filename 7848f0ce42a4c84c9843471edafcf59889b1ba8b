{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4d53c702_d5eaa60b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2023-04-27T19:27:24Z",
      "side": 1,
      "message": "This seems like the right fix to me. PTAL. Fixes dawn:1701.",
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "44fd57b9_3a1c9c7c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-27T22:43:06Z",
      "side": 1,
      "message": "if it fixes the problem, then I think we should probably land this since it\u0027s a pretty small and targeted change.\n\nThat said, I\u0027m still trying to understand *how* it fixes the problem. It\u0027ll definitely make the heaps switch over faster - but is that simply masking the problem in some other way?\n\nFrom what I understand, the descriptors are allocated from some pending serial `N`.\nThese descriptors are marked as free in the descriptor allocator once `N` has completed on the GPU. After they are complete, we\u0027ll reuse that space in the ring buffer to put new GPU descriptors.\n\nSo, using CompletedSerial *sounds* right to me. the descriptors are still valid if that serial hasn\u0027t passed yet......\n\nOHHH is it because we are checking `lastUsageSerial \u003e CompletedSerial` when it should be `lastUsageSerial \u003e\u003d CompletedSerial ????",
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "822e4c4d_43e99acf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-27T23:03:26Z",
      "side": 1,
      "message": "Ok - I think. is it because when we **reuse a descriptor allocation** we don\u0027t actually *extend its lifetime*?\n\nConsider:\n\n1. Allocate descriptors in PopulateViews for pending serial `N`, at offset `n`. The descriptors have last usage serial `N`.\n2. Submit\n3. PopulateViews for pending serial `N+1`, reusing descriptors at offset `n`. The descriptors have last usage serial `N`.\n4. Submit\n5. Serial `N` completes\n6. PopulateViews for pending serial `N+2`, **overwriting descriptors** at offset `n`. The descriptors have last usage serial `N+2`.\n   This is a problem!!!\n   Serial N+1 is still in flight and is using descriptors at offset `n`, and in use by the GPU!!!",
      "parentUuid": "44fd57b9_3a1c9c7c",
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f715726_184ae031",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-27T23:22:46Z",
      "side": 1,
      "message": "the CL fixes it because:\n\n1. Allocate descriptors in PopulateViews for pending serial `N`, at offset `n`. The descriptors have last usage serial `N`.\n2. Submit serial `N`\n3. PopulateViews for pending serial `N+1`, the old descriptors are no longer valid because their usage serial N \u003d\u003d the last submitted serial N. They are not \u003e\n   Populate new descriptors at offset `n + m`. The descriptors have last usage serial `N+1`.\n4. Submit serial `N+1`\n5. Serial `N` completes. Now descriptors in range `[n, n+m)` may be reused\n\nI\u0027ve convinced myself this fixes the problem, but I\u0027d like Corentin to review too\n\nIf possible, we should extend D3D12DescriptorHeapTests.cpp to catch the problem",
      "parentUuid": "822e4c4d_43e99acf",
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b970425f_97579c12",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-04-28T12:26:03Z",
      "side": 1,
      "message": "LGTM as well, though a test here or as a follow-up would be ideal.\n\nBrandon (Google) PTAL as well, this is one of the more subtle parts of the D3D12 backend and an interesting bug to understand.",
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "88388239_1caeb018",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-04-28T12:26:03Z",
      "side": 1,
      "message": "This was hard to figure out, nice find Brandon! And thank you Austin for the detailed explanation, it helped understand exactly what\u0027s going on (though I still had to think about it for 20 minutes xD) LGTM",
      "parentUuid": "1f715726_184ae031",
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be5da57b_bab43bc1",
        "filename": "src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 238,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-04-28T12:26:03Z",
      "side": 1,
      "message": "Can we update the comment at [1] so that it doesn\u0027t mention ringbuffer? That was one of the original ideas but in the end we have a linear allocator that manages a pool of heaps it switches between as needed.",
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bc49e1b_00930d63",
        "filename": "src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 242,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-27T22:43:06Z",
      "side": 1,
      "message": "```suggestion\n    return (allocation.GetLastUsageSerial() \u003e\u003d mDevice-\u003eGetCompletedCommandSerial() \u0026\u0026\n```\n\nI think this might be the actual problem :o",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 242,
        "endChar": 89
      },
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f4de3715_9989f1af",
        "filename": "src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 242,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-27T22:44:10Z",
      "side": 1,
      "message": "nevermind. I\u0027m wrong; this is the opposite condition. it\u0027s checking that it is still valid, not that it is invalid.",
      "parentUuid": "7bc49e1b_00930d63",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 242,
        "endChar": 89
      },
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f7ac701_3c38e684",
        "filename": "src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 242,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-04-28T12:26:03Z",
      "side": 1,
      "message": "Shouldn\u0027t this be `allocation.GetLastUsageSerial() \u003d\u003d mDevice-\u003eGetPendingCommandSerial()`? This is equivalent but the semantic is more clear.\n\nThen update the comment to explain that allocations are only valid for a single execution serial as the heaps when switched start overwriting all allocations from the start.",
      "parentUuid": "f4de3715_9989f1af",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 242,
        "endChar": 89
      },
      "revId": "7848f0ce42a4c84c9843471edafcf59889b1ba8b",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}