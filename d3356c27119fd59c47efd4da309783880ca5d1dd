{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "48428aaf_45f3743c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002241
      },
      "writtenOn": "2023-06-06T20:17:11Z",
      "side": 1,
      "message": "PTAL, happy to take suggestions for tweaks to the format.",
      "revId": "d3356c27119fd59c47efd4da309783880ca5d1dd",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66c0bf44_d3700f89",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-06-06T23:05:09Z",
      "side": 1,
      "message": "LGTM as an initial step.\nI think it would be sensible to ID types similarly to values, not necessarily with a `%`, but with some this-is-an-id prefix.\n\nDan for +2",
      "revId": "d3356c27119fd59c47efd4da309783880ca5d1dd",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ee56f63d_09111d89",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000257
      },
      "writtenOn": "2023-06-06T23:35:49Z",
      "side": 1,
      "message": "I think using the struct name here is fine as it means we can keep using the FriendlyName from the type and don\u0027t have to do anything special for structs when emitting as a type.",
      "revId": "d3356c27119fd59c47efd4da309783880ca5d1dd",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "027d070e_9fccde7f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-06-06T23:44:38Z",
      "side": 1,
      "message": "My concern is when we come to implement parsing. Raw identifiers might be hard to support without lookahead.",
      "parentUuid": "ee56f63d_09111d89",
      "revId": "d3356c27119fd59c47efd4da309783880ca5d1dd",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "77131cb7_9ed91d21",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003216
      },
      "writtenOn": "2023-06-06T23:46:50Z",
      "side": 1,
      "message": "I think it\u0027s ok here, because they\u0027re outside a block. If you\u0027re outside a block, and not looking at a %b or %\u003cfunction_name\u003e then it\u0027s a struct identifier (at least currently).\n\nEverything else is either in the root block or a function.\n\nAnd, even with lookahead, it\u0027s always next token (is it an \u003d)",
      "parentUuid": "027d070e_9fccde7f",
      "revId": "d3356c27119fd59c47efd4da309783880ca5d1dd",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}