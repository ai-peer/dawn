{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "58e6a13b_66805ea3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-05T22:09:50Z",
      "side": 1,
      "message": "PTAL\n\nA couple opens:\n- The secure hash (ANGLE uses SHA1).\n- E2E coverage: test local vs global (up to 50% faster if the latter).\n- Caching DX shader bytecode for release builds (vs not).\n\nProposed split:\n1. Metadata for keys\n2. D3D + persistence + whitebox tests\n3. VK + E2E coverage\n\n",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be15c24f_423b7958",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "I feel we might need to be more careful than ANGLE w.r.t. secure hashing. D3D12 has fewer guard rails w.r.t. robust buffer access than GL/D3D11.\nWe have this issue now that dynamic buffers aren\u0027t bounds checked and Dawn will need to upload a constant to specify the buffer length. Any Dawn-side protections could probably be circumvented if an attacker manufactures the right hash collision... maybe?\n\nTesting: we could probably just run the tests twice with both variants. They\u0027re pretty fast.\n\nWhat reasons are there for not caching DX shader bytecode?",
      "parentUuid": "58e6a13b_66805ea3",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc5fbbdc_686e61cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-06T21:26:22Z",
      "side": 1,
      "message": "\u003e\u003e I feel we might need to be more careful than ANGLE w.r.t. secure hashing.\n\nIf we key stretch from the XOR hash of CachedObject to SHA2, that\u0027ll bring us up to TLS/SSL level for preventing collisions. The weaker link is CachedObject\u0027s being only XOR hashed.\n\n\u003e\u003e What reasons are there for not caching DX shader bytecode?\n\n1. Space, E2E was +10% more memory. Not too bad but this is unbounded.\n2. No guarantee the cached DX bytecode will be the same (vs re-gen). Need a Tint-side hash to be 100% sure.",
      "parentUuid": "be15c24f_423b7958",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2d1dbaa_ff780539",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-06T21:26:22Z",
      "side": 1,
      "message": "Thanks, AE. Left some questions.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eadf42bf_2aff5e9f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T00:17:29Z",
      "side": 1,
      "message": "if the cache gets too big, could the embedder just decide to evict some stuff?\n(in that case, maybe it\u0027s valuable for the embedder to know what it\u0027s caching shader/pipeline)\n\nFor (2) is this because of Dawn\u0027s renaming of stuff - or the debug information that\u0027s different for each compile - or something else?",
      "parentUuid": "fc5fbbdc_686e61cb",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50adc5b9_c3a2a1b0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T16:48:30Z",
      "side": 1,
      "message": "\u003e If the cache gets too big\n\nYup.\n\n\u003e For (2) is this because of Dawn\u0027s renaming of stuff\n\nIf we bugfix Tint, loading the previously (buggy) cached DX bytecode version would be bad.",
      "parentUuid": "eadf42bf_2aff5e9f",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57be65dc_a544442a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T16:59:11Z",
      "side": 1,
      "message": "Include the tint version hash in the key?",
      "parentUuid": "50adc5b9_c3a2a1b0",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c227d4f_99335161",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Let\u0027s add the Tint hash to the key, and also its dependencies in general. We could have a method in Tint that queries the caching fingerprint from it.\n\nIf we start going the crypto-hash route, then we\u0027ll need to serialize the whole caching fingerprint before running it through the crypto hash (I think it\u0027s quite rare to have streaming hashes at the granularity of the uint32_t). So how about generating the key as an std::vector\u003cuint8_t\u003e already, then see whether we\u0027ll apply a crypto hash on it or not?",
      "parentUuid": "50adc5b9_c3a2a1b0",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9305a22e_6d016722",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T20:01:55Z",
      "side": 1,
      "message": "\u003e then we\u0027ll need to serialize the whole caching fingerprint \n\nThe pipeline cache already does that and it\u0027s not based on uint32_t. The key for PSO desc is based on uint32_t since D3D forbids collisions anyway. Note: same goes for all the other CachedObjects.",
      "parentUuid": "4c227d4f_99335161",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "872d8fe1_6f7e0262",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T20:01:55Z",
      "side": 1,
      "message": "Thanks, @CW! Left some comments/questions.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ada370cc_01dd5048",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-08T13:36:24Z",
      "side": 1,
      "message": "It doesn\u0027t seem to serialize, but uses HashUtils instead to do a streaming hash.\n\n\u003e The key for PSO desc is based on uint32_t since D3D forbids collisions anyway.\n\nI\u0027m not sure I understood what you meant.",
      "parentUuid": "9305a22e_6d016722",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "218e0d31_0d930d79",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-08T17:15:47Z",
      "side": 1,
      "message": "The pipeline cache does serialize the entire backing store upon storePipelineCache().\n\nD3D has a separate key to load/store PSOs based off of HashUtils. This is because the objects used to compute the PSO key are also based off of HashUtils and D3D enforces that a PSO lookup cannot use the wrong PSO desc or use the same key.\n\nIf the D3D pipeline cache can only use compatible PSOs then the key we must protect is the pipeline cache key. If we get PSO key collisions where D3D must error then I think it\u0027s better to strengthen the hash or use a better key that\u0027s compatible.",
      "parentUuid": "ada370cc_01dd5048",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9098bc59_19cef5fe",
        "filename": "src/dawn_native/CMakeLists.txt",
        "patchSetId": 6
      },
      "lineNbr": 107,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "nit: This is missing PersistentCache",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78f94a8f_245b9d2d",
        "filename": "src/dawn_native/PersistentCache.h",
        "patchSetId": 6
      },
      "lineNbr": 33,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "This is an extremely low-level API, can we have some higher-level version that helps use the thing correctly?\n\nFor example\n\n    template\u003ctypename T\u003e\n    ResultOrError\u003cT\u003e LoadFromCacheOrCreate(key, std::function\u003cResultOrError\u003cT\u003e(std::function\u003cvoid(span\u003cvoid\u003e)\u003e)\u003e createFn);\n\n That\u0027s used like the following:\n\n   DAWN_TRY_ASSIGN(pipelineState, LoadFromCacheOrCreate(key, [\u0026](DoCacheFn doCache){\n       // We know we need to create the thing, do a bunch of work\n       // We create the thing, now put it in the cache, the PersistentCache will check we called this\n       doCache(thing-\u003eCachedBlob());\n       return {thing};\n   }));\n\nThis is a sketch and there should be something nicer possible.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6dca10a0_5023466e",
        "filename": "src/dawn_native/PipelineCache.h",
        "patchSetId": 6
      },
      "lineNbr": 25,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "nit: this isn\u0027t used in the frontend and does almost nothing, so it could be moved to the backend entirely.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "737bdea2_8e16ee2b",
        "filename": "src/dawn_native/PipelineCache.h",
        "patchSetId": 6
      },
      "lineNbr": 25,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T20:01:55Z",
      "side": 1,
      "message": "Couldn\u0027t the front-end control how backends store/flush the pipeline cache? Note: right now, it\u0027s done on Shutdown() for lack of a better heuristic.",
      "parentUuid": "6dca10a0_5023466e",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e6ec0af_97ed95b2",
        "filename": "src/dawn_native/PipelineCache.h",
        "patchSetId": 6
      },
      "lineNbr": 25,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-08T13:36:24Z",
      "side": 1,
      "message": "It could, but it doesn\u0027t now and we don\u0027t have a plan for it so this is just extra indirection. We can always extract a base class later if we feel that we need to for extra frontend control.",
      "parentUuid": "737bdea2_8e16ee2b",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47c537a2_66d9dddf",
        "filename": "src/dawn_native/PipelineCache.h",
        "patchSetId": 6
      },
      "lineNbr": 25,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-08T17:15:47Z",
      "side": 1,
      "message": "Sounds good.",
      "parentUuid": "6e6ec0af_97ed95b2",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "910887b4_e9bb780e",
        "filename": "src/dawn_native/RenderPipeline.cpp",
        "patchSetId": 6
      },
      "lineNbr": 596,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Uh, I\u0027m not sure I understand the isContentLess. What is the difference between true and false, given that here RenderPipeline can take both but it always content-less.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60d94359_a8359296",
        "filename": "src/dawn_native/RenderPipeline.cpp",
        "patchSetId": 6
      },
      "lineNbr": 596,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T20:01:55Z",
      "side": 1,
      "message": "\u003e but it always content-less.\n\nRenderPipeline needs a full hash of its contents to persist (IsContentLess\u003dfalse). If not, we can still avoid re-hashing child objects for the in-memory cache (IsContentLess\u003dtrue).",
      "parentUuid": "910887b4_e9bb780e",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c53d81a0_10cb1a52",
        "filename": "src/dawn_native/RenderPipeline.cpp",
        "patchSetId": 6
      },
      "lineNbr": 596,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-08T13:36:24Z",
      "side": 1,
      "message": "Ah thanks for the explanation, isContentLess is a bit misleading. Maybe hashSubobjectContent?\n\nMaybe it makes sense to structure a bit more how we fingerprint contentless objects. What about:\n\nclass Pipeline : ContentLessObject, ObjectBase {\n  // ContentLessObject implementation.\n  void Fingerprint(FingerprintRecorder* recorder) override {\n    recorder-\u003erecord(member1);\n    recorder-\u003erecord(member2);\n    recorder-\u003erecordSubObject(subobject); // Either does by pointer or by value.\n  }\n\nThen the recorder recording of sub objects can be different for the in-memory cache and the persistent cache.",
      "parentUuid": "60d94359_a8359296",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0de4679e_eedad106",
        "filename": "src/dawn_native/Toggles.cpp",
        "patchSetId": 6
      },
      "lineNbr": 138,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "\"Enable\" comment should describe what the toggle does, not what toggling it away from the default does.",
      "range": {
        "startLine": 138,
        "startChar": 44,
        "endLine": 138,
        "endChar": 51
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "299df253_b626ab5a",
        "filename": "src/dawn_native/d3d12/AdapterD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 203,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Mabye Dawn adapters should expose a \"CachingFingerprint\" that when changed invalidates all the previous cache so that embedders easily know when to nuke the whole cache. (it would be a combination of backend-specific stuff, the Dawn git commit, and the Tint git commit). This CachingFingerprint would always be a prefix to what\u0027s used to make the keys (so that we can test it is correctly used).",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79999e7d_409a23ba",
        "filename": "src/dawn_native/d3d12/ComputePipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "It seems that this logic should be a property of the ShaderModule instead because it is duplicated here and in [a]. GPUShaderModule-\u003eCompile could return structure that holds the ref to either the DxcBloc or the D3DBloc and has a method to get a D3D12_SHADER_BYTECODE.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "042ba6bf_a4156b35",
        "filename": "src/dawn_native/d3d12/ComputePipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 69,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Right now the hashing mechanism makes it super easy to create collisions, maybe we could use variable-length key forever, or in preparation to use a crypto hash.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c4ce6b8_f1d2d369",
        "filename": "src/dawn_native/d3d12/ComputePipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 69,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T20:01:55Z",
      "side": 1,
      "message": "I think this is related to the other comment on serializing the footprint with a new key type. Please see my other response and re-open if I misunderstood.",
      "parentUuid": "042ba6bf_a4156b35",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8ce3956_dd39f3f2",
        "filename": "src/dawn_native/d3d12/ComputePipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 124,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "this may narrow size_t -\u003e uint32_t",
      "range": {
        "startLine": 124,
        "startChar": 85,
        "endLine": 124,
        "endChar": 91
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa2e2b2f_d18041ec",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 119,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "What does this mean? We\u0027ll need to be able to run on Windows 10 pre Anniversary Update forever.",
      "range": {
        "startLine": 118,
        "startChar": 72,
        "endLine": 119,
        "endChar": 29
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ad1556c_6d4a0668",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 119,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T20:01:55Z",
      "side": 1,
      "message": "The use of ID3D12PipelineLibrary does not guarantee support. This points out this is not optional and ALL versions of Windows/drivers will (eventually) support it in lieu of the using cached pipeline blobs.\n\nAlso, I really hope users don\u0027t stay on the Anniversary Update forever \u003d)",
      "parentUuid": "fa2e2b2f_d18041ec",
      "range": {
        "startLine": 118,
        "startChar": 72,
        "endLine": 119,
        "endChar": 29
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b11371e_237885e6",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 119,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-08T13:36:24Z",
      "side": 1,
      "message": "Erhm, we can\u0027t really rely on driver updates either, and should make a best effort to run on old drivers too, so we can\u0027t rely on the feature being ubiquitous until many many years from now.",
      "parentUuid": "2ad1556c_6d4a0668",
      "range": {
        "startLine": 118,
        "startChar": 72,
        "endLine": 119,
        "endChar": 29
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11c91b51_f9436a7a",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 119,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-08T17:15:47Z",
      "side": 1,
      "message": "If drivers don\u0027t update, one will need to consider employing the older cached blobs approach. This is not obvious to me (no \"tier\" option either) so it seems appropriate to comment. Happy to re-word, if needed.",
      "parentUuid": "0b11371e_237885e6",
      "range": {
        "startLine": 118,
        "startChar": 72,
        "endLine": 119,
        "endChar": 29
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91ebda88_ce8116e1",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "So if you make two devices on the same adapter, then I think they have the same cache key, but use different pipeline libraries. Then, seems like only the device that is destroyed last will have its pipeline cache persisted because the first device will be overwritten. Is there some way to avoid this?\n\nNote: in the future we\u0027d like to have \"logical\" and \"physical\" Dawn devices where we emulate multiple logical devices w/ tracking, limits validation, etc. on top of one real D3D12 device - so this would be less of a problem.\n\nThough it would be another reason to have GetDeviceKey mentioned at [1]",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3011c323_cc31bf7f",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-06T21:26:22Z",
      "side": 1,
      "message": "For D3D, easier to have a separate pipeline library per device. For Vulkan, we can use vkMergePipeline to de-dup. But I have questions: 1) will logical devices be persistent? and 2) who will manage Dawn\u0027s logical devices? Ex. client can also prepend the key, HashCombine(deviceGUID, key) upon load/store.",
      "parentUuid": "91ebda88_ce8116e1",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d133f48_3c31a3ff",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T00:17:29Z",
      "side": 1,
      "message": "(actually, forget about logical devices, it\u0027s probably orthogonal, and we don\u0027t need to consider it too much since it\u0027s some time in the future)\n\nWhat WILL happen sooner though is we\u0027re going to stop making a new dawn_native::Instance per-tab and rediscovering adapters on the system every time someone uses WebGPU.\n\nSo even with adding the device GUID to the key, the design still can\u0027t do per-origin cache isolation. The subSysId, deviceGuid, etc. are all the same no matter what origin you\u0027re using, no?\n\nIt seems like we either need to a way to pass some origin-identifier from Chrome into Dawn on device creation, or we need to have a way for Dawn to ask the embedder for an origin-identifier for the device ?",
      "parentUuid": "3011c323_cc31bf7f",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8873155e_277586cd",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T16:48:30Z",
      "side": 1,
      "message": "\u003e are all the same no matter what origin you\u0027re using, no?\n\nThe client could always isolate its keys by wrapping the key retuned by Dawn with origin data.\n\nBut I\u0027m unsure if this is an issue in practice. PSOs will be checked for compatibility so they should always be the same.",
      "parentUuid": "9d133f48_3c31a3ff",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce410013_a82bf153",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T16:59:11Z",
      "side": 1,
      "message": "DawnPlatform will not know what origin it\u0027s on. The platform is a member of the dawn_native::Instance which will probably be a singleton in the GPU process. So inside Chrome\u0027s implementation of load/storeData, we don\u0027t know which origin it\u0027s coming from.\n\nWhat about we have a Dawn extension for DeviceIsolation that puts a key chained on the DeviceDescriptor, and we include it in this cache key?",
      "parentUuid": "8873155e_277586cd",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9df2caa0_942aca48",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T20:01:55Z",
      "side": 1,
      "message": "Hmm. Where would the origin data come from in Chromium?",
      "parentUuid": "ce410013_a82bf153",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9deb9db9_288ec67c",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-08T13:36:24Z",
      "side": 1,
      "message": "Which origin called GPU.requestAdapter in the renderer process. There is something in the WebGPUCommandDecoder\u0027s parent class to know the origin it\u0027s used with.",
      "parentUuid": "9df2caa0_942aca48",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b00ccca_f169b34c",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-08T18:12:28Z",
      "side": 1,
      "message": "What if we introduced our own dawn pipeline cache header that contains the logical deviceId so the client can read it to isolate keys as it wishes?\n\nThis avoids passing some blob around and doesn\u0027t depend on Dawn to isolate keys on behalf of the client.",
      "parentUuid": "9deb9db9_288ec67c",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05c67f25_c7ede7a7",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-08T18:18:25Z",
      "side": 1,
      "message": "Sorry, I\u0027m not exactly following. Could you clarify?",
      "parentUuid": "8b00ccca_f169b34c",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7fabb1be_717bc9e7",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-08T19:17:07Z",
      "side": 1,
      "message": "Just pass the key as a UID, Dawn doesn\u0027t need to hash it.\n\nLong answer, client generates a logical device UID which could be based on origin data or not. The logical device UID is specified on device creation and returned in the payload header by Dawn. If the client generated the UID based on origin data, the GUID simply acts as the key in its cache. Otherwise, map the UID to origin data.",
      "parentUuid": "05c67f25_c7ede7a7",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "693cdaff_0028bdde",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-08T19:38:06Z",
      "side": 1,
      "message": "passing something on device creation chained on the device descriptor makes sense. What\u0027s the proposed interface?",
      "parentUuid": "7fabb1be_717bc9e7",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "082168e4_1ab98428",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-08T21:40:36Z",
      "side": 1,
      "message": "Add the deviceUUID to DeviceDescriptor then in DAWN_PIPELINE_CACHE_HEADER, add two fields (total size and deviceUUID) and I think that\u0027s it. Updated the design doc w/ more detail.",
      "parentUuid": "693cdaff_0028bdde",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "148e53f7_75b5b95a",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-09T14:57:27Z",
      "side": 1,
      "message": "That could work with the caveat that DeviceDescriptor is in webgpu.h so it\u0027d be better as a device descriptor extension struct. However browsers are likely the only clients that will need to do this type of thing (and maybe they\u0027ll need the GPUDevice anyway for tracking the cache size per origin or something) so I think it\u0027s marginally better to pass the GPUDevice inside the platform callbacks.",
      "parentUuid": "082168e4_1ab98428",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02380cfe_63184e26",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.h",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "This uses a single pipeline library for all the pipelines, is there any advantage to doing that, compared to doing one library per pipeline (or at least per combination of VS / FS / CS)? It would allow flushing at a smaller granularity.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71cb7b6f_0d058eee",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.h",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-08T17:15:47Z",
      "side": 1,
      "message": "Not that I know of. @RC?",
      "parentUuid": "02380cfe_63184e26",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b97bb17_52fd26c8",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.h",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-12T21:51:18Z",
      "side": 1,
      "message": "I think this is do-able by storing entries as {key: Hash(PSO) + Hash(RP or CS), value: PipelineCacheBlob} pairs.\n\nWe prefix the key using the PSO hash to 1) give the key strength (via crypto) and 2) prevent collisions, and 3) it\u0027s cheaply computed. For 2), the loaded pipeline cache can only store compatible pipelines, so if the weaker XOR hash, Hash(RP or CS) collides, it results into a cache-miss in the pipeline cache.\n\nObviously we know having pipelines in separate caches will not come for free, so I propose we have a switch to change the key back to eval impact. WDYT?",
      "parentUuid": "71cb7b6f_0d058eee",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1e12035_a359b375",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.h",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-13T21:40:56Z",
      "side": 1,
      "message": "RP is render pipeline and CS is compute shader? not sure if those were supposed to indicate the same \"level\" of object.\n\nDo we need to key on the PSO or just the combination of shaders? Seems like PSO means we have nearly one pipeline library per pipeline.",
      "parentUuid": "6b97bb17_52fd26c8",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3acf8f37_40343e68",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.h",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-13T23:17:12Z",
      "side": 1,
      "message": "Good catch, that\u0027s a typo. Should be \"Hash(RP or CP)\" and not \"Hash(RP or CS)\" for 1 pipeline per library.",
      "parentUuid": "d1e12035_a359b375",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68a450d2_25dd5c96",
        "filename": "src/dawn_native/d3d12/RenderPipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 322,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "[a]",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "106fc357_17b1d6f8",
        "filename": "src/dawn_native/vulkan/RenderPipelineVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 494,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "add a TODO to look at VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT on VK_EXT_pipeline_creation_cache_control\n\nThat would let us compile ONLY using the cache first, and then if it fails (when we have threads) make a background thread to do the compilation (for createReadyPipeline)\n\nThis lets us have the try-the-cache-then-fallback pattern we use in D3D12.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e2d33f9_459f95ef",
        "filename": "src/dawn_native/vulkan/RenderPipelineVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 494,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-06T21:26:22Z",
      "side": 1,
      "message": "\u003e\u003e VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT\n\nWhy wouldn\u0027t you always want to create the pipeline but get notified if re-compile (vs two pipeline creations)? It\u0027s like asking for permission vs forgiveness, the latter is usually faster since the compilation is already underway.\n\n\u003e\u003e VK_EXT_pipeline_creation_cache_control\n\nAre you thinking we do an Dawn-side cache? I figured between Dawn\u0027s in-memory cache and the client\u0027s cache, it would only be useful for Dawn native (or testing w/o persistence API).",
      "parentUuid": "106fc357_17b1d6f8",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e103a22b_3ee6bf7f",
        "filename": "src/dawn_native/vulkan/RenderPipelineVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 494,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T00:17:29Z",
      "side": 1,
      "message": "in D3D12 we do\n\n(relatively cheap?)\nDAWN_TRY_ASSIGN(mPipelineState, device-\u003eGetPipelineCache()-\u003eloadComputePipeline(d3dDesc, psoKey))\n\nand if that is a cache miss,\n(relatively expensive?)\ndevice-\u003eGetD3D12Device()-\u003eCreateComputePipelineState(\n                                      \u0026d3dDesc, IID_PPV_ARGS(\u0026mPipelineState)),\n                                  \"ID3D12Device::CreateComputePipelineState\")\n\nso the thought was that if it\u0027s a cache hit, we could resolve the createReadyPipeline synchronously right away without going to ask a worker thread to do a compilation\n\nMaybe this Vulkan extension (kinda low adoption) would let us do something similar. I haven\u0027t read it in full, but I believe it tells you if Vulkan\u0027s builtin cache was a cache miss and it needs to go do a full pipeline compilation.",
      "parentUuid": "9e2d33f9_459f95ef",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "088f7d8e_989b720e",
        "filename": "src/dawn_native/vulkan/RenderPipelineVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 494,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T16:48:30Z",
      "side": 1,
      "message": "SGTM.",
      "parentUuid": "e103a22b_3ee6bf7f",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f2021c4_f0a393f3",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "[1] Eventually, I think this DawnPlatform object will be shared between multiple origins and devices. Perhaps we should have a |size_t GetDeviceKey(WGPUDevice device)| so that Chrome can look up an origin-specific identifier in a device-\u003eorigin mapping.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd500b8d_80886d9c",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Maybe we could just pass the WGPUDevice object as an argument?\n\nAlso we\u0027ll have to make sure we key on a representative Adapter description so that if the driver is upgraded, or the device swapped, we invalidate correctly.",
      "parentUuid": "5f2021c4_f0a393f3",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1288042c_68ddf689",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T17:44:51Z",
      "side": 1,
      "message": "err, you get a new device on each page load, so I think we need some origin identifier otherwise we\u0027ll never ever hit the cache",
      "parentUuid": "fd500b8d_80886d9c",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32d4cdc4_5136a3d4",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:45:52Z",
      "side": 1,
      "message": "Can\u0027t the embedder have a map from GPUDevice to whatever it needs to know?",
      "parentUuid": "1288042c_68ddf689",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a591780b_41f17aef",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T17:47:48Z",
      "side": 1,
      "message": "oh yes, that was one of my suggestions above as well. Either works, though we could avoid the lookup table if we store the origin on the device.",
      "parentUuid": "32d4cdc4_5136a3d4",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}