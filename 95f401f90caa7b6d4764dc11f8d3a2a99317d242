{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "58e6a13b_66805ea3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-05T22:09:50Z",
      "side": 1,
      "message": "PTAL\n\nA couple opens:\n- The secure hash (ANGLE uses SHA1).\n- E2E coverage: test local vs global (up to 50% faster if the latter).\n- Caching DX shader bytecode for release builds (vs not).\n\nProposed split:\n1. Metadata for keys\n2. D3D + persistence + whitebox tests\n3. VK + E2E coverage\n\n",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be15c24f_423b7958",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "I feel we might need to be more careful than ANGLE w.r.t. secure hashing. D3D12 has fewer guard rails w.r.t. robust buffer access than GL/D3D11.\nWe have this issue now that dynamic buffers aren\u0027t bounds checked and Dawn will need to upload a constant to specify the buffer length. Any Dawn-side protections could probably be circumvented if an attacker manufactures the right hash collision... maybe?\n\nTesting: we could probably just run the tests twice with both variants. They\u0027re pretty fast.\n\nWhat reasons are there for not caching DX shader bytecode?",
      "parentUuid": "58e6a13b_66805ea3",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc5fbbdc_686e61cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-06T21:26:22Z",
      "side": 1,
      "message": "\u003e\u003e I feel we might need to be more careful than ANGLE w.r.t. secure hashing.\n\nIf we key stretch from the XOR hash of CachedObject to SHA2, that\u0027ll bring us up to TLS/SSL level for preventing collisions. The weaker link is CachedObject\u0027s being only XOR hashed.\n\n\u003e\u003e What reasons are there for not caching DX shader bytecode?\n\n1. Space, E2E was +10% more memory. Not too bad but this is unbounded.\n2. No guarantee the cached DX bytecode will be the same (vs re-gen). Need a Tint-side hash to be 100% sure.",
      "parentUuid": "be15c24f_423b7958",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2d1dbaa_ff780539",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-06T21:26:22Z",
      "side": 1,
      "message": "Thanks, AE. Left some questions.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eadf42bf_2aff5e9f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T00:17:29Z",
      "side": 1,
      "message": "if the cache gets too big, could the embedder just decide to evict some stuff?\n(in that case, maybe it\u0027s valuable for the embedder to know what it\u0027s caching shader/pipeline)\n\nFor (2) is this because of Dawn\u0027s renaming of stuff - or the debug information that\u0027s different for each compile - or something else?",
      "parentUuid": "fc5fbbdc_686e61cb",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50adc5b9_c3a2a1b0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T16:48:30Z",
      "side": 1,
      "message": "\u003e If the cache gets too big\n\nYup.\n\n\u003e For (2) is this because of Dawn\u0027s renaming of stuff\n\nIf we bugfix Tint, loading the previously (buggy) cached DX bytecode version would be bad.",
      "parentUuid": "eadf42bf_2aff5e9f",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57be65dc_a544442a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T16:59:11Z",
      "side": 1,
      "message": "Include the tint version hash in the key?",
      "parentUuid": "50adc5b9_c3a2a1b0",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c227d4f_99335161",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Let\u0027s add the Tint hash to the key, and also its dependencies in general. We could have a method in Tint that queries the caching fingerprint from it.\n\nIf we start going the crypto-hash route, then we\u0027ll need to serialize the whole caching fingerprint before running it through the crypto hash (I think it\u0027s quite rare to have streaming hashes at the granularity of the uint32_t). So how about generating the key as an std::vector\u003cuint8_t\u003e already, then see whether we\u0027ll apply a crypto hash on it or not?",
      "parentUuid": "50adc5b9_c3a2a1b0",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9098bc59_19cef5fe",
        "filename": "src/dawn_native/CMakeLists.txt",
        "patchSetId": 6
      },
      "lineNbr": 107,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "nit: This is missing PersistentCache",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78f94a8f_245b9d2d",
        "filename": "src/dawn_native/PersistentCache.h",
        "patchSetId": 6
      },
      "lineNbr": 33,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "This is an extremely low-level API, can we have some higher-level version that helps use the thing correctly?\n\nFor example\n\n    template\u003ctypename T\u003e\n    ResultOrError\u003cT\u003e LoadFromCacheOrCreate(key, std::function\u003cResultOrError\u003cT\u003e(std::function\u003cvoid(span\u003cvoid\u003e)\u003e)\u003e createFn);\n\n That\u0027s used like the following:\n\n   DAWN_TRY_ASSIGN(pipelineState, LoadFromCacheOrCreate(key, [\u0026](DoCacheFn doCache){\n       // We know we need to create the thing, do a bunch of work\n       // We create the thing, now put it in the cache, the PersistentCache will check we called this\n       doCache(thing-\u003eCachedBlob());\n       return {thing};\n   }));\n\nThis is a sketch and there should be something nicer possible.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6dca10a0_5023466e",
        "filename": "src/dawn_native/PipelineCache.h",
        "patchSetId": 6
      },
      "lineNbr": 25,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "nit: this isn\u0027t used in the frontend and does almost nothing, so it could be moved to the backend entirely.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "910887b4_e9bb780e",
        "filename": "src/dawn_native/RenderPipeline.cpp",
        "patchSetId": 6
      },
      "lineNbr": 596,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Uh, I\u0027m not sure I understand the isContentLess. What is the difference between true and false, given that here RenderPipeline can take both but it always content-less.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0de4679e_eedad106",
        "filename": "src/dawn_native/Toggles.cpp",
        "patchSetId": 6
      },
      "lineNbr": 138,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "\"Enable\" comment should describe what the toggle does, not what toggling it away from the default does.",
      "range": {
        "startLine": 138,
        "startChar": 44,
        "endLine": 138,
        "endChar": 51
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "299df253_b626ab5a",
        "filename": "src/dawn_native/d3d12/AdapterD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 203,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Mabye Dawn adapters should expose a \"CachingFingerprint\" that when changed invalidates all the previous cache so that embedders easily know when to nuke the whole cache. (it would be a combination of backend-specific stuff, the Dawn git commit, and the Tint git commit). This CachingFingerprint would always be a prefix to what\u0027s used to make the keys (so that we can test it is correctly used).",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79999e7d_409a23ba",
        "filename": "src/dawn_native/d3d12/ComputePipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 59,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "It seems that this logic should be a property of the ShaderModule instead because it is duplicated here and in [a]. GPUShaderModule-\u003eCompile could return structure that holds the ref to either the DxcBloc or the D3DBloc and has a method to get a D3D12_SHADER_BYTECODE.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "042ba6bf_a4156b35",
        "filename": "src/dawn_native/d3d12/ComputePipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 69,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Right now the hashing mechanism makes it super easy to create collisions, maybe we could use variable-length key forever, or in preparation to use a crypto hash.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8ce3956_dd39f3f2",
        "filename": "src/dawn_native/d3d12/ComputePipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 124,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "this may narrow size_t -\u003e uint32_t",
      "range": {
        "startLine": 124,
        "startChar": 85,
        "endLine": 124,
        "endChar": 91
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa2e2b2f_d18041ec",
        "filename": "src/dawn_native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 119,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "What does this mean? We\u0027ll need to be able to run on Windows 10 pre Anniversary Update forever.",
      "range": {
        "startLine": 118,
        "startChar": 72,
        "endLine": 119,
        "endChar": 29
      },
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91ebda88_ce8116e1",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "So if you make two devices on the same adapter, then I think they have the same cache key, but use different pipeline libraries. Then, seems like only the device that is destroyed last will have its pipeline cache persisted because the first device will be overwritten. Is there some way to avoid this?\n\nNote: in the future we\u0027d like to have \"logical\" and \"physical\" Dawn devices where we emulate multiple logical devices w/ tracking, limits validation, etc. on top of one real D3D12 device - so this would be less of a problem.\n\nThough it would be another reason to have GetDeviceKey mentioned at [1]",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3011c323_cc31bf7f",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-06T21:26:22Z",
      "side": 1,
      "message": "For D3D, easier to have a separate pipeline library per device. For Vulkan, we can use vkMergePipeline to de-dup. But I have questions: 1) will logical devices be persistent? and 2) who will manage Dawn\u0027s logical devices? Ex. client can also prepend the key, HashCombine(deviceGUID, key) upon load/store.",
      "parentUuid": "91ebda88_ce8116e1",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d133f48_3c31a3ff",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T00:17:29Z",
      "side": 1,
      "message": "(actually, forget about logical devices, it\u0027s probably orthogonal, and we don\u0027t need to consider it too much since it\u0027s some time in the future)\n\nWhat WILL happen sooner though is we\u0027re going to stop making a new dawn_native::Instance per-tab and rediscovering adapters on the system every time someone uses WebGPU.\n\nSo even with adding the device GUID to the key, the design still can\u0027t do per-origin cache isolation. The subSysId, deviceGuid, etc. are all the same no matter what origin you\u0027re using, no?\n\nIt seems like we either need to a way to pass some origin-identifier from Chrome into Dawn on device creation, or we need to have a way for Dawn to ask the embedder for an origin-identifier for the device ?",
      "parentUuid": "3011c323_cc31bf7f",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8873155e_277586cd",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T16:48:30Z",
      "side": 1,
      "message": "\u003e are all the same no matter what origin you\u0027re using, no?\n\nThe client could always isolate its keys by wrapping the key retuned by Dawn with origin data.\n\nBut I\u0027m unsure if this is an issue in practice. PSOs will be checked for compatibility so they should always be the same.",
      "parentUuid": "9d133f48_3c31a3ff",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce410013_a82bf153",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T16:59:11Z",
      "side": 1,
      "message": "DawnPlatform will not know what origin it\u0027s on. The platform is a member of the dawn_native::Instance which will probably be a singleton in the GPU process. So inside Chrome\u0027s implementation of load/storeData, we don\u0027t know which origin it\u0027s coming from.\n\nWhat about we have a Dawn extension for DeviceIsolation that puts a key chained on the DeviceDescriptor, and we include it in this cache key?",
      "parentUuid": "8873155e_277586cd",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02380cfe_63184e26",
        "filename": "src/dawn_native/d3d12/PipelineCacheD3D12.h",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "This uses a single pipeline library for all the pipelines, is there any advantage to doing that, compared to doing one library per pipeline (or at least per combination of VS / FS / CS)? It would allow flushing at a smaller granularity.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68a450d2_25dd5c96",
        "filename": "src/dawn_native/d3d12/RenderPipelineD3D12.cpp",
        "patchSetId": 6
      },
      "lineNbr": 322,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "[a]",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "106fc357_17b1d6f8",
        "filename": "src/dawn_native/vulkan/RenderPipelineVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 494,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "add a TODO to look at VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT on VK_EXT_pipeline_creation_cache_control\n\nThat would let us compile ONLY using the cache first, and then if it fails (when we have threads) make a background thread to do the compilation (for createReadyPipeline)\n\nThis lets us have the try-the-cache-then-fallback pattern we use in D3D12.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e2d33f9_459f95ef",
        "filename": "src/dawn_native/vulkan/RenderPipelineVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 494,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-06T21:26:22Z",
      "side": 1,
      "message": "\u003e\u003e VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT\n\nWhy wouldn\u0027t you always want to create the pipeline but get notified if re-compile (vs two pipeline creations)? It\u0027s like asking for permission vs forgiveness, the latter is usually faster since the compilation is already underway.\n\n\u003e\u003e VK_EXT_pipeline_creation_cache_control\n\nAre you thinking we do an Dawn-side cache? I figured between Dawn\u0027s in-memory cache and the client\u0027s cache, it would only be useful for Dawn native (or testing w/o persistence API).",
      "parentUuid": "106fc357_17b1d6f8",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e103a22b_3ee6bf7f",
        "filename": "src/dawn_native/vulkan/RenderPipelineVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 494,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T00:17:29Z",
      "side": 1,
      "message": "in D3D12 we do\n\n(relatively cheap?)\nDAWN_TRY_ASSIGN(mPipelineState, device-\u003eGetPipelineCache()-\u003eloadComputePipeline(d3dDesc, psoKey))\n\nand if that is a cache miss,\n(relatively expensive?)\ndevice-\u003eGetD3D12Device()-\u003eCreateComputePipelineState(\n                                      \u0026d3dDesc, IID_PPV_ARGS(\u0026mPipelineState)),\n                                  \"ID3D12Device::CreateComputePipelineState\")\n\nso the thought was that if it\u0027s a cache hit, we could resolve the createReadyPipeline synchronously right away without going to ask a worker thread to do a compilation\n\nMaybe this Vulkan extension (kinda low adoption) would let us do something similar. I haven\u0027t read it in full, but I believe it tells you if Vulkan\u0027s builtin cache was a cache miss and it needs to go do a full pipeline compilation.",
      "parentUuid": "9e2d33f9_459f95ef",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "088f7d8e_989b720e",
        "filename": "src/dawn_native/vulkan/RenderPipelineVk.cpp",
        "patchSetId": 6
      },
      "lineNbr": 494,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-10-07T16:48:30Z",
      "side": 1,
      "message": "SGTM.",
      "parentUuid": "e103a22b_3ee6bf7f",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f2021c4_f0a393f3",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-06T01:35:56Z",
      "side": 1,
      "message": "[1] Eventually, I think this DawnPlatform object will be shared between multiple origins and devices. Perhaps we should have a |size_t GetDeviceKey(WGPUDevice device)| so that Chrome can look up an origin-specific identifier in a device-\u003eorigin mapping.",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd500b8d_80886d9c",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:42:01Z",
      "side": 1,
      "message": "Maybe we could just pass the WGPUDevice object as an argument?\n\nAlso we\u0027ll have to make sure we key on a representative Adapter description so that if the driver is upgraded, or the device swapped, we invalidate correctly.",
      "parentUuid": "5f2021c4_f0a393f3",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1288042c_68ddf689",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T17:44:51Z",
      "side": 1,
      "message": "err, you get a new device on each page load, so I think we need some origin identifier otherwise we\u0027ll never ever hit the cache",
      "parentUuid": "fd500b8d_80886d9c",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32d4cdc4_5136a3d4",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-10-07T17:45:52Z",
      "side": 1,
      "message": "Can\u0027t the embedder have a map from GPUDevice to whatever it needs to know?",
      "parentUuid": "1288042c_68ddf689",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a591780b_41f17aef",
        "filename": "src/include/dawn_platform/DawnPlatform.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-10-07T17:47:48Z",
      "side": 1,
      "message": "oh yes, that was one of my suggestions above as well. Either works, though we could avoid the lookup table if we store the origin on the device.",
      "parentUuid": "32d4cdc4_5136a3d4",
      "revId": "95f401f90caa7b6d4764dc11f8d3a2a99317d242",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}