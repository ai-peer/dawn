{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "72502da8_a6a5c1f7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:06:47Z",
      "side": 1,
      "message": "+Quyen since a lot of the ideas here were originally from him!",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e4890ab_1a888670",
        "filename": "src/dawn/common/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "also need it in CMakeLists.txt",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "82d59ee2_32130076",
        "filename": "src/dawn/common/BUILD.gn",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8e4890ab_1a888670",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a61aecfc_334f91b7",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "could you add a microbenchmark to see how something like bind group layout or sampler creation performs when:\n 1. lots of cache lookups, additions, removals\n 2. lots of lookups\n\n?\n\nthe benchmark thing also lets you test a variety of thread counts.\nWe can see how well it scales with more threads, and also see how it performs relative to baseline (no locks at all) for the threads\u003d1 case",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "277a7b4c_e9fe89d5",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "would be great to have unittests specifically for this class",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ba5a35ba_526d5922",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "a61aecfc_334f91b7",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3d2876e_c0ed58ac",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Would it be alright to have in a follow up? Along with the microbenchmarks?",
      "parentUuid": "277a7b4c_e9fe89d5",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a4211ee_1a238314",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-10T00:36:29Z",
      "side": 1,
      "message": "benchmarks can be later, but tests should really come with the implementation so we can verify the implementation and find bugs sooner",
      "parentUuid": "d3d2876e_c0ed58ac",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca8c4441_e9e14471",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-13T05:12:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2a4211ee_1a238314",
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b068ea9_7ae06e5e",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "that means that Erase can no longer assert that the object-to-be-erased is in the cache. since it may be removed here instead",
      "range": {
        "startLine": 42,
        "startChar": 15,
        "endLine": 42,
        "endChar": 91
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1edbece1_67c83364",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Yup! That\u0027s why I removed the asserts in Device.cpp (and changed the type signature for `Erase`.",
      "parentUuid": "9b068ea9_7ae06e5e",
      "range": {
        "startLine": 42,
        "startChar": 15,
        "endLine": 42,
        "endChar": 91
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71adf152_c35de7cb",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-10T00:36:29Z",
      "side": 1,
      "message": "Erase still has the following though:\n\n```\n        std::lock_guard\u003cstd::mutex\u003e lock(mMutex);\n        auto it \u003d mCache.find(object);\n        ASSERT(it !\u003d mCache.end());\n```\n\nI think the ASSERT could fail. And, thinking about it now I\u0027ve actually realized the code can also do something unexpected.\n\nConsider the following:\n```\n1. thread 1: obj.Release() // refcount goes to zero. will uncache soon\n2. thread 2: Insert(obj2)  // fails to insert because `obj` is already in the cache\n                           // TryGetRef returns nullptr b.c. refcount of obj is 0\n                           // erase(it) the old entry from the cache\n                           // insert obj2 into the cache\n3. thread 1: Uncache(obj)  // actually removes obj2 from the cache! uh-oh \n4. thread 2: obj2.Release()\n          -\u003e Uncache(obj2)\n          -\u003e Erase(obj2)   // ASSERT fails. It\u0027s not in the cache.\n                           \n```\n\nMaybe we can resolve this by having step (2) also do `obj-\u003eSetIsCachedReference(false)` ? That way step (3) will not wrongly remove obj2",
      "parentUuid": "1edbece1_67c83364",
      "range": {
        "startLine": 42,
        "startChar": 15,
        "endLine": 42,
        "endChar": 91
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa60639c_9e8fafac",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-12T20:25:34Z",
      "side": 1,
      "message": "Hmm, I think that the `ASSERT` shouldn\u0027t fail actually?\n\nSo in the example you gave, at (3), obj2 wouldn\u0027t be removed because the pointer equality condition that follows the `ASSERT` wouldn\u0027t pass. On the other hand, the `ASSERT` would be fine because hash equality would\u0027ve returned the `obj2` and not `end()`.\n\nWhen (4) comes around `obj2` is still in the cache so the `ASSERT` should pass because we find `obj2` and then the pointers are equal now so we actually `erase` it.",
      "parentUuid": "71adf152_c35de7cb",
      "range": {
        "startLine": 42,
        "startChar": 15,
        "endLine": 42,
        "endChar": 91
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95650cb5_a65817c7",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-12T20:42:32Z",
      "side": 1,
      "message": "oh yes, I see - and that\u0027s a different equality function than used for the set. Great thing to include in the tests so we don\u0027t regress the behavior!",
      "parentUuid": "fa60639c_9e8fafac",
      "range": {
        "startLine": 42,
        "startChar": 15,
        "endLine": 42,
        "endChar": 91
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab1815e5_7f04e1d2",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-13T05:12:45Z",
      "side": 1,
      "message": "Upon implementing the unit tests, I actually decided to remove the `ASSERT` and add a dtor `ASSERT` instead since it made more sense for the general data structure.",
      "parentUuid": "95650cb5_a65817c7",
      "range": {
        "startLine": 42,
        "startChar": 15,
        "endLine": 42,
        "endChar": 91
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3304b65e_f19a7e9b",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "to confirm: this can happen if two threads both fail to Find, then both create an object and both Insert ? if so, a comment would be helpful",
      "range": {
        "startLine": 44,
        "startChar": 12,
        "endLine": 45,
        "endChar": 36
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76efe2b5_058064d1",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Updated the comment, but no, this case is to protect against racing destruction when the entry in the cache hit refcount\u003d0 but hasn\u0027t been removed from the cache yet. If two threads both fail to `Find`, only 1 of the two will see `inserted \u003d\u003d true` because we acquire the cache lock at the start of `Insert`.",
      "parentUuid": "3304b65e_f19a7e9b",
      "range": {
        "startLine": 44,
        "startChar": 12,
        "endLine": 45,
        "endChar": 36
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91b92ca9_336cd2d8",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-10T00:36:29Z",
      "side": 1,
      "message": "I think double Insert is still something that happens here. See [a]",
      "parentUuid": "76efe2b5_058064d1",
      "range": {
        "startLine": 44,
        "startChar": 12,
        "endLine": 45,
        "endChar": 36
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e1bc3833_dfbe8851",
        "filename": "src/dawn/common/ContentLessObjectCache.h",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-12T20:25:34Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "91b92ca9_336cd2d8",
      "range": {
        "startLine": 44,
        "startChar": 12,
        "endLine": 45,
        "endChar": 36
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6cf9e9a_10b10a10",
        "filename": "src/dawn/common/RefCounted.cpp",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "I think this ASSERT is now contradictory with the body of the function which checks if the refcount becomes 0.\n\nalso though, I don\u0027t think we want to pay for acquire/release semantics for normal ref increment operations.\n\nCould we have a version that is exclusively called by the cache so it is only more expensive on cache lookups?",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 49,
        "endChar": 45
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3992d231_02255454",
        "filename": "src/dawn/common/RefCounted.cpp",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c6cf9e9a_10b10a10",
      "range": {
        "startLine": 49,
        "startChar": 0,
        "endLine": 49,
        "endChar": 45
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e493e45_37d0a748",
        "filename": "src/dawn/common/RefCounted.cpp",
        "patchSetId": 2
      },
      "lineNbr": 127,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "Cached objects will need an override of this (or just an override of DeleteThis) which acquires the cache\u0027s lock before actual deletion\n\nOtherwise, the deleting thread can make the ref go to zero, and then immediately go on to delete the object. Meanwhile, some other thread is attempting to do CopyRefIfCountNotZero on some deleted memory",
      "range": {
        "startLine": 127,
        "startChar": 0,
        "endLine": 127,
        "endChar": 38
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c3789096_02b171a4",
        "filename": "src/dawn/common/RefCounted.cpp",
        "patchSetId": 2
      },
      "lineNbr": 127,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "I think it\u0027s fine actually because all cached objects call `Device::Uncache*` (which calls the locked `ContentLessObjectCache::Erase`) in their `Destroy` function.",
      "parentUuid": "6e493e45_37d0a748",
      "range": {
        "startLine": 127,
        "startChar": 0,
        "endLine": 127,
        "endChar": 38
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8121fae9_880c5077",
        "filename": "src/dawn/common/RefCounted.cpp",
        "patchSetId": 2
      },
      "lineNbr": 127,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-13T21:33:53Z",
      "side": 1,
      "message": "I was talking with Corentin this morning about how we can make this more obviously correct.\n\nSummarizing - it\u0027s not obvious because there requires some coordination between the cache, refcounting, and destruction for things to work correctly. The cache assumes that objects are always removed from the cache strictly before they are deleted. It\u0027s because of this assumption that we can assume that performing TryGetRef while the cache mutex is acquired will never be a use-after-free.\n\nTaking a step back, this is not such a crazy assumption. If you start from the idea that the cache should not hold references to actually deleted things, then it follows that removal from the cache happens strictly before deletion. The tricky bit though is that there\u0027s a few steps between refcount going to 0, and actual deletion that need to be carefully considered, and problems could slip through in the future.\n\nThe way we discussed to really fix this would be to use real full on weak refs and put those inside the cache instead.\nThe interesting bit is how we might make it not unnecessarily heavy. One of the ways this is often done involves storing the refcount in a new, separate allocation - resulting in an extra indirection for every reference/release call. And, if we did this, that means we would need to fork the object hierarchy significantly since RefCounted is at the very, very bottom of it. We\u0027d need a RefCountedWithWeakRefSupport that cached objects ultimately inherit from instead. (or, we add this indirection to ALL RefCounted, so everything supports weakrefs).\n\nI think the other way we can do it is have the cached objects hold a WeakRef\u003cT\u003e back to themselves, and when you GetWeakRef they return that to you. WeakRef\u003cT\u003e holds a T* and has an Promote method to turn it into a Ref\u003cT\u003e. Promote needs to synchronize with deletion - the simple solution is to store a mutex in the WeakRef and acquire it on Promote and acquire it in DeleteThis of a cached object.\n\nIn practice, this is pretty similar to how the current implementation works, except there\u0027s a mutex per WeakRef as well as per cache, and the synchronization around promotion/deletion is more explicit.\n\nI think weakrefs are probably what we should do unless others have some better ideas. The semantics are for sure safer, though a little heavy. Weak refs let you store refs to deleted objects safely, but that\u0027s not *actually* what we\u0027re trying to do with the cache. We want something a bit less powerful; our cache might have soon-to-be-deleted and not reusable objects, but never actually contains deleted objects.",
      "parentUuid": "c3789096_02b171a4",
      "range": {
        "startLine": 127,
        "startChar": 0,
        "endLine": 127,
        "endChar": 38
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94f43bbc_3880c11a",
        "filename": "src/dawn/common/RefCounted.h",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "does it need to be private and do we need the friend class?\n\nI think it\u0027d be OK if it were public with some explicit name like CopyRefIfCountNotZero.\n\nAlso, the syntax `static_cast\u003cRefCountedT*\u003e(*it)-\u003etemplate GetRef\u003cRefCountedT\u003e();` is a bit clunky. I think we should be able to do something like `CopyRefIfCountNotZero(static_cast\u003cRefCountedT*\u003e(*it))`.\n\n```\nfriend Ref\u003cT\u003e CopyRefIfCountNotZero(T* obj) {\n  if (!mRefCount.IncrementIfNotZero()) {\n    return nullptr;\n  }\n  return AcquireRef(obj);\n}\n```",
      "range": {
        "startLine": 86,
        "startChar": 0,
        "endLine": 86,
        "endChar": 21
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "89cd1740_b4c58e95",
        "filename": "src/dawn/common/RefCounted.h",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "94f43bbc_3880c11a",
      "range": {
        "startLine": 86,
        "startChar": 0,
        "endLine": 86,
        "endChar": 21
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04f5ce30_3033146b",
        "filename": "src/dawn/common/RefCounted.h",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "to save an extra ref+release, this should work:\n\n```suggestion\n        return AcquireRef(static_cast\u003cT*\u003e(this));\n```",
      "range": {
        "startLine": 93,
        "startChar": 8,
        "endLine": 95,
        "endChar": 18
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e514a1bc_e10619ac",
        "filename": "src/dawn/common/RefCounted.h",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "04f5ce30_3033146b",
      "range": {
        "startLine": 93,
        "startChar": 8,
        "endLine": 95,
        "endChar": 18
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "492fa110_91a67778",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 828,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-06-09T18:05:55Z",
      "side": 1,
      "message": "here and the others - I think we\u0027re missing the case where two insertations race, and we only want to return the one that is inside the cache.\n\nSo I think this code should be:\n```suggestion\n    Ref\u003cBindGroupLayoutBase\u003e result \u003d mCaches-\u003ebindGroupLayouts.Find(\u0026blueprint);\n    if (result !\u003d nullptr) {\n        return std::move(result);\n    }\n    DAWN_TRY_ASSIGN(result, CreateBindGroupLayoutImpl(descriptor, pipelineCompatibilityToken));\n    result-\u003eSetContentHash(blueprintHash);\n    bool inserted;\n    [result, inserted] \u003d mCaches-\u003ebindGroupLayouts.Insert(result.Get());\n    if (inserted) {\n        result-\u003eSetIsCachedReference();\n    }\n    return std::move(result);\n```",
      "range": {
        "startLine": 820,
        "startChar": 0,
        "endLine": 828,
        "endChar": 29
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26fbd5a4_ab7277b8",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 828,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-06-09T22:37:36Z",
      "side": 1,
      "message": "Added helper for this sort of thing. Thanks for the catch!",
      "parentUuid": "492fa110_91a67778",
      "range": {
        "startLine": 820,
        "startChar": 0,
        "endLine": 828,
        "endChar": 29
      },
      "revId": "cc5477e6043bdfee99242c7f73991e23775db3c2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}