{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "af8d5289_7f23cedf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-02-26T21:18:04Z",
      "side": 1,
      "message": "PTAL. The primary input we\u0027re targeting for SharedBufferMemory for use with WebNN is an ID3D12Resource.",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "658b9688_1f677e7f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-02-26T21:46:23Z",
      "side": 1,
      "message": "it\u0027ll be useful to understand how the whole picture is going to work:\n - how is the ID3D12Resource allocated?\n - similar to my question about fences, why can\u0027t we use HANDLE like we do for SharedTextureMemory, and cache the import operation?\n - how will it work for cross-adapter resources?",
      "parentUuid": "af8d5289_7f23cedf",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ccd53a7_bbd1fbb1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-02-26T23:31:13Z",
      "side": 1,
      "message": "\u003e how is the ID3D12Resource allocated?\n\nFor our WebNN use case, the ID3D12Resource is allocated and managed by WebNN. Specifically, these appear to be standard Default, Upload and Readback buffers. These originate from WebNN\u0027s MLBuffer type, which is WIP [1].\n\n[1] https://chromium-review.googlesource.com/c/chromium/src/+/5101781\n\n\u003e why can\u0027t we use HANDLE like we do for SharedTextureMemory, and cache the import operation?\n\nFeedback I\u0027ve gotten is that there\u0027s some small performance overhead and the minor inconvenience going to/from HANDLE. We do prefer to import an ID3D12Resource*, however if you feel strongly we should use a HANDLE, we can use that instead.\n\n\u003e how will it work for cross-adapter resources?\n\nIt won\u0027t. We\u0027ll need to verify that the parent WebNN device and the Dawn device are the same upon import, otherwise we have to just return an error. For WebNN, we don\u0027t anticipate needing cross-adapter functionality and instead plan to move resources such that they would always be on same device device that Dawn is using.",
      "parentUuid": "658b9688_1f677e7f",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d762181_08a72703",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-02-27T01:35:27Z",
      "side": 1,
      "message": "Is there a way to validate the the ID3D12Resource is not a placed resource? I don\u0027t see a safe and easy way to make such an import work because then Dawn will need to make sure some external suballocator doesn\u0027t reallocate the resource.\n\nAside from that, I think it would be OK to use an ID3D12Resource if we plan on validating the device is the same. The benefit of share handle is that it doesn\u0027t let you share placed resources, so we have that guarantee.\n\nOverall though, I\u0027m surprised that we won\u0027t ever need cross-adapter functionality. Aren\u0027t there devices where the NPU and GPU are entirely separate adapters? You won\u0027t be able to keep resources on the same adapter in that scenario.",
      "parentUuid": "5ccd53a7_bbd1fbb1",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4cf5fe7c_d6361c3d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-02-27T09:40:33Z",
      "side": 1,
      "message": "LGTM",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63946b40_2bd018b0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-02-27T19:40:48Z",
      "side": 1,
      "message": "\u003e Is there a way to validate the the ID3D12Resource is not a placed resource? I don\u0027t see a safe and easy way to make such an import work because then Dawn will need to make sure some external suballocator doesn\u0027t reallocate the resource.\n\nI don\u0027t believe this should be a concern - I intend to maintain a ComPtr reference to the ID3D12Resource within Dawn, which would ensure the underlying memory of the ID3D12Resource cannot be destroyed or reallocated externally. Does that makes sense?\n\n\u003e Aside from that, I think it would be OK to use an ID3D12Resource if we plan on validating the device is the same. The benefit of share handle is that it doesn\u0027t let you share placed resources, so we have that guarantee.\n\nWe will validate the ID3D12Resource device matches the Dawn device.\n\n\u003e Overall though, I\u0027m surprised that we won\u0027t ever need cross-adapter functionality. Aren\u0027t there devices where the NPU and GPU are entirely separate adapters? You won\u0027t be able to keep resources on the same adapter in that scenario.\n\nYes, NPUs and GPUs can be separate devices. I admit I don\u0027t fully understand the tradeoffs and I\u0027m just parroting Rafael\u0027s opinion here. Direct quote from RC: \"Since WebGPU does not support \"high performance\" adapters, I was going to have WebNN take care of moving data to the correct adapter and have WebGPU be none the wiser to the fact that the imported buffer originally came from another adapter.\"\n\nIt seems like if this does ever become an issue we can just always add support to also import a HANDLE (like SharedTextureMemoryD3D11 does).",
      "parentUuid": "0d762181_08a72703",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0635172d_974f7300",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-02-27T21:12:14Z",
      "side": 1,
      "message": "\u003e I don\u0027t believe this should be a concern - I intend to maintain a ComPtr reference to the ID3D12Resource within Dawn, which would ensure the underlying memory of the ID3D12Resource cannot be destroyed or reallocated externally. Does that makes sense?\n\u003e \n\nIf the resource is a placed resource, the whoever allocated it orignally (WebNN) might **think** it has dropped all references and reallocate a new resource in its place. But actually, Dawn still is holding a reference. Now these two resources alias which is no good.\n\n\u003e Yes, NPUs and GPUs can be separate devices. I admit I don\u0027t fully understand the tradeoffs and I\u0027m just parroting Rafael\u0027s opinion here. Direct quote from RC: \"Since WebGPU does not support \"high performance\" adapters, I was going to have WebNN take care of moving data to the correct adapter and have WebGPU be none the wiser to the fact that the imported buffer originally came from another adapter.\"\n\u003e \n\u003e It seems like if this does ever become an issue we can just always add support to also import a HANDLE (like SharedTextureMemoryD3D11 does).\n\nI don\u0027t feel too strongly about using HANDLE or not if there is only a import single path. However, if we **know** we\u0027re going to need HANDLE in the future, then we may as well implement that now and have a single import path. If we end up having both ID3D12Resource and HANDLE, then I think we should delete the ID3D12Resource path in the future. It would be good to not go through the pain of deprecating and deleting it if we can avoid it. Lower overhead of ID3D12Resource isn\u0027t that compelling to me because the point of wgpu::SharedBufferMemory is that it lets you cache the cost of import and then never pay for it again.\n\nBut I guess it\u0027s hard to say how exactly things will be, and the details with NPU/GPU aren\u0027t so fleshed out yet, so this is fine for now.",
      "parentUuid": "63946b40_2bd018b0",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d746e386_beee170a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2024-02-27T23:33:10Z",
      "side": 1,
      "message": "[Unresolving this issue to make sure the discussion doesn\u0027t get lost]\n\n\u003e Overall though, I\u0027m surprised that we won\u0027t ever need cross-adapter functionality. Aren\u0027t there devices where the NPU and GPU are entirely separate adapters? You won\u0027t be able to keep resources on the same adapter in that scenario.\n\nFor same adapter sharing between Dawn and Chromium, I think `ID3D12Resource` should be sufficient.  \n\nWe\u0027ve had requests from developers to have WebNN respect the \"high performance\" request. Since the power preference adapter returned by `IDXGIFactory6::EnumAdapterByGpuPreference` can change over the course of the application\u0027s lifetime, it\u0027s important that it happen in one, central Chromium component. This way, developers will get the same high/lower power adapter whether they ask WebGPU or WebNN. \n\nFor now, we can decide to only allow same power preference adapters for WebGPU/WebNN interop. If not, we can have WebNN move resources to the correct adapter before calling Dawn or have Dawn move the resource itself. Unless I am missing something, we should be able to use `ID3D12Resource` as the sharing currency for SharedBufferMemory in either case.  \n\nIn case you\u0027re wondering, `ID3D11Device::OpenSharedResource` does not work with buffers. So WebGPU\u003c-\u003eWebNN interop will not work when WebGPU is in compat mode.",
      "parentUuid": "0d762181_08a72703",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f8a110f_c541fea6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-02-28T15:04:41Z",
      "side": 1,
      "message": "\u003e For same adapter sharing between Dawn and Chromium, I think ID3D12Resource should be sufficient.\n\nLike Austin said, ID3D12Resource is sufficient for same-adapter sharing, but it doesn\u0027t enforce that the resource is a committed resource, and other users could decide to reuse the same memory. That\u0027s why HANDLE would be slightly preferred, but either way.\n\n\u003e We\u0027ve had requests from developers to have WebNN respect the \"high performance\" request. Since the power preference adapter returned by IDXGIFactory6::EnumAdapterByGpuPreference can change over the course of the application\u0027s lifetime, it\u0027s important that it happen in one, central Chromium component. This way, developers will get the same high/lower power adapter whether they ask WebGPU or WebNN.\n\nIsn\u0027t it the case that if WebGPU-WebNN is to be used, the MLContext must be created with a gpu device as argument?",
      "parentUuid": "d746e386_beee170a",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc90506b_aecaa59d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-02-28T19:32:07Z",
      "side": 1,
      "message": "\u003e Like Austin said, ID3D12Resource is sufficient for same-adapter sharing, but it doesn\u0027t enforce that the resource is a committed resource, and other users could decide to reuse the same memory. That\u0027s why HANDLE would be slightly preferred, but either way.\n\nAfter some further discussion on our side we do acknowledge the memory synchronization risk, however we feel using ID3D12Resource* provides more flexibility for our usage and remains our preference. I\u0027ll merge this shortly if there are no objections.",
      "parentUuid": "9f8a110f_c541fea6",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a2a3978_f2a1b359",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2024-03-01T00:33:42Z",
      "side": 1,
      "message": "\u003e Like Austin said, ID3D12Resource is sufficient for same-adapter sharing, but it doesn\u0027t enforce that the resource is a committed resource, and other users could decide to reuse the same memory. That\u0027s why HANDLE would be slightly preferred, but either way.\n\nYes, there could bugs where the memory underlying a placed resource given to Dawn is accidentally given to another resource. But a similar bug happens if WebNN accidentally read/writes a committed resource given to Dawn without proper synchronization with its command queue.\n\nOne advantage of using ID3D12Resource is WebNN could decide to give Dawn a resource backed by a cross adapter heap on UMA devices. The only way to allocate such a resource as a buffer is to first allocate the cross adapter heap and then create a placed resource in the heap. Here, there is a handle to the heap but not to the placed resource. See https://learn.microsoft.com/en-us/windows/win32/direct3d12/shared-heaps.\n\n\u003e Isn\u0027t it the case that if WebGPU-WebNN is to be used, the MLContext must be created with a gpu device as argument?\n\nThe spec does have text that lets you provide a WebGPU device to the constructor of a WebNN context. However, people have been wanting the `MLBuffer` datatype to be more pervasive and be allowed to be created even if you request a context that is a \"gpu\" context.  I think that should be manageable in Chromium if we have one component own the adapter selection for everything else. Could be SharedContextState or Dawn itself; I do not feel strongly either way.",
      "parentUuid": "dc90506b_aecaa59d",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6c9c59e_87869455",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 389,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-02-27T09:40:33Z",
      "side": 1,
      "message": "This return will never be hit and could be removed.",
      "range": {
        "startLine": 387,
        "startChar": 0,
        "endLine": 389,
        "endChar": 0
      },
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "55882dda_7853017a",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 389,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-02-27T20:42:16Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e6c9c59e_87869455",
      "range": {
        "startLine": 387,
        "startChar": 0,
        "endLine": 389,
        "endChar": 0
      },
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}