{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "af8d5289_7f23cedf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-02-26T21:18:04Z",
      "side": 1,
      "message": "PTAL. The primary input we\u0027re targeting for SharedBufferMemory for use with WebNN is an ID3D12Resource.",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "658b9688_1f677e7f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-02-26T21:46:23Z",
      "side": 1,
      "message": "it\u0027ll be useful to understand how the whole picture is going to work:\n - how is the ID3D12Resource allocated?\n - similar to my question about fences, why can\u0027t we use HANDLE like we do for SharedTextureMemory, and cache the import operation?\n - how will it work for cross-adapter resources?",
      "parentUuid": "af8d5289_7f23cedf",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ccd53a7_bbd1fbb1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000248
      },
      "writtenOn": "2024-02-26T23:31:13Z",
      "side": 1,
      "message": "\u003e how is the ID3D12Resource allocated?\n\nFor our WebNN use case, the ID3D12Resource is allocated and managed by WebNN. Specifically, these appear to be standard Default, Upload and Readback buffers. These originate from WebNN\u0027s MLBuffer type, which is WIP [1].\n\n[1] https://chromium-review.googlesource.com/c/chromium/src/+/5101781\n\n\u003e why can\u0027t we use HANDLE like we do for SharedTextureMemory, and cache the import operation?\n\nFeedback I\u0027ve gotten is that there\u0027s some small performance overhead and the minor inconvenience going to/from HANDLE. We do prefer to import an ID3D12Resource*, however if you feel strongly we should use a HANDLE, we can use that instead.\n\n\u003e how will it work for cross-adapter resources?\n\nIt won\u0027t. We\u0027ll need to verify that the parent WebNN device and the Dawn device are the same upon import, otherwise we have to just return an error. For WebNN, we don\u0027t anticipate needing cross-adapter functionality and instead plan to move resources such that they would always be on same device device that Dawn is using.",
      "parentUuid": "658b9688_1f677e7f",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d762181_08a72703",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-02-27T01:35:27Z",
      "side": 1,
      "message": "Is there a way to validate the the ID3D12Resource is not a placed resource? I don\u0027t see a safe and easy way to make such an import work because then Dawn will need to make sure some external suballocator doesn\u0027t reallocate the resource.\n\nAside from that, I think it would be OK to use an ID3D12Resource if we plan on validating the device is the same. The benefit of share handle is that it doesn\u0027t let you share placed resources, so we have that guarantee.\n\nOverall though, I\u0027m surprised that we won\u0027t ever need cross-adapter functionality. Aren\u0027t there devices where the NPU and GPU are entirely separate adapters? You won\u0027t be able to keep resources on the same adapter in that scenario.",
      "parentUuid": "5ccd53a7_bbd1fbb1",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4cf5fe7c_d6361c3d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-02-27T09:40:33Z",
      "side": 1,
      "message": "LGTM",
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6c9c59e_87869455",
        "filename": "src/dawn/native/d3d12/DeviceD3D12.cpp",
        "patchSetId": 1
      },
      "lineNbr": 389,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-02-27T09:40:33Z",
      "side": 1,
      "message": "This return will never be hit and could be removed.",
      "range": {
        "startLine": 387,
        "startChar": 0,
        "endLine": 389,
        "endChar": 0
      },
      "revId": "10324b2ed9cbaef1a54f71db1d2e692efd69af6d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}