{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fbf64e28_0ffff68c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 7,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-30T08:11:36Z",
      "side": 1,
      "message": "nit: it\u0027s not a bug but part of the implementation of the feature ðŸ˜Š\n\nMaybe \"Track read-only depth-stencil attachment as read-only usage\"",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ebbcf926_ca274034",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-09-30T06:05:41Z",
      "side": 1,
      "message": "PTAL. Thanks.\n\nThe validation rule in WebGPU spec about resource usage for this (The same textureview as both SampledTexture and ReadOnlyRenderAttachment in a single render pass) is already there.",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cfd1b05c_3b90b4ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-30T08:11:36Z",
      "side": 1,
      "message": "LGTM",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f83a8199_68b89ff2",
        "filename": "src/dawn_native/CommandEncoder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 448,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-30T08:11:36Z",
      "side": 1,
      "message": "u-nit: IsReadOnlyDepthStencilAttachment (capital I)",
      "range": {
        "startLine": 448,
        "startChar": 13,
        "endLine": 448,
        "endChar": 45
      },
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd324bd9_9ff2d390",
        "filename": "src/dawn_native/CommandEncoder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 452,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-30T08:11:36Z",
      "side": 1,
      "message": "nit: Did you mean that the aspects should be a subset of Depth|Stencil? I don\u0027t think this checks that. You can use IsSubset from Math.h",
      "range": {
        "startLine": 452,
        "startChar": 24,
        "endLine": 452,
        "endChar": 67
      },
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0810f66e_fc419574",
        "filename": "src/dawn_native/CommandEncoder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 588,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-09-30T08:11:36Z",
      "side": 1,
      "message": "Since this is starting to implement the semantics of depthReadOnly/stencilReadOnly but the code isn\u0027t complete in the backends, I think we should mark this as an unsafe API until it is completed (otherwise developers will be able to cause memory barriers issues in the backends)",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "306a79dd_a4f432fb",
        "filename": "src/dawn_native/dawn_platform.h",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2021-09-30T23:50:12Z",
      "side": 1,
      "message": "Tangential to this change, but isn\u0027t this value now kReadOnlyRenderAttachment | CopySrc? Seems like it collides with both the new usage and an existing usage.",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "786b7433_d127a9ce",
        "filename": "src/dawn_native/dawn_platform.h",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-10-01T00:18:33Z",
      "side": 1,
      "message": "Good catch. What about set kAgainAsRenderAttachment to 0xFFFFFFFF? That value will be extremely hard to be hit by combinations.",
      "parentUuid": "306a79dd_a4f432fb",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c68e1998_79037aa5",
        "filename": "src/dawn_native/dawn_platform.h",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2021-10-01T00:36:53Z",
      "side": 1,
      "message": "Shouldn\u0027t it have its own bit? Like 0x40000000 or something.\n\nAs long as these \"internal\" bits are all next to each other (in this file) we should be able to notice collisions. Although I think we should group the BufferUsage bits and the TextureUsage bits separately so we can see the list easily.",
      "parentUuid": "786b7433_d127a9ce",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fafc60b8_20415c0f",
        "filename": "src/tests/unittests/validation/ResourceUsageTrackingTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 919,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2021-09-30T23:50:12Z",
      "side": 1,
      "message": "nit: IMO you should change as little as possible between the two cases, so depthLoadOp and depthStoreOp should stay the same and only depthReadOnly should change.",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a767dee_795bbf4b",
        "filename": "src/tests/unittests/validation/ResourceUsageTrackingTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 919,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-10-01T00:18:33Z",
      "side": 1,
      "message": "depthLoadOp\u0027s default value in ComboRenderPassDescriptor is not \"Load\", it is \"Clear\". But the spec requires it to be \"Load\" if depthReadOnly is true. So changing depthLoadOp is a must. But setting depthStoreOp is indeed unnecessary because it is already the required value by default. I just wanted to make it clear and consistent.",
      "parentUuid": "fafc60b8_20415c0f",
      "revId": "707ab4a2a552dfe00885048a0c41596918a8cb2c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}