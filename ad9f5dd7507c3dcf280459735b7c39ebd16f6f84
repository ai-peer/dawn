{
  "comments": [
    {
      "key": {
        "uuid": "d727995d_3b9083bb",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-01-23T23:29:58Z",
      "side": 1,
      "message": "The lost buffer change also had code in special places that need to workaround the fact Destroy is not called in the destructor on device removed. This seems a bit fragile.  \n\nInstead of having Destroy get skipped if on device lost, we should consider letting it run more than once and be resilient to having some objects of the class already be destroyed in a previous go-around.  \n\nThoughts?",
      "range": {
        "startLine": 99,
        "startChar": 0,
        "endLine": 103,
        "endChar": 0
      },
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "accfacb6_939cf436",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-01-24T00:46:11Z",
      "side": 1,
      "message": "What about having Derived::Destroy handle destroying mErrorScopeTracker and mFenceSignalTracker , and ASSERT that happened in DeviceBase::~DeviceBase ?\n\nThis is what we do for the DynamicUploader.\n\nThen, in ~ErrorScopeTracker and ~FenceSignalTracker (and other relevant trackers as well), they can check if the Device is alive, and call (or mark) all callbacks / objects with the DeviceLost status?",
      "parentUuid": "d727995d_3b9083bb",
      "range": {
        "startLine": 99,
        "startChar": 0,
        "endLine": 103,
        "endChar": 0
      },
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c3d6153_ffc25ac2",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-01-24T00:50:51Z",
      "side": 1,
      "message": "Sorry, last step is probably unnecessary so long as all of the things that happen on Tick() check if the Device is lost and set the status appropriately.",
      "parentUuid": "accfacb6_939cf436",
      "range": {
        "startLine": 99,
        "startChar": 0,
        "endLine": 103,
        "endChar": 0
      },
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3264152a_b2658281",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-01-24T10:11:02Z",
      "side": 1,
      "message": "Either way would work imho. Being resilient to destroy being called twice could have the slight advantage that things are less likely to break when we add more service. If the cost is slightly more overhead at destruction that\u0027s fine, but hopefully it doesn\u0027t impact the code of service to add overhead during regular operations.",
      "parentUuid": "1c3d6153_ffc25ac2",
      "range": {
        "startLine": 99,
        "startChar": 0,
        "endLine": 103,
        "endChar": 0
      },
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4efb862c_43f552f5",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 103,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-27T19:49:01Z",
      "side": 1,
      "message": "i think this will require tick to be run after device is lost. (I moved copied those from tick, since device was lost, tick gets skipped)",
      "parentUuid": "3264152a_b2658281",
      "range": {
        "startLine": 99,
        "startChar": 0,
        "endLine": 103,
        "endChar": 0
      },
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d437f15e_7f65710d",
        "filename": "src/dawn_native/Fence.cpp",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-23T21:30:22Z",
      "side": 1,
      "message": "do we want to send WGPUFenceCompletionStatus_DeviceLost status here?",
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cdd9de0b_e6da00f6",
        "filename": "src/dawn_native/Fence.cpp",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-01-24T00:46:11Z",
      "side": 1,
      "message": "If the Device is lost, then yes.",
      "parentUuid": "d437f15e_7f65710d",
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d7ed1e5_8bd04061",
        "filename": "src/dawn_native/Fence.cpp",
        "patchSetId": 2
      },
      "lineNbr": 109,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-01-24T00:46:11Z",
      "side": 1,
      "message": "Similar to with Buffers, can we test that\n\nfence.onCompletion(value, callback, userdata)\nSetCallbackAndLoseForTesting();\n\nwill call |callback| with DeviceLost ?",
      "range": {
        "startLine": 109,
        "startChar": 20,
        "endLine": 109,
        "endChar": 38
      },
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8201e9e8_e37ef1bb",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-01-24T10:11:02Z",
      "side": 1,
      "message": "This isn\u0027t used.",
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "64db6779_6eb0d29a",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 42,
      "author": {
        "id": 1000308
      },
      "writtenOn": "2020-01-27T19:49:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8201e9e8_e37ef1bb",
      "revId": "ad9f5dd7507c3dcf280459735b7c39ebd16f6f84",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    }
  ]
}