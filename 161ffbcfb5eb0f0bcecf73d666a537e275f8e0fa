{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "323fa463_109bb4c1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000024
      },
      "writtenOn": "2023-11-05T23:14:54Z",
      "side": 1,
      "message": "LGTM (bots willing)",
      "revId": "161ffbcfb5eb0f0bcecf73d666a537e275f8e0fa",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2b211f7_44802706",
        "filename": "src/tint/lang/glsl/writer/ast_printer/ast_printer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1938,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-11-06T12:23:21Z",
      "side": 1,
      "message": "`UniqueIdentifier` will append suffixes to make sure the name is unique, on symbol collision. As you\u0027re trying to create the unique name in the printer which is the end of the pipeline, this comes after transforms like `SingleEntryPoint`, you might end up with different names between stages for the same variable.\n\nA test that has a symbol collision made by a reference to a variable or structure with the name `blah_ubo_n`, made by just one stage might demonstrate this.\n\nYou might need to create a new transform that runs very early to fix this properly. That transform would have to create a new structure per SSBO.",
      "range": {
        "startLine": 1938,
        "startChar": 15,
        "endLine": 1938,
        "endChar": 47
      },
      "revId": "161ffbcfb5eb0f0bcecf73d666a537e275f8e0fa",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91ae2139_25732b2c",
        "filename": "src/tint/lang/glsl/writer/ast_printer/ast_printer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1938,
      "author": {
        "id": 1000024
      },
      "writtenOn": "2023-11-06T18:38:45Z",
      "side": 1,
      "message": "That\u0027s what I was trying to get at (probably badly) with my question in the bug.\n\nWhat if we simply skipped the UniqueIdentifier call, and modified the renamer (for GLSL) to rename anything of the form `*_ubo_*` and `*_ssbo_*`. Would that work?",
      "parentUuid": "d2b211f7_44802706",
      "range": {
        "startLine": 1938,
        "startChar": 15,
        "endLine": 1938,
        "endChar": 47
      },
      "revId": "161ffbcfb5eb0f0bcecf73d666a537e275f8e0fa",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "742d41a6_bf28c30e",
        "filename": "src/tint/lang/glsl/writer/ast_printer/ast_printer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1938,
      "author": {
        "id": 1000685
      },
      "writtenOn": "2023-11-06T20:48:45Z",
      "side": 1,
      "message": "Yeah Stephen asked about this in bug. I tried and seemed that opengl didn\u0027t complain. But looking closer at the GLSL, the mismatch of block name is present though, with the case Ben suggested.\n\nWGSL input\n```\n@group(0) @binding(0) var\u003cuniform\u003e tint_symbol_ubo_0: f32;\n        @group(0) @binding(1) var\u003cuniform\u003e tint_symbol_ubo_1: u32;\n\n        @vertex fn vertex() -\u003e @builtin(position) vec4f {\n          _ \u003d tint_symbol_ubo_0;\n          _ \u003d tint_symbol_ubo_1;\n          return vec4f(tint_symbol_ubo_0) + vec4f(f32(tint_symbol_ubo_1));\n        }\n\n        @fragment fn fragment() -\u003e @location(0) vec4f {\n          _ \u003d tint_symbol_ubo_1;\n          return vec4f(f32(tint_symbol_ubo_1));\n        }\n```\n\n```\nInfo: /* Dumped generated GLSL Vertex */\n#version 320 es\n\nlayout(binding \u003d 0, std140) uniform tint_symbol_block_ubo_0 {\n  float inner;\n} tint_symbol;\n\nlayout(binding \u003d 1, std140) uniform tint_symbol_1_block_ubo_1 {\n  uint inner;\n} tint_symbol_1;\n\nvec4 tint_symbol_2() {\n  return (vec4(tint_symbol.inner) + vec4(float(tint_symbol_1.inner)));\n}\n\nvoid main() {\n  gl_PointSize \u003d 1.0;\n  vec4 inner_result \u003d tint_symbol_2();\n  gl_Position \u003d inner_result;\n  gl_Position.y \u003d -(gl_Position.y);\n  gl_Position.z \u003d ((2.0f * gl_Position.z) - gl_Position.w);\n  return;\n}\n\nInfo: /* Dumped generated GLSL Fragment */\n#version 320 es\nprecision highp float;\n\nlayout(location \u003d 0) out vec4 value;\nlayout(binding \u003d 1, std140) uniform tint_symbol_block_ubo_1 {\n  uint inner;\n} tint_symbol;\n\nvec4 tint_symbol_1() {\n  return vec4(float(tint_symbol.inner));\n}\n\nvoid main() {\n  vec4 inner_result \u003d tint_symbol_1();\n  value \u003d inner_result;\n  return;\n}\n\n```\n\nNote `\"tint_symbol_1_block_ubo_1\" !\u003d \"tint_symbol_block_ubo_1\"`\n\nBut glLinkProgram didn\u0027t complain about it. Weird.\n\n\nWhat Stephen suggests: with the Renamer transform now takes extra input of remappings of assigned name, in dawn we can tell tint that these binding variable names have their custom remappings, e.g.:\n\n\"@group(0) @binding(0) var\u003cuniform\u003e blah_ubo_0\" -\u003e \"dawn_binding_0_0\"\n\"@group(0) @binding(1) var\u003cuniform\u003e blah_ubo_1\" -\u003e \"dawn_binding_0_1\"\n\nThis is not directly assign block name, but the name of the variable. Tint now deducts the block name from the variable name. I feel this is not 100% stable, e.g. if Tint changes internal renaming rules of these blocks, mismatch can still happen.\n\nBut would like to hear your thoughts.",
      "parentUuid": "91ae2139_25732b2c",
      "range": {
        "startLine": 1938,
        "startChar": 15,
        "endLine": 1938,
        "endChar": 47
      },
      "revId": "161ffbcfb5eb0f0bcecf73d666a537e275f8e0fa",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "28139447_bf406bf2",
        "filename": "src/tint/lang/glsl/writer/ast_printer/ast_printer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1938,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-11-06T21:10:13Z",
      "side": 1,
      "message": "\u003e Tint now deducts the block name from the variable name.\n\nAnything that does this suffers the same collision issue. I still think the most stable option is to create a new transform that generates these buffer object structures early in the transform list. It doesn\u0027t matter what you name these (`b.Symbols().New()` is sufficient), so long as the symbol is consistent for each entry point.\n\nTo do this though, you might have to wrap the variable type in a new, unique structure, and fix up the accesses to go via a member access. Without nesting, you\u0027ll get a type mismatch when attempting to between uniform / storage vars and another variable of the same type.",
      "parentUuid": "742d41a6_bf28c30e",
      "range": {
        "startLine": 1938,
        "startChar": 15,
        "endLine": 1938,
        "endChar": 47
      },
      "revId": "161ffbcfb5eb0f0bcecf73d666a537e275f8e0fa",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}