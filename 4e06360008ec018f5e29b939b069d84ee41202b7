{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "dc399438_83ec18ff",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-11T14:39:02Z",
      "side": 1,
      "message": "This strays from the design that we discussed with Microsoft folks (Peng, if there is nothing confidential in that doc, do you mind sharing it with Intel folks? Or publicly?) https://docs.google.com/document/d/1d2dKbNnnZOCivq5jVfrTndU9eqv64h6F468jnQGaq-0\n\nIn general emulating staging buffers should be slower for a bunch of things because instead of doing 2 copies (application -\u003e staging buffer, staging buffer -\u003e GPU-local buffer) we have three (application -\u003e emulated buffer, emulated buffer -\u003e driver staging buffer, driver staging buffer -\u003e GPU-local buffer).\n\nWhat is the map operation that was measured to be slow and what is the chain of operation that cause it?",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0589c3e4_5acdd485",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-11T20:34:09Z",
      "side": 1,
      "message": "I shared the doc with jie.\n\nD3D11\u0027s Map() and Unmap() methods are on the ID3D11DeviceContext instead of ID3D11Buffer or ID3D11Device. Not like Metal, Vulkan and D3D12, they have to synchronize between CPU and GPU. I think it adds extra overhead. I tested with AMD and Nvidia GPU. It doubles MotionMark Images score with AMD GPU (33 -\u003e 72), and +24% with NVidia GPU (59 -\u003e 73). MotionMark Images does CopyBufferToTexture a lot.\n\nThe overall motionmark scores:\nAMD GPU: 1100 (Ganesh) vs 1263 (Graphite) vs 1447 (Graphite with this CL). \nNVidia GPU: 1126 vs 1349 vs 1392\nJie tested with Intel, it improves more. 1334 (Ganesh) -\u003e 2379(graphite with this CL)\n\nI think there are two major use cases in graphite (see below), and graphite tracks transfer buffer usages, it only reuses transfer buffers, when the previous GPU accessing is done. However we don\u0027t know how d3d11 driver track buffer usage. It may be not very smart.\n\n1. Transfer buffer -\u003e uniform buffer (vertex buffer), etc.\n   For this case, this CL may add an extra copy, but it saves Map() and Unmap() calls (Metal, Vulkan, D3D12 backends only map staging buffer once, and neve call Unmap() them), and staging buffer allocations. If the copy size is small, the one extra copy could be ignored.\n   And for UMA GPU, probably it doesn\u0027t need an extra copy (`emulated buffer -\u003e staging buffer`), I am not sure.\n \n2. Transfer buffer -\u003e textures. MotionMark images test does this a lot.\n   For this case, d3d11 doesn\u0027t support copying data between staging `ID3D11Buffer` and `ID3D11Texture2D`. With the emulated buffer, it doesn\u0027t add any extra copy, but save the calls of Map() and Unmap(), and staging buffer allocations.",
      "parentUuid": "dc399438_83ec18ff",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02272edd_409d38cd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-11T21:23:19Z",
      "side": 1,
      "message": "FYI, for `CopyBufferToTexture` command, graphite has to also call `Map()/Unamp()` while executing the command for reading back the data from the `ID3D11Buffer`. \n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/CommandBufferD3D11.cpp;l\u003d354?q\u003dCommandBufferD3D11.cpp\u0026ss\u003dchromium",
      "parentUuid": "0589c3e4_5acdd485",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "864d9543_794a7d3f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-12T02:12:41Z",
      "side": 1,
      "message": "To be clearer for the perf data on Intel:\n(1) Graphite without the CL is 1726. That is to say: 1334 (Ganesh) -\u003e 1726(Graphite) -\u003e 2379(graphite with this CL).\n(2) Intel runs on a medium screen, that is why the score is higher than AMD and Nvdia, where the test runs on a large screen.\n\nMy overall impression is that data copy itself is not that expensive, however map/unmap may stall GPU significantly if not carefully used.",
      "parentUuid": "02272edd_409d38cd",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "940511b6_3492b294",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-12T14:28:37Z",
      "side": 1,
      "message": "There are two cases to consider for Graphite, trying to summarize my understanding:\n\n - Use case 1: Uniform / vertex updates: Graphite writes a bunch of the updates in a mapped buffer then encodes a bunch of small copyB2B.\n - Use case 2: Texture upload: Graphite writes to a mapped buffer then encodes a few large CopyB2T calls.\n \nI\u0027m surprised that the D3D11 \"may not be very smart\" with respect to avoiding stalls on Map() calls, in my experience, D3D11 drivers are among the ones that received the most engineering and tuning so it\u0027s surprising that they don\u0027t have a way to know when resources are finished being used. Looking at the code, we never call ID3D11DevicedContext::Flush() which would help it \"segment\" our workload to track when things are used. Does calling it in CommandRecordingContext::ExecuteCommandList() help?\n\nThe design doc also calls for using a shader blit to implement CopyB2T, even for mappable buffers (with an intermediate copy to a DEFAULT buffer). This is the same amount of copying that this CL does, but the extra copy is done on the GPU instead of the CPU, so it should be faster. Any reason we can\u0027t do this now?\n\nOverall I agree that the improvements are massive and worth it, however I think that by digging in why these improvements happen, we can find even better solution that scale to more use-cases and with less heuristics.",
      "parentUuid": "864d9543_794a7d3f",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd99feee_0d1bc6f9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-14T09:02:33Z",
      "side": 1,
      "message": "I tried calling ID3D11DevicedContext::Flush() in CommandRecordingContext::ExecuteCommandList()\". Unfortunately it didn\u0027t make a difference.\n\nI also tried calling [map](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/BufferD3D11.cpp;drc\u003d16b3c288a3144342908f6b8b7aede057c40528bd;l\u003d272) with \"D3D11_MAP_FLAG_DO_NOT_WAIT\". It never returned \"DXGI_ERROR_WAS_STILL_DRAWING\". It seems D3D11 indeed doesn\u0027t know when resources are finished being used. With this CL in dawn alone, and without the the full-size write [CL](https://skia-review.googlesource.com/c/skia/+/798636) in skia, which only involves a 256 uniform buffer map write, MM can only score 1869 instead of 2379. That\u0027s to say, map/unmap a staging buffer is actually a perf key point here. \nCurrently graphite updates vertex/uniform buffers in a way as mentioned in \"Use case 1\". That\u0027s not the recommended way for D3D11. Ideally we should use dynamic buffers and map with \"D3D11_MAP_WRITE_DISCARD/D3D11_MAP_WRITE_NO_OVERWRITE\". Maybe we can try that by enabling and extending \"Feature::BufferMapExtendedUsages\" on Win as [Metal](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/metal/BackendMTL.mm;drc\u003d73d42978dc9ec38c13f6af91e90a38e7ab1b59b2;l\u003d620).\n\nMM doesn\u0027t involve texture uploads for a very large size of data, like 720p video. So the urgency to use a shader blit to implement CopyB2T haven\u0027t come up yet. Sooner or later we will need to address that.",
      "parentUuid": "940511b6_3492b294",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62c6b417_78a0c997",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-15T14:02:02Z",
      "side": 1,
      "message": "It makes sense that map() never returned `D3D11_MAP_FLAG_DO_NOT_WAIT` with `D3D11_MAP_FLAG_DO_NOT_WAIT`, since graphite tracks usage of staging buffers, and only reuses them when they are not used by GPU.\n\nFor `D3D11_MAP_WRITE_DISCARD/D3D11_MAP_WRITE_NO_OVERWRITE`, do you mean map uniform or vertex buffers directly without using staging buffers? It should improve MotionMark Images scores, but the test still uses map/unmap for uploading data to textures heavily. I think we can have both emulated staging buffer and  `Feature::BufferMapExtendedUsages` for d3d11. Maybe it can improve perform further.",
      "parentUuid": "bd99feee_0d1bc6f9",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af35d7b7_d25dbe02",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-15T15:52:18Z",
      "side": 1,
      "message": "Can we have a different CL that adds the `D3D11_MAP_FLAG_DO_NOT_WAIT` and the `Flush()` in the recording context? This would be an improvement for users of Dawn because it should guarantee that MapAsync() never blocks things, and that `DXGI_ERROR_WAS_STILL_DRAWING` never happens because the flush should make sure fences are signaled correctly wrt. to what the D3D11 driver sees.\n\n\u003e  Ideally we should use dynamic buffers and map with \"D3D11_MAP_WRITE_DISCARD/D3D11_MAP_WRITE_NO_OVERWRITE\".\n\nIMHO we shouldn\u0027t do that, because even though it is recommended to avoid developers messing up, ultimately what happens is that the driver should be handling its own buffer renaming and staging internally. D3D12 goes away with it, which shows that it isn\u0027t something necessary for the hardware, just something that the driver took care off for the application in D3D11.\n\n+CC Rafael, what are the costs associated with mapping buffer with `D3D11_MAP_FLAG_DO_NOT_WAIT` compared to an `UpdateSubresource`?\n\nIf we really can\u0027t understand where the overhead comes from we can go with an approach like this, but we\u0027ll eventually need to revisit with something that\u0027s a better heuristic and more consistent.",
      "parentUuid": "62c6b417_78a0c997",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d60369f3_7109b644",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-16T07:45:29Z",
      "side": 1,
      "message": "The CL https://dawn-review.googlesource.com/c/dawn/+/169841 for `D3D11_MAP_FLAG_DO_NOT_WAIT` and `Flush()`.\n\nI did more tests with `D3D11_MAP_FLAG_DO_NOT_WAIT`, and made some experiments with these changes:\na) skia-graphite full-size write\nb) flush in CommandRecordingContext::ExecuteCommandList()\nc) upload buffer emulation(this CL)\n\n\na(N) b(N) c(N) score(1746) DXGI_ERROR_WAS_STILL_DRAWING(Y)\na(N) b(Y) c(N) score(1738) DXGI_ERROR_WAS_STILL_DRAWING(Y)\na(Y) b(N) c(N) score(1785) DXGI_ERROR_WAS_STILL_DRAWING(Y)\na(Y) b(Y) c(N) score(1860) DXGI_ERROR_WAS_STILL_DRAWING(Y)\na(Y) b(Y) c(Y) score(2247) DXGI_ERROR_WAS_STILL_DRAWING(N)\na(Y) b(N) c(Y) score(2017) DXGI_ERROR_WAS_STILL_DRAWING(N)\n\nobservations:\n1) no DXGI_ERROR_WAS_STILL_DRAWING found with a) and c).\n2) Without a), DXGI_ERROR_WAS_STILL_DRAWING occurs immediately after chromium is launched.\n3) With a), but without c), DXGI_ERROR_WAS_STILL_DRAWING doesn\u0027t occur running \"Images\" alone, but does running the full \"MotionMarker\".\n4) DXGI_ERROR_WAS_STILL_DRAWING seems irrelevant with b)\n5) b) plays a negative impact in score when there is no DXGI_ERROR_WAS_STILL_DRAWING.\n\n\nMy only concern is about `Flush`. I am not sure about it. The manual also advises not to use it.\n\n\"Most applications don\u0027t need to call this method. If an application calls this method when not necessary, it incurs a performance penalty. Each call to Flush incurs a significant amount of overhead.\"",
      "parentUuid": "af35d7b7_d25dbe02",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fb93077_56cb1350",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-16T08:10:02Z",
      "side": 1,
      "message": "Essentially, the problem seems to be that D3D11/driver can\u0027t tell exactly when a buffer can be recycled for mapping re-use. The current [fence](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/QueueD3D11.cpp;drc\u003dee224b663bbbd61650d528530768f9b6d247ff8c;l\u003d223) approach seems not precise enough.",
      "parentUuid": "d60369f3_7109b644",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd516510_af03f821",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-16T18:53:46Z",
      "side": 1,
      "message": "In my understanding, the reason why CopyBufferToTexture with the current implementation is slow is because it is implemented with a simple and easy workaround that we knew would be slow. Performing the copy itself maps the source buffer, and then performs a CPU upload of the texture data. So of course our current fence approach does not prevent stalls in GPU execution, because our fence only controls when we map for writing into the original source buffer - but this is a separate internal map that occurs for writing into the destination buffer.\nWith the current workaround, the code will write into the source buffer, then immediately map it, and upload to the destination texture. Since we map immediately after writing, it is not surprising that a GPU wait is involved.\n\nI\u0027m confused about why we are trying this system memory approach, because as Corentin mentioned, it diverges from the design we discussed previously, and worked with Microsoft to identify what we think the best approach is - which is to use a shader blit to do the texture-to-buffer copy. Did we try this? I would like us to investigate this approach first.\nNote that we already have a blit path for various texture formats implemented [here](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/CommandEncoder.cpp;l\u003d1722;drc\u003de036a8e7200d41afa08898ccede1324355ed5741;bpv\u003d0;bpt\u003d1); you may need to expand it.",
      "parentUuid": "2fb93077_56cb1350",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "27ea6886_743f2955",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-16T20:26:51Z",
      "side": 1,
      "message": "I think another thing maybe we should check is. ID3D11DeviceContext::{Map/Unmap}() call will require a global lock in the immediate context. It could reduce the performance, especially there are too much work for submit dawn command buffers on the GPU main thread for MotionMark.",
      "parentUuid": "bd516510_af03f821",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fb21a17_44a859e6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-17T03:56:54Z",
      "side": 1,
      "message": "For CopyBufferToTexture, I agree we should try the shader blit approach as the original design advised. We can do that in some follow-up CLs later. However, the key factor now impacting the MM perf is CopyBufferToBuffer as I mentioned previously:\n\u003e\u003e With this CL in dawn alone, and without the the full-size write CL in skia, which only involves a 256 uniform buffer map write, MM can only score 1869 instead of 2379. That\u0027s to say, map/unmap a staging buffer is actually a perf key point here.\n\n\nMore specifically, the problem most likely is that we map a buffer still being used by GPU. To solve this problem, firstly we need to sort out how we can safely map a buffer used in previously submitted commands in case of D3D11 immediate context. The current Fence we are using should be correct according to the D3D11 manual. That\u0027s to say, when the fence value passes, all previous buffers should be safe to be mapped without stalling GPU. If this is true, we can revisit all current buffer usages to follow this rule. As far as I know, internally the [staging buffer](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/DeviceD3D11.h;drc\u003d208ce394095cff453d85f5d7070a6fa8c2970dac;l\u003d167) and the [built-in uniform buffer](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/CommandRecordingContextD3D11.h;drc\u003dc696bee7fb87959b4db2dba8a85395439fd4110c;l\u003d67) at least are not properly tracked with fence serial. For external buffers used by clients, one problem I can identify now is [MapAsyncImpl](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/Buffer.cpp;drc\u003de036a8e7200d41afa08898ccede1324355ed5741;l\u003d576). For D3D11, that\u0027s not right timing to do the actual map. Instead we should do that only after the buffer\u0027s `mLastUsageSerial` has passed. With these cleanup done, we can map with `D3D11_MAP_FLAG_DO_NOT_WAIT` by default, and throw out an error instead of warning in case of `DXGI_ERROR_WAS_STILL_DRAWING`. This might be the right way to solve the map perf issue. Certainly the assumption is based on that the Fence works as expected.",
      "parentUuid": "27ea6886_743f2955",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "186e4873_30f01d09",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-17T18:29:44Z",
      "side": 1,
      "message": "I see - you\u0027re spot on about those buffer usages not doing any fence tracking at all. We should update the usage of the staging buffer and uniform buffer to be smarter about how we map instead of using system memory. And yes, we should also update D3D11\u0027s MapAsyncImpl to map after the serial has passed instead of when the map is requested.",
      "parentUuid": "2fb21a17_44a859e6",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4e82ed8_cb256c15",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2024-01-17T18:36:30Z",
      "side": 1,
      "message": "UpdateSubResource will make a copy of the data you pass it if the buffer is currently in use by the GPU. If you want to avoid this copy, you should keep a pool of staging buffers and look for a free one by calling Map with the \"do not wait\" flag and use the first one that returns S_OK. \n\nWith a profiler and symbols, we should be able to determine where the overhead is coming from. The Windows performance analyzer has a tool (Critical Path Analysis) which tells you when the CPU is stalled and what callstack causes it to be woken up. Happy to look at traces of workloads if you\u0027d like.",
      "parentUuid": "2fb21a17_44a859e6",
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c335db4_aa400d1c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-11T21:19:11Z",
      "side": 1,
      "message": "We also have a dawn bug about it. Please add it here.\nhttps://bugs.chromium.org/p/dawn/issues/detail?id\u003d1732",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 3
      },
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d9ef21cb_c1f6c295",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-01-12T02:12:41Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5c335db4_aa400d1c",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 3
      },
      "revId": "4e06360008ec018f5e29b939b069d84ee41202b7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}