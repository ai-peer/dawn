{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1c644ae7_fbb3ebb3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2022-07-07T14:02:37Z",
      "side": 1,
      "message": "Please take a look, thanks",
      "revId": "d219816726761deab4a0d2070b99916e2888601e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fc41352e_8540ea80",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2022-07-07T15:04:00Z",
      "side": 1,
      "message": "I suspect that this will not work with storage buffers and uniform buffers, as they both use the `DecomposeMemoryAccess` transform, which will flatten down to an `array\u003cvec4\u003cu32\u003e, N\u003e`.\n\nFor read-only buffers this can be implemented by unpacking a 16-bit float from the 32-bits, but for read-write storage buffers, there\u0027s no easy way to safely write from two invocations.\n\nTo accomplish this, I think we\u0027d need the HLSL writer to utilize the templated Load/Store ops with a `ByteAddressBuffer`. This isn\u0027t supported by FXC.",
      "revId": "d219816726761deab4a0d2070b99916e2888601e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6c0115a_a13dd552",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2022-07-07T16:41:13Z",
      "side": 1,
      "message": "Thanks for review!\nCurrently I haven\u0027t implement storage / uniform buffer support yet (intentionally), because I do realize there are some tricky cases for buffer accessing. Also I don\u0027t test array of f16 yet.\nI would like to first support using f16 types within a single shader, which includes declaring and constructing module-scope and function-scope f16 types variable and constant (frontend supported in CL #94642, and backend in these under-reviewing CLs and another two CLs to be uploaded for SPIRV and WGSL) and also using these variable and constant to call operator and built-in function (going to be the next CLs); than we are going to support f16 in storage / uniform buffer, and pipeline IO. This is my current plan, and I would love to have your suggestions.",
      "parentUuid": "fc41352e_8540ea80",
      "revId": "d219816726761deab4a0d2070b99916e2888601e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "27ee7699_976d7734",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2022-07-07T17:01:30Z",
      "side": 1,
      "message": "Okay, we can defer buffer and I/O accesses, however we need to ensure that these WIP codepaths are safe (no null-derefs, no crashes, etc), so these need tests.\n\nThe fuzzers will report backend failures (that passed validation) as bugs that need fixing, so just putting errors in the backend is likely to upset the fuzzers.\n\nOne other thing to consider is that the `DecomposeMemoryAccess` transform may be required for more backends, due to the WG decision to ensure that padding bytes are not touched in loads and stores.\n\nFor the above reasons, maybe we should error out as `not implemented yet` in the resolver for use of `f16` in the `storage` or `uniform` storage class, or in use as I/O. WDYT?",
      "parentUuid": "b6c0115a_a13dd552",
      "revId": "d219816726761deab4a0d2070b99916e2888601e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4d1a0f0a_43a9d985",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2022-07-08T01:39:48Z",
      "side": 1,
      "message": "Yes, I think that would be a safe path. I will do the validation in resolver now.",
      "parentUuid": "27ee7699_976d7734",
      "revId": "d219816726761deab4a0d2070b99916e2888601e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "593ed4da_02e26fdc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2022-07-08T19:47:25Z",
      "side": 1,
      "message": "After the resolver patch landed (https://dawn-review.googlesource.com/c/dawn/+/95827), would this patch be proper to merge now?",
      "parentUuid": "4d1a0f0a_43a9d985",
      "revId": "d219816726761deab4a0d2070b99916e2888601e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "975047f5_e9655058",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002536
      },
      "writtenOn": "2022-07-08T19:47:25Z",
      "side": 1,
      "message": "Please take a look, thanks",
      "revId": "d219816726761deab4a0d2070b99916e2888601e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1c3e4f8b_2150f8f3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2022-07-11T13:34:46Z",
      "side": 1,
      "message": "Yes, thank you!",
      "parentUuid": "593ed4da_02e26fdc",
      "revId": "d219816726761deab4a0d2070b99916e2888601e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}