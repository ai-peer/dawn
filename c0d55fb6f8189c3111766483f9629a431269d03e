{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "10610023_73cf0a5f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-06-17T11:02:17Z",
      "side": 1,
      "message": "This mostly re-uses the code lines in Peng\u0027s previous attempting [CL](https://dawn-review.googlesource.com/c/dawn/+/180322). Instead of totally replacing Fence with Query, this only uses Query for completion serial pumping, and still keeps Fence for shared resource synchronization. Therefore the complexity is largely reduced, meantime Fence signaling can still be significantly avoided.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56ff5915_3c412a7c",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 288,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-17T13:49:53Z",
      "side": 1,
      "message": "Note: `isMonitored` here is leaking implementation details to be implemented in `Queue`. Could we either create the fence in the child classes constructors and set them on the parent, or pass the fence flags into the constructor? (in a follow-up).",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69baf48a_5b0aae36",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 295,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-17T13:49:53Z",
      "side": 1,
      "message": "Would this way of doing completion tracking also work on the UnmonitoredQueue? Is that\u0027s the case then we could merge much of the logic between the queues together.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5aa2eddc_1e7f0215",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 295,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-06-18T03:09:33Z",
      "side": 1,
      "message": "What\u0027s difference between d3d11 un-monitored fence and monitored fence? I dug around the internet for a while, but failed to find any useful doc to understand it. My guess is that the value of a un-monitored fence can only be 0 or 1, right?",
      "parentUuid": "69baf48a_5b0aae36",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26b9d02e_31a148fd",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 295,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-18T04:38:24Z",
      "side": 1,
      "message": "Unmonitored fences can\u0027t be observed on the CPU. You can\u0027t do things like GetCompletedValue / SetEventOnCompletion. They are only useful for GPU-GPU sync",
      "parentUuid": "5aa2eddc_1e7f0215",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7ba177c_6565c9d8",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-18T04:38:24Z",
      "side": 1,
      "message": "WebGPU needs to guarantee to make forward progress. Using the DONOTFLUSH flag makes it so that forward progress may never occur.\n\nSo overall, I don\u0027t think we can use this flag in the general case. Not using it causes a flush - which I suspect will make the code path have the same overhead as using a fence.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c0701a5_f490e0dd",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 336,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-17T13:49:53Z",
      "side": 1,
      "message": "nit: slight preference to have the command serial pushed along the query on the std::dequeue, to avoid replicating the increment logic (which could change) in this function. See for example how this is done in the Vulkan backend.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71807714_c6b7bc33",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 355,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-17T13:49:53Z",
      "side": 1,
      "message": "In most cases we shouldn\u0027t ignore errors. But why do we need to busy-wait here? This method could be used fairly often through `WaitAny` so it\u0027d be best to not busy-wait.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}