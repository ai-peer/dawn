{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "10610023_73cf0a5f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-06-17T11:02:17Z",
      "side": 1,
      "message": "This mostly re-uses the code lines in Peng\u0027s previous attempting [CL](https://dawn-review.googlesource.com/c/dawn/+/180322). Instead of totally replacing Fence with Query, this only uses Query for completion serial pumping, and still keeps Fence for shared resource synchronization. Therefore the complexity is largely reduced, meantime Fence signaling can still be significantly avoided.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56ff5915_3c412a7c",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 288,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-17T13:49:53Z",
      "side": 1,
      "message": "Note: `isMonitored` here is leaking implementation details to be implemented in `Queue`. Could we either create the fence in the child classes constructors and set them on the parent, or pass the fence flags into the constructor? (in a follow-up).",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "69baf48a_5b0aae36",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 295,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-17T13:49:53Z",
      "side": 1,
      "message": "Would this way of doing completion tracking also work on the UnmonitoredQueue? Is that\u0027s the case then we could merge much of the logic between the queues together.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5aa2eddc_1e7f0215",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 295,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-06-18T03:09:33Z",
      "side": 1,
      "message": "What\u0027s difference between d3d11 un-monitored fence and monitored fence? I dug around the internet for a while, but failed to find any useful doc to understand it. My guess is that the value of a un-monitored fence can only be 0 or 1, right?",
      "parentUuid": "69baf48a_5b0aae36",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26b9d02e_31a148fd",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 295,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-18T04:38:24Z",
      "side": 1,
      "message": "Unmonitored fences can\u0027t be observed on the CPU. You can\u0027t do things like GetCompletedValue / SetEventOnCompletion. They are only useful for GPU-GPU sync",
      "parentUuid": "5aa2eddc_1e7f0215",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94dbf52c_3d090f78",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 295,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-06-18T06:03:15Z",
      "side": 1,
      "message": "Got it, thanks!",
      "parentUuid": "26b9d02e_31a148fd",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7ba177c_6565c9d8",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-18T04:38:24Z",
      "side": 1,
      "message": "WebGPU needs to guarantee to make forward progress. Using the DONOTFLUSH flag makes it so that forward progress may never occur.\n\nSo overall, I don\u0027t think we can use this flag in the general case. Not using it causes a flush - which I suspect will make the code path have the same overhead as using a fence.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79a76016_a170db70",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-06-18T06:03:15Z",
      "side": 1,
      "message": "Theoretically it could happen. In fact we don\u0027t need to worry about that too much. As far as I can see in the driver, there are a few cases where the driver implicitly flushes the command buffer:\n1) the current command buffer is full.\n2) RTV is changed.\n3) Swapchain present method is called.\nIn the worst situation, even all these methods don\u0027t work, we can have a timeout to force a flush when there is any pending work, however it has been too long since last completion progress.",
      "parentUuid": "c7ba177c_6565c9d8",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03d08f28_815c4dac",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-18T10:02:35Z",
      "side": 1,
      "message": "From what I\u0027m reading, we\u0027re yet again trying to work around Graphite doing too many flushes by not acting on all the flushes it asks for. Can we fix Graphite to not do 1000 flushes instead? We have had like 3 different approach in Dawn that all have their problems because they don\u0027t flush when request. Let\u0027s fix Graphite instead unless there\u0027s another bigger problem there?",
      "parentUuid": "79a76016_a170db70",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "615a4bc1_ba3667bc",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 327,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-06-19T00:46:28Z",
      "side": 1,
      "message": "Makes sense. Let\u0027s try to it in Graphite. Thanks anyway.",
      "parentUuid": "03d08f28_815c4dac",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c0701a5_f490e0dd",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 336,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-17T13:49:53Z",
      "side": 1,
      "message": "nit: slight preference to have the command serial pushed along the query on the std::dequeue, to avoid replicating the increment logic (which could change) in this function. See for example how this is done in the Vulkan backend.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71807714_c6b7bc33",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 355,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-17T13:49:53Z",
      "side": 1,
      "message": "In most cases we shouldn\u0027t ignore errors. But why do we need to busy-wait here? This method could be used fairly often through `WaitAny` so it\u0027d be best to not busy-wait.",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0529e492_2cb17fdf",
        "filename": "src/dawn/native/d3d11/QueueD3D11.cpp",
        "patchSetId": 3
      },
      "lineNbr": 355,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-06-18T07:52:01Z",
      "side": 1,
      "message": "The method is majorly used to implement the synchronous [\u0027ExecutionQueue::WaitForQueueSerial(...)\u0027](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/ExecutionQueue.h;drc\u003d90cac1911508d3d682a67c97aa62483eb712f69a;l\u003d82). Normally we are not encouraged to use such synchronous style function. In fact, the frequency of calling this function is just once for each renderer process as I can catch in chromium/graphite.\n```\n \tdawn_native.dll!dawn::native::d3d11::MonitoredQueue::SetEventOnCompletion(dawn::detail::TypedIntegerImpl\u003cdawn::native::QueueSerialT,unsigned long long\u003e serial, void * event) Line 359\tC++\n\u003e\tdawn_native.dll!dawn::native::d3d::Queue::WaitForQueueSerial(dawn::detail::TypedIntegerImpl\u003cdawn::native::QueueSerialT,unsigned long long\u003e serial, dawn::detail::TypedIntegerImpl\u003cdawn::native::NanosecondsT,unsigned long long\u003e timeout) Line 89\tC++\n \tdawn_native.dll!dawn::native::`anonymous namespace\u0027::WaitQueueSerialsImpl::\u003clambda_11\u003e::operator()() Line 175\tC++\n \tdawn_native.dll!dawn::native::`anonymous namespace\u0027::WaitQueueSerialsImpl(dawn::native::DeviceBase * device, dawn::native::QueueBase * queue, dawn::detail::TypedIntegerImpl\u003cdawn::native::QueueSerialT,unsigned long long\u003e waitSerial, std::__Cr::__wrap_iter\u003cdawn::native::(anonymous namespace)::TrackedFutureWaitInfo *\u003e begin, std::__Cr::__wrap_iter\u003cdawn::native::(anonymous namespace)::TrackedFutureWaitInfo *\u003e end, dawn::detail::TypedIntegerImpl\u003cdawn::native::NanosecondsT,unsigned long long\u003e timeout) Line 160\tC++\n \tdawn_native.dll!dawn::native::`anonymous namespace\u0027::WaitImpl(std::__Cr::vector\u003cdawn::native::(anonymous namespace)::TrackedFutureWaitInfo,std::__Cr::allocator\u003cdawn::native::(anonymous namespace)::TrackedFutureWaitInfo\u003e\u003e \u0026 futures, dawn::detail::TypedIntegerImpl\u003cdawn::native::NanosecondsT,unsigned long long\u003e timeout) Line 258\tC++\n \tdawn_native.dll!dawn::native::EventManager::WaitAny(unsigned __int64 count, dawn::native::FutureWaitInfo * infos, dawn::detail::TypedIntegerImpl\u003cdawn::native::NanosecondsT,unsigned long long\u003e timeout) Line 539\tC++\n \tdawn_native.dll!dawn::native::InstanceBase::APIWaitAny(unsigned __int64 count, dawn::native::FutureWaitInfo * futures, unsigned __int64 timeoutNS) Line 567\tC++\n \tdawn_native.dll!dawn::native::NativeInstanceWaitAny(WGPUInstanceImpl * cSelf, unsigned __int64 futureCount, WGPUFutureWaitInfo * futures, unsigned __int64 timeoutNS) Line 1360\tC++\n \tdawn_proc.dll!wgpuInstanceWaitAny(WGPUInstanceImpl * instance, unsigned __int64 futureCount, WGPUFutureWaitInfo * futures, unsigned __int64 timeoutNS) Line 614\tC++\n \tskia.dll!wgpu::Instance::WaitAny(unsigned __int64 futureCount, wgpu::FutureWaitInfo * futures, unsigned __int64 timeoutNS) Line 7986\tC++\n \tskia.dll!skgpu::graphite::`anonymous namespace\u0027::DawnWorkSubmissionWithFuture::onWaitUntilFinished(const skgpu::graphite::SharedContext * sharedContext) Line 103\tC++\n \tskia.dll!skgpu::graphite::GpuWorkSubmission::waitUntilFinished(const skgpu::graphite::SharedContext * sharedContext) Line 46\tC++\n \tskia.dll!skgpu::graphite::QueueManager::checkForFinishedWork(skgpu::graphite::SyncToCpu sync) Line 253\tC++\n \tskia.dll!skgpu::graphite::Context::checkForFinishedWork(skgpu::graphite::SyncToCpu syncToCpu) Line 742\tC++\n \tskia.dll!skgpu::graphite::Context::submit(skgpu::graphite::SyncToCpu syncToCpu) Line 172\tC++\n \tgpu_gles2.dll!gpu::SharedContextState::FlushAndSubmit(bool sync_to_cpu) Line 754\tC++\n \tgpu_gles2.dll!gpu::raster::RasterDecoderImpl::DoFinish() Line 1817\tC++\n \tgpu_gles2.dll!gpu::raster::RasterDecoderImpl::HandleFinish(unsigned int immediate_data_size, const volatile void * cmd_data) Line 18\tC++\n \tgpu_gles2.dll!gpu::raster::RasterDecoderImpl::DoCommandsImpl\u003c0\u003e(unsigned int num_commands, const volatile void * buffer, int num_entries, int * entries_processed) Line 1510\tC++\n \tgpu_gles2.dll!gpu::raster::RasterDecoderImpl::DoCommands(unsigned int num_commands, const volatile void * buffer, int num_entries, int * entries_processed) Line 1571\tC++\n \tgpu.dll!gpu::CommandBufferService::Flush(int put_offset, gpu::AsyncAPIInterface * handler) Line 231\tC++\n \tgpu_ipc_service.dll!gpu::CommandBufferStub::OnAsyncFlush(int put_offset, unsigned int flush_id, const std::__Cr::vector\u003cgpu::SyncToken,std::__Cr::allocator\u003cgpu::SyncToken\u003e\u003e \u0026 sync_token_fences) Line 507\tC++\n\n```\nAnother simpler way with no busy-wait is to force a Flush1 event here like [this](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d11/QueueD3D11.cpp;drc\u003d9da3eaf710d7c5ae6c81f2a6af42b078ecab3b40;l\u003d350). However that could causes that we don\u0027t wait precisely at the desired serial.",
      "parentUuid": "71807714_c6b7bc33",
      "revId": "c0d55fb6f8189c3111766483f9629a431269d03e",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}