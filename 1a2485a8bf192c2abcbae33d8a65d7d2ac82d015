{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ac30859f_8db0005c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-08-04T17:24:51Z",
      "side": 1,
      "message": "a thought occurred to me - why do we need to implement this in Dawn?\n\nwould it be sufficient to implement it in Chromium\u0027s shared image system?\nChrome can do the readback/upload manually into a wgpu::Texture",
      "revId": "1a2485a8bf192c2abcbae33d8a65d7d2ac82d015",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6590c823_4f024af1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-08-06T19:32:47Z",
      "side": 1,
      "message": "That is another approach. That would work too. But I think implementing in Dawn has some points:\n- Dawn can know that the texture is not initialized or discarded when exporting/ending access thus can skip the readback. Whereas if we implement in chrome, I don\u0027t know there is any way to know that and the readback/upload will always happen.\n- ANGLE can import IOSurface to swiftshader backend and chrome doesn\u0027t need to do anything special in its shared image system. So it would make sense to do the same for Dawn.\n- We can make use of Dawn\u0027s external image\u0027s unit tests.\n\nWDYT?",
      "parentUuid": "ac30859f_8db0005c",
      "revId": "1a2485a8bf192c2abcbae33d8a65d7d2ac82d015",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6d890322_5bdd5590",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-08-07T16:31:59Z",
      "side": 1,
      "message": "here are my thoughts - open to discussion!\n\n- For skipping the readback based on initialization state, agree this is better for performance. But - I understand that SwiftShader integration now is intended to be for testing purposes, and doesn\u0027t necessarily need to be very fast. Maybe I\u0027m wrong about this and we\u0027re actually going to ship Chrome software fallback on Graphite-Dawn-Swiftshader?\n- While we definitely could support import like this - it feels deceptive. It\u0027s not a real import and has far different performance characteristics. So, it might be a better layering to put the readback/upload outside of Dawn. We\u0027re working on unifying the import/export APIs and as we do so, I think it would be better if the API had a consistent meaning across backends. If not, applications will be incentived to use a different code path when running on SwiftShader. And if they\u0027re doing that - it seems better that they also manage the readback/upload.\n- IMO Chromium should also have good testing of this too",
      "parentUuid": "6590c823_4f024af1",
      "revId": "1a2485a8bf192c2abcbae33d8a65d7d2ac82d015",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6918e84f_9488ac4a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-08-08T11:27:19Z",
      "side": 1,
      "message": "\u003e For skipping the readback based on initialization state, agree this is better for performance. But - I understand that SwiftShader integration now is intended to be for testing purposes, and doesn\u0027t necessarily need to be very fast. Maybe I\u0027m wrong about this and we\u0027re actually going to ship Chrome software fallback on Graphite-Dawn-Swiftshader?\n\n- Unfortunately, some chrome\u0027s unit tests rely on `isInitialized` flag to know whether the shared image is cleared by Dawn or not (e.g. IOSurfaceImageBackingFactoryTest.UnclearDawn_SkiaFails [1]). By implementing the upload/readback in chrome, we don\u0027t know that and will always assume that the images are filled/cleared by Dawn.\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/iosurface_image_backing_factory_unittest.cc;drc\u003db537cbde0c7c42da2ee730b286bfb1cc7735eb1a;l\u003d458\n\nWe could skip these tests if swiftshader is used. But not sure it\u0027s the best way to do. Or there could be other places in Chrome which rely on knowing exactly whether the images are initialized by Dawn or not.\n\nCC @sunnyps@chromium.org any insights?",
      "parentUuid": "6d890322_5bdd5590",
      "revId": "1a2485a8bf192c2abcbae33d8a65d7d2ac82d015",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d6a1d938_94468349",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-08-08T11:45:07Z",
      "side": 1,
      "message": "I think chrome wants to know that dawn didn\u0027t initialize or discarded the image. So that it avoid using/importing it to another system .e.g. skia.",
      "parentUuid": "6918e84f_9488ac4a",
      "revId": "1a2485a8bf192c2abcbae33d8a65d7d2ac82d015",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "281ae71d_ec4a41fd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-08-08T15:52:19Z",
      "side": 1,
      "message": "nvm, looks like we can use this function in chrome to determine whether the texture is initialized https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/include/dawn/native/DawnNative.h;drc\u003db537cbde0c7c42da2ee730b286bfb1cc7735eb1a;l\u003d231",
      "parentUuid": "d6a1d938_94468349",
      "revId": "1a2485a8bf192c2abcbae33d8a65d7d2ac82d015",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one maximum vote for label \u0027Code-Review\u0027 is required"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "1a2485a8bf192c2abcbae33d8a65d7d2ac82d015",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "1a2485a8bf192c2abcbae33d8a65d7d2ac82d015",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}