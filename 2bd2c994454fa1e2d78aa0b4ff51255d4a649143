{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b21dba2e_7988d55a",
        "filename": "src/dawn/native/vulkan/BufferVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 220,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-16T07:01:51Z",
      "side": 1,
      "message": "Looks unnecessary to delay submit for testing only code.",
      "range": {
        "startLine": 220,
        "startChar": 55,
        "endLine": 220,
        "endChar": 59
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "014191f2_0ac47be0",
        "filename": "src/dawn/native/vulkan/BufferVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 220,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T15:54:46Z",
      "side": 1,
      "message": "This is the ensure before the buffer is first used, it is initialized to non-zero. It should be OK to defer since we only need it to happen at the start of the next usage.",
      "parentUuid": "b21dba2e_7988d55a",
      "range": {
        "startLine": 220,
        "startChar": 55,
        "endLine": 220,
        "endChar": 59
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ed9585c_ab78310d",
        "filename": "src/dawn/native/vulkan/BufferVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 230,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-16T07:01:51Z",
      "side": 1,
      "message": "Not sure about this.",
      "range": {
        "startLine": 230,
        "startChar": 91,
        "endLine": 230,
        "endChar": 95
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3bf72f9_77ba9571",
        "filename": "src/dawn/native/vulkan/BufferVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 230,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T15:54:46Z",
      "side": 1,
      "message": "This is the ensure before the buffer is first used, it is initialized to zero. It should be OK to defer since we only need it to happen at the start of the next usage.",
      "parentUuid": "2ed9585c_ab78310d",
      "range": {
        "startLine": 230,
        "startChar": 91,
        "endLine": 230,
        "endChar": 95
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0487bc1a_7cff0eaa",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-16T07:01:51Z",
      "side": 1,
      "message": "\u0027false\u0027 here can lead to the CQ [fail](https://ci.chromium.org/ui/p/dawn/builders/try/linux-clang-dbg-x64/b8805711684613257553/overview). There might be something unexpected in the implementation exposed. Let me know if it\u0027s worth digging deeper into that.",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb6b9214_78105bf3",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-17T06:47:03Z",
      "side": 1,
      "message": "After digging around for quite a while, it turned out me a very subtle bug relating `AssumeCommandsComplete` [here](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/Device.cpp;drc\u003dfd3d5ceda5d7987a7c8fb21e24ab52b1799ca8af;l\u003d1270):\n```\nMaybeError DeviceBase::Tick() {\n    DAWN_TRY(ValidateIsAlive());\n\n    // to avoid overly ticking, we only want to tick when:\n    // 1. the last submitted serial has moved beyond the completed serial\n    // 2. or the completed serial has not reached the future serial set by the trackers\n    if (mLastSubmittedSerial \u003e mCompletedSerial || mCompletedSerial \u003c mFutureSerial) {\n        DAWN_TRY(CheckPassedSerials());\n        DAWN_TRY(TickImpl());\n\n        // There is no GPU work in flight, we need to move the serials forward so that\n        // so that CPU operations waiting on GPU completion can know they don\u0027t have to wait.\n        // AssumeCommandsComplete will assign the max serial we must tick to in order to\n        // fire the awaiting callbacks.\n        if (mCompletedSerial \u003d\u003d mLastSubmittedSerial) {\n            AssumeCommandsComplete();\n        }\n\n        // TODO(crbug.com/dawn/833): decouple TickImpl from updating the serial so that we can\n        // tick the dynamic uploader before the backend resource allocators. This would allow\n        // reclaiming resources one tick earlier.\n        mDynamicUploader-\u003eDeallocate(mCompletedSerial);\n        mQueue-\u003eTick(mCompletedSerial);\n    }\n```\n\nAs my debug log below shows,\n```\n[ RUN      ] QueueWriteBufferTests.UnalignedDynamicUploader/Vulkan_SwiftShader_Device_Subzero\nAddFutureSerial -- serial:1\nGetPendingRecordingContext:0\ncmd CopyBufferToImage\ncopyBufferToTexture: src:6070000a3408 dst:611000008748\ncmdbuf:6070000a5240\nTexture::DestroyImpl:611000008748\nAddFutureSerial -- serial:1\ncopyFromStagingBuffer:0\nGetPendingRecordingContext:0\ncmd CopyBufferToBuffer\ncopyBufferToBuffer: src:6070000a3408 dst:6070000a4f98\ncmdbuf:6070000a5240\nAddFutureSerial -- serial:1\ncopyFromStagingBuffer:0\nGetPendingRecordingContext:0\ncmd CopyBufferToBuffer\ncopyBufferToBuffer: src:6070000a3408 dst:6070000a5158\ncmdbuf:6070000a5240\nTickImpl -- completedSerial:0\nAssumeCommandsComplete -- mFutureSerial:1\nAssumeCommandsComplete -- mLastSubmittedSerial:0\nGetPendingRecordingContext:1\ncopyBufferToBuffer: src:6070000a4f98 dst:6070000a5158\ncmdbuf:6070000a5240\nSubmitPendingCommands\nqueue submit\nsubmit done -- lastSubmittedSerial:2\nMapAsync\nGetPendingRecordingContext:0\nAddFutureSerial -- serial:3\nOnTrackTask\nTickImpl -- completedSerial:1\nDestroyTexture 611000008748\nSubmitPendingCommands\nqueue submit\nsubmit done -- lastSubmittedSerial:3\n```\n`AssumeCommandsComplete` advances `mCompletedSerial`, which in turn causes `FencedDeleter` to destory the texture, that is still in use.\n\nPer [vkspec](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#VUID-vkDestroyImage-image-01000):\n```\nAll submitted commands that refer to image, either directly or via a VkImageView, must have completed execution\n```\nWithout the signaled fence, we can\u0027t accurately tell if the execution is completed. \nSo we probably can\u0027t just assume anything to safely advance `mCompletedSerial`. No idea yet to fix this, any insights?",
      "parentUuid": "0487bc1a_7cff0eaa",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f42b8ab8_117c8dbb",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-18T06:15:47Z",
      "side": 1,
      "message": "The attempting fix of PS11 seemingly worked.",
      "parentUuid": "eb6b9214_78105bf3",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f4478f3_3fda8579",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T15:54:46Z",
      "side": 1,
      "message": "ugh... the serials, and particularly mFutureSerial, are hard to understand and we would like to make it better (see crbug.com/dawn/1413)\n\nIt seems bad that we advance mCompletedSerial up to mFutureSerial when there are still incomplete commands. I have a suggestion to fix this problem by removing mFutureSerial entirely. I feel like mFutureSerial is a bit of a hack.\n\nYour solution will look like it will work, but I\u0027m afraid about other places and that this is a bigger problem than just mDeleter. What about  mResourceMemoryAllocator-\u003eTick and  mDescriptorAllocatorsPendingDeallocation.ClearUpTo and DescriptorSetAllocator-\u003eFinishDeallocation?\n\nI went and looked through history to see why we AddFutureSerial in WriteBuffer and WriteTexture. It came from here\nhttps://dawn-review.googlesource.com/c/dawn/+/29980/comments/21fe028a_5859e7ff\n\nWe AddFutureSerial so that Tick() knows there is a pending write operations that need to get flushed and we don\u0027t increase memory forever. This CL fixes that though! \n a) I think, we can remove AddFutureSerial from WriteBuffer and WriteTexture if inside DeviceBase::Tick() we add another condition which will make sure the uploads are submitted. That way, if there are many pending WriteBuffers, calling Tick repeatedly will eventually cause them to all get flushed.\n\n b) The one more remaining usage of AddFutureSerial is in QueueBase::TrackTask. This is because operations like OnSubmittedWorkDone and MapAsync are scheduled to resolved their callbacks using the pending command serial. Calling Tick() needs to eventually make them fire, so we tracked that there is a future submit that needs to happen using mFutureSerial. However, now we have ForceEventualFlushOfCommands. I think we could also remove AddFutureSerial from TrackTask, and instead, add another condition in Device::Tick() like CheckCommandsNeedFlush().\n\nall in all, Device::Tick would look something like\n(may also need to tag the recording context as needsSubmit)\n```\n\nif (mLastSubmittedSerial \u003e mCompletedSerial || CheckCommandsNeedFlush()) {\n  ...\n  mForceNextTick \u003d false;\n  DAWN_TRY(TickImpl());\n  ...\n}\n```\n```\n\nvirtual void DeviceBase::ForceEventualFlushOfCommands() {\n  mForceNextTick \u003d true;\n}\n\nvirtual bool DeviceBase::CheckCommandsNeedFlush() {\n  return mForceNextTick || GetDynamicUploader()-\u003eShouldFlush();\n}\n\nvirtual bool DeviceVk::ForceEventualFlushOfCommands() {\n  DeviceBase::ForceEventualFlushOfCommands();\n  mRecordingContext.needsSubmit |\u003d mRecordingContext.used;\n}\n\nbool DeviceVk::CheckCommandsNeedFlush() override {\n  return mRecordingContext.needsSubmit || DeviceBase::CheckCommandsNeedFlush();\n}\n```\nfinally, with no more AddFutureSerial, we can remove it from AssumeCommandsComplete.\n```\nvoid DeviceBase::AssumeCommandsComplete() {\n    // bump serials so any pending callbacks can fire. \n    mLastSubmittedSerial++;\n    mCompletedSerial \u003d mLastSubmittedSerial;\n}\n```\n\nI only thought about Vulkan here; we we also likely need a similar thing for other backends.\n\nWhat do you think? Please feel free to simplify this idea or offer other suggestions as well.",
      "parentUuid": "f42b8ab8_117c8dbb",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f0c7741_5d41d920",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-19T05:51:09Z",
      "side": 1,
      "message": "Sounds like a good idea. Let me have a try.\nBut what still concerns me most is the `AssumeCommandsComplete` [here](https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/Device.cpp;drc\u003d5e879c6f6b61fd2768cbf2453515e371fdb00811;l\u003d1270):\n```\n        // There is no GPU work in flight, we need to move the serials forward so that\n        // so that CPU operations waiting on GPU completion can know they don\u0027t have to wait.\n        // AssumeCommandsComplete will assign the max serial we must tick to in order to\n        // fire the awaiting callbacks.\n        if (mCompletedSerial \u003d\u003d mLastSubmittedSerial) {\n            AssumeCommandsComplete();\n        }\n```\nMy understanding is that we should only do `AssumeCommandsComplete` in abnormal cases like device lost, etc. We should by no means do that in a normal tick, which can cause wrong resource release. I don\u0027t quite understand its comment. Can you help me understand what CPU operation callbacks it intends to trigger? It seems to me that we have to find a way to remove it here.",
      "parentUuid": "6f4478f3_3fda8579",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a1c84f1_9d361b3c",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-19T14:39:02Z",
      "side": 1,
      "message": "The CPU operations are enqueued callbacks for onSubmittedWorkDone and mapAsync.\n\nConsider for example if there is absolutely 0 work in flight.\nmLastSubmittedSerial \u003d\u003d 2 \u0026\u0026 mCompletedSerial \u003d\u003d 2\n\nYou enqueue some callbacks like\n```\nqueue.onSubmittedWorkDone(cb1);\nbuffer.mapAsync(cb2);\n```\n\nThese callbacks are enqueued using the \"pending command serial\" which will be 3.\n\nIf you do:\n```\nwhile (NotCalled(cb1)) {\n  device.Tick();\n  sleep(10);\n}\n```\n\nYou will loop forever since we never get to serial 3 since nothing gets submitted to the queue.\nThe goal of AssumeCommandsComplete here is to make it so that the serial continues to increase if there are pending callbacks but no GPU work.\n\nHowever, I think we may be able to remedy this as well. If at the time the callbacks are enqueued (QueueBase::TrackTask), after we call ForceEventualFlushOfCommands()..  if the recording context does not `needsSubmit`, that means the callbacks are waiting on nothing. We may be able to enqueue them immediately in DeviceBase::mCallbackTaskManager instead of having them wait on a future serial.",
      "parentUuid": "7f0c7741_5d41d920",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "019cabe8_0a30658a",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-24T01:18:24Z",
      "side": 1,
      "message": "Got it, thanks for the clarification.\nLuckily I\u0027ve got a simple fix. We can make a dummy submit to advance in tick rather than `AssumeCommandsComplete`. As a result we could ensure the correctness and avoid bothering with different backends.",
      "parentUuid": "0a1c84f1_9d361b3c",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef05c951_f58a36cd",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-08-25T13:51:30Z",
      "side": 1,
      "message": "Agreed that the FutureSerial is a hack, but DummySubmit is also forcing GPU work when none needs to happen. I added some thoughts on https://bugs.chromium.org/p/dawn/issues/detail?id\u003d1413 but in all cases, changing the way serials work is extremely risky because it is very subtle and should be split in its own CL.",
      "parentUuid": "019cabe8_0a30658a",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0846a438_fe059ddd",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-26T01:59:11Z",
      "side": 1,
      "message": "Insightful thoughts. Let\u0027s split and have a separate CL to address them.\nTo clarify a little bit for DummySubmit, in very rare case we actually force an empty submit. As Austin\u0027s case explained, we only do that in case we don\u0027t have any work for GPU to do. So I am not seeing any significant perf impact potentially. Please correct me if I missed anything. Let me know if you have something else better in your mind.",
      "parentUuid": "ef05c951_f58a36cd",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58565f1e_19c2fd6a",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-26T15:37:21Z",
      "side": 1,
      "message": "Thanks for the additional thoughts here - I\u0027m still thinking about this and trying to see how we can make progress on this CL without needing to overhaul all the serial stuff (yet).\n\nStill hacking around with it but I think what I\u0027m trying to target is to narrow down mFutureSerial so it is less \"future\". It should always refer to either actually submitted or actually pending commands. So it\u0027s past or near-future. There should never be a case where we a callback is waiting on a pending serial that doesn\u0027t refer to any actual pending commands. I think this will remove the need for the artificial serial progression, and then this CL will be unblocked.",
      "parentUuid": "0846a438_fe059ddd",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9427e4af_ff91ce53",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-26T22:23:43Z",
      "side": 1,
      "message": "ugh nevermind - that idea won\u0027t work so easily. mFutureSerial is a frontend concept, and we can\u0027t simply narrow it to be less futuristic since the frontend only knows about frontend work. MapAsync still needs to wait on backend operations like buffer zero-initialization so we can\u0027t do it purely based on frontend knowledge. here was my attempt if you\u0027re curious\nhttps://dawn-review.googlesource.com/c/dawn/+/100481\n\nwe can discuss more on crbug.com/dawn/1413 about what to do.\n\nMy concern with DummySubmit is also that it\u0027s highly re-entrant. That\u0027s risky because is likely not expecting to be called re-entrantly. Some of the backend implementations of Submit call Tick which will then call Submit again... :-/",
      "parentUuid": "58565f1e_19c2fd6a",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22f7ddd9_7dd94457",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-09-25T11:35:50Z",
      "side": 1,
      "message": "@Corentin @Austin\nI am not quite clear about the ideas you mentioned in crbug.com/dawn/1413. As Corentin now is back from his trip. Hopefully you may have time to help me understand them piece by piece with regards to this CL. I\u0027ve removed the DummySubmit() and added HasPendingCommands() for Vulkan backend firstly since your last review. Could you indicate me what\u0027re still missing in your view?",
      "parentUuid": "9427e4af_ff91ce53",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd50eb63_f27bdf41",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-09-28T15:58:45Z",
      "side": 1,
      "message": "I think this is a good incremental step forward to remove mFutureSerial. Do you think we could split it out from the Vulkan backend changes?",
      "parentUuid": "22f7ddd9_7dd94457",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9841b35a_429ec83b",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-09-29T06:20:26Z",
      "side": 1,
      "message": "Current CL is incomplete and only handles Vulkan backend. I just want to quickly make sure the basic idea is what you and @cwallez@chromium.org want, as discussed in the [issue](https://bugs.chromium.org/p/dawn/issues/detail?id\u003d1413). If I\u0027m in the right direction now, I will continue working on other backends, gradually figuring out other refactoring like moving CommandRecordingContext to frontend, etc.",
      "parentUuid": "cd50eb63_f27bdf41",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0346f041_ec1aa048",
        "filename": "src/dawn/native/vulkan/DeviceVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 811,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-10-19T13:17:55Z",
      "side": 1,
      "message": "resolving this thread",
      "parentUuid": "9841b35a_429ec83b",
      "range": {
        "startLine": 811,
        "startChar": 75,
        "endLine": 811,
        "endChar": 79
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d1f24ba_b0ec7120",
        "filename": "src/dawn/native/vulkan/NativeSwapChainImplVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 191,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-16T07:01:51Z",
      "side": 1,
      "message": "Totally unfamiliar with this.",
      "range": {
        "startLine": 191,
        "startChar": 40,
        "endLine": 191,
        "endChar": 44
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c962e2f_f74d605e",
        "filename": "src/dawn/native/vulkan/NativeSwapChainImplVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 191,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T15:54:46Z",
      "side": 1,
      "message": "the semaphore is signaled by vkAcquireNextImageKHR. We should enqueue it to be waited on before the next usage of nextTexture. Changing to `false` looks ok to me",
      "parentUuid": "0d1f24ba_b0ec7120",
      "range": {
        "startLine": 191,
        "startChar": 40,
        "endLine": 191,
        "endChar": 44
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b55132a2_e52b3a42",
        "filename": "src/dawn/native/vulkan/SwapChainVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 76,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-16T07:01:51Z",
      "side": 1,
      "message": "Not sure.",
      "range": {
        "startLine": 76,
        "startChar": 83,
        "endLine": 76,
        "endChar": 87
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d1d2af5_a76a74ba",
        "filename": "src/dawn/native/vulkan/SwapChainVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 76,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T15:54:46Z",
      "side": 1,
      "message": "I think this one should be true because we need to be the transition to presentation usage actually happens before vkQueuePresent",
      "parentUuid": "b55132a2_e52b3a42",
      "range": {
        "startLine": 76,
        "startChar": 83,
        "endLine": 76,
        "endChar": 87
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47a976fe_9642bf94",
        "filename": "src/dawn/native/vulkan/SwapChainVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 530,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-16T07:01:51Z",
      "side": 1,
      "message": "Not sure.",
      "range": {
        "startLine": 530,
        "startChar": 83,
        "endLine": 530,
        "endChar": 87
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76b72c01_a403e4d9",
        "filename": "src/dawn/native/vulkan/SwapChainVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 530,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T15:54:46Z",
      "side": 1,
      "message": "I think it should be true because we need to be the transition to presentation usage actually happens before vkQueuePresent",
      "parentUuid": "47a976fe_9642bf94",
      "range": {
        "startLine": 530,
        "startChar": 83,
        "endLine": 530,
        "endChar": 87
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "480a51d6_5784433d",
        "filename": "src/dawn/native/vulkan/SwapChainVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 641,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-16T07:01:51Z",
      "side": 1,
      "message": "Not sure",
      "range": {
        "startLine": 641,
        "startChar": 43,
        "endLine": 641,
        "endChar": 47
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "42f65b25_710bc6d7",
        "filename": "src/dawn/native/vulkan/SwapChainVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 641,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T15:54:46Z",
      "side": 1,
      "message": "the semaphore is signaled by vkAcquireNextImageKHR. We should enqueue it to be waited on before the next usage of nextTexture. Changing to `false` looks ok to me",
      "parentUuid": "480a51d6_5784433d",
      "range": {
        "startLine": 641,
        "startChar": 43,
        "endLine": 641,
        "endChar": 47
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "adde6ce6_edaaa3f5",
        "filename": "src/dawn/native/vulkan/TextureVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 708,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2022-08-16T07:01:51Z",
      "side": 1,
      "message": "Seems testing only.",
      "range": {
        "startLine": 708,
        "startChar": 81,
        "endLine": 708,
        "endChar": 85
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4dc3e59f_dbf8dcd1",
        "filename": "src/dawn/native/vulkan/TextureVk.cpp",
        "patchSetId": 10
      },
      "lineNbr": 708,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-18T15:54:46Z",
      "side": 1,
      "message": "This is the ensure before the texture is first used, it is initialized to non-zero. It should be OK to defer since we only need it to happen at the start of the next usage.",
      "parentUuid": "adde6ce6_edaaa3f5",
      "range": {
        "startLine": 708,
        "startChar": 81,
        "endLine": 708,
        "endChar": 85
      },
      "revId": "2bd2c994454fa1e2d78aa0b4ff51255d4a649143",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}