{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5671b598_dd1f2634",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "What is the plan for separating the old extension and the new extension? Is the new extension currently only exposed when both the old AND new extensions are supported?",
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31fdb448_27d5e375",
        "filename": "src/dawn/native/CommandEncoder.cpp",
        "patchSetId": 3
      },
      "lineNbr": 761,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "it\u0027s oddly redundant that the end timestamp is in both the `timestampWrites` vector as well as the EndComputePassCmd.\n\nWhat if instead we got rid of the vector and simply had two members `beginTimestamp` and `endTimestamp` on BeginComputePassCmd? We don\u0027t need it on EndComputePassCmd\n\nFor render passes, all of the backends already pass `BeginRenderPassCmd` into `RecordRenderPass`. We could do the same for compute passes so that we\u0027re able to get the end timestamp for backends that record it at the end of the pass.",
      "range": {
        "startLine": 758,
        "startChar": 15,
        "endLine": 761,
        "endChar": 0
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96a87264_934e153c",
        "filename": "src/dawn/native/CommandEncoder.cpp",
        "patchSetId": 3
      },
      "lineNbr": 761,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2022-06-28T09:28:49Z",
      "side": 1,
      "message": "I\u0027ve also considered adding the timestamps of the beginning and end separately in `BeginXxxPassCmd`, this is easier for implementation. But I think it is strange to use a parameter with end keyword in begin cmds. If the `endTimestamp` is acceptable, I\u0027d be happy to make changes.",
      "parentUuid": "31fdb448_27d5e375",
      "range": {
        "startLine": 758,
        "startChar": 15,
        "endLine": 761,
        "endChar": 0
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb0d4847_473fffa2",
        "filename": "src/dawn/native/CommandEncoder.cpp",
        "patchSetId": 3
      },
      "lineNbr": 761,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-28T17:22:56Z",
      "side": 1,
      "message": "I think it would be ok - you\u0027re beginning a render pass yes, but it matches the Metal API where the begin/end timestamps are specified both at the start of the pass",
      "parentUuid": "96a87264_934e153c",
      "range": {
        "startLine": 758,
        "startChar": 15,
        "endLine": 761,
        "endChar": 0
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "183ef8bd_097f557f",
        "filename": "src/dawn/native/CommandEncoder.cpp",
        "patchSetId": 3
      },
      "lineNbr": 761,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2022-06-28T17:25:17Z",
      "side": 1,
      "message": "+1 to that suggestion. BeginComputePass can have \"end\" stuff because it\u0027s begin this compute pass (start stuff, end stuff)",
      "parentUuid": "96a87264_934e153c",
      "range": {
        "startLine": 758,
        "startChar": 15,
        "endLine": 761,
        "endChar": 0
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b798ed5e_17a5a320",
        "filename": "src/dawn/native/Commands.h",
        "patchSetId": 3
      },
      "lineNbr": 76,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "this struct holds a QuerySetBase* not a Ref\u003cQuerySetBase\u003e\ndo we hold the ref somewhere else? if not, we\u0027ll have a potential use-after-free",
      "range": {
        "startLine": 76,
        "startChar": 16,
        "endLine": 76,
        "endChar": 41
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a12e26d6_724a31a7",
        "filename": "src/dawn/native/metal/BackendMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 250,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "\"GPU counters are only available if sampling at least one of the command or stage boundaries is supported.\"",
      "range": {
        "startLine": 249,
        "startChar": 31,
        "endLine": 250,
        "endChar": 19
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec3eb9a5_741ee54f",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "why not Concurrent?",
      "range": {
        "startLine": 58,
        "startChar": 30,
        "endLine": 58,
        "endChar": 51
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "224c74ab_a389833e",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2022-06-28T09:28:49Z",
      "side": 1,
      "message": "On macOS version less than 11.0 ï¼ˆiOS \u003c 14.0), we only can create default compute pass by [MTLCommandBuffer computeCommandEncoder] (https://developer.apple.com/documentation/metal/mtlcommandbuffer/1443044-computecommandencoder/), and it is a sequential compute pass. The compute pass created from descriptor should be same to the default one, otherwise it\u0027s hard to decide that the commands are executed concurrently or sequentially.",
      "parentUuid": "ec3eb9a5_741ee54f",
      "range": {
        "startLine": 58,
        "startChar": 30,
        "endLine": 58,
        "endChar": 51
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40a38bbc_200fc2a6",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-28T17:22:56Z",
      "side": 1,
      "message": "I see. Is there a reason we wouldn\u0027t use Concurrent on higher mac os versions? It should allow better use of the GPU",
      "parentUuid": "224c74ab_a389833e",
      "range": {
        "startLine": 58,
        "startChar": 30,
        "endLine": 58,
        "endChar": 51
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2619b8b_55b73417",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 240,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "what if we have a vertex-only pipeline with no fragment shader?",
      "range": {
        "startLine": 239,
        "startChar": 16,
        "endLine": 240,
        "endChar": 80
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "804821ad_1657c02f",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 240,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2022-06-28T09:28:49Z",
      "side": 1,
      "message": "Good question, but I didn\u0027t found any explaination about this in Apple document. I need to try it.",
      "parentUuid": "d2619b8b_55b73417",
      "range": {
        "startLine": 239,
        "startChar": 16,
        "endLine": 240,
        "endChar": 80
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c81a9a0_24172ea8",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "why do we use 0 here and MTLCounterDontSample above?",
      "range": {
        "startLine": 244,
        "startChar": 26,
        "endLine": 244,
        "endChar": 40
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1c958b5_58c39a35",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 244,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2022-06-28T09:28:49Z",
      "side": 1,
      "message": "My mistake, should be `MTLCounterDontSample`.",
      "parentUuid": "9c81a9a0_24172ea8",
      "range": {
        "startLine": 244,
        "startChar": 26,
        "endLine": 244,
        "endChar": 40
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d8ba2d4_91361c63",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 952,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2022-06-27T10:10:03Z",
      "side": 1,
      "message": "TODO: Here need to add a simulation for WriteTimestamp using blit encoder\u0027s sampleBufferAttachments when the sampleCountersInBuffer is not supported which I missed.",
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5115d79d_072e4857",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 952,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "we should put that behind a Toggle so we can force using the path in tests",
      "parentUuid": "5d8ba2d4_91361c63",
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23522488_8ff1906a",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 1053,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:17:51Z",
      "side": 1,
      "message": "we should add a Toggle to force disable mSupportCounterSamplingAtStageBoundary so we can test the other path if both types of sampling are supported",
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8204e1cc_8b204246",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 1053,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2022-06-28T09:28:49Z",
      "side": 1,
      "message": "The counter sampling will not be supported at both stage boundary and draw/dispatch/blit boundary on same device. Apple Silicon devices do not support draw/dispatch/blit boundary, and any TBDR renderer wouldn\u0027t be able to support them , draw calls for example, all the vertex processing of all the draw calls in the render pass execute together. So I think only one of stage boundary and draw/dispatch/blit boundary is supported if the counter sampling is supported.",
      "parentUuid": "23522488_8ff1906a",
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "977bb4b0_ef2c34dd",
        "filename": "src/dawn/native/metal/CommandBufferMTL.mm",
        "patchSetId": 3
      },
      "lineNbr": 1053,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-28T17:22:56Z",
      "side": 1,
      "message": "ah, I see - perhaps making this an enum would make it more clear that exactly one of the modes is supported",
      "parentUuid": "8204e1cc_8b204246",
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2403662_7aacf754",
        "filename": "src/dawn/tests/end2end/QueryTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 551,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-06-27T22:19:36Z",
      "side": 1,
      "message": "This sounds like we should implement this workaround in the Vulkan backend instead of in the test.\n\nIt\u0027s ok to write the test the way it should work, and skip on Intel Windows Vulkan, with a bug about implementing the workaround in the future.",
      "range": {
        "startLine": 548,
        "startChar": 27,
        "endLine": 551,
        "endChar": 48
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "861b7f37_cba7f4de",
        "filename": "src/dawn/tests/end2end/QueryTests.cpp",
        "patchSetId": 3
      },
      "lineNbr": 551,
      "author": {
        "id": 1000030
      },
      "writtenOn": "2022-06-28T09:28:49Z",
      "side": 1,
      "message": "Sure. We have reported this issue to Intel driver team, and it has been fixed on latest driver 30.0.11.1994. We don\u0027t need to workaround it, I will add a skip condition for driver version to make the tests could run on the fixed driver version.",
      "parentUuid": "b2403662_7aacf754",
      "range": {
        "startLine": 548,
        "startChar": 27,
        "endLine": 551,
        "endChar": 48
      },
      "revId": "3f30c82700cf5e7fb34a00693bfcffbcdc23733a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}