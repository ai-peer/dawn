{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "fc737bd8_09f848b3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-04T20:24:38Z",
      "side": 1,
      "message": "Hi Austin, Corentin, PTAL. Thanks",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "29de324d_4678418b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T16:00:46Z",
      "side": 1,
      "message": "Corentin and Austin, kindly ping. thanks",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e2ad3cb_ed99374e",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 229,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "I think we need the read-onlyness to be part of the BeginAccessDescriptor: we need to validate the following:\n\n - The texture is marked initialized if it is accessed for read-only because we cannot do any lazy-clearing without writing.\n - The Vulkan image layout is either GENERAL or exactly the correct layout for the usage. (we need to also change the backend to assert that during readonly access we don\u0027t do any layout changes, tests that we should add will find a bug here).\n - Ditto for D3D12 although there will be what looks like barriers but they must all decay.",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d76fccd8_0c590e5c",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 233,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "Where do we validate that we can\u0027t access a destroyed texture?",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbf1e965_2e4e5cb3",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 249,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "nit: Error messages conventions would have the error be more like \"%s is already used to access %s.\" And following ones like \"%s is currently accessed for reading and writing.\" \"Read-write access used while %s is accessed in a read-only.\".",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ad0766a_fe38e873",
        "filename": "src/dawn/native/Texture.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1000,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "Why is destroyed + access not an enum? We can\u0027t access a texture if it is destroyed. State could be \"Accessible, Paused, Destroyed\" or something like that? ReadonlyAccess being another boolean because it is checked independently.",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8319468e_4de391be",
        "filename": "src/dawn/native/Texture.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1000,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T18:54:29Z",
      "side": 1,
      "message": "I think we more than the three states, because destroyed-ness is checked at submit time, and access is checked at BeginAccess-time (at least with the current validation rules).\n\nSo, there are four distinct states that behave differently:\n - AliveAndAccessible for the usable state\n - DestroyedAndPaused in order to have double-access validation for destroyed textures\n - AliveAndPaused in order to have submit-time validation for inaccessible textures\n - DestroyedAndAccessible for when BeginAccess succeeds, but then submit-time validation fails b.c. it is destroyed.\n\nWe could make Destroyed a terminal state so that you can\u0027t transition back to Paused, but I\u0027m worried it will make the error handling the client more complicated. Then, the client will need to handle more cases where BeginAccess failed because the texture was destroyed - and the fences weren\u0027t actually acquired.",
      "parentUuid": "5ad0766a_fe38e873",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67530e01_399f2423",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "nit: Can we rename this to be more explicit that it is for SharedTextureMemory. MarkAccessingSharedMemory();\nIsAccessingSharedMemory();",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d894c689_e7352d5d",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T16:49:13Z",
      "side": 1,
      "message": "Actually, non shared textures also use it, just dawn will call `SetHasAccess(true),`, after creating a regular texture. If we rename it, calling it at [1] will look weird. WDYT?\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/SharedTextureMemory.cpp;drc\u003d67d90538f11c6b232dbfd716075db52aeb34fd15;bpv\u003d1;bpt\u003d1;l\u003d198",
      "parentUuid": "67530e01_399f2423",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23d7fa99_3f76c892",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T17:12:55Z",
      "side": 1,
      "message": "If we split the two enums: state (active, paused, destroyed) and sharedAccessMode (None, ReadWrite, ReadOnly) then the true/false becomes a SharedAccessMode and that\u0027s slightly more explicit. The SetHasAccess() in regular creation would be SetState(Active) which seems fine.",
      "parentUuid": "d894c689_e7352d5d",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8cde2084_62563abb",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "The texture should know if it is readonly or writable access. Even a texture with readonly usages can be opened with writable access, this helps produce better barriers in Dawn potentially and allows lazy-clearing.",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d51e85eb_18bcc2ed",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T16:49:13Z",
      "side": 1,
      "message": "How about we verify `SharedTextureMemoryBeginAccessDescriptor::initialized \u003d\u003d true` in `BeginAccess()` for readonly textures? Make it the API client\u0027s responsibility.",
      "parentUuid": "8cde2084_62563abb",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c509c99_b6bfbce4",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T17:12:55Z",
      "side": 1,
      "message": "I think it could break some usages: for example imagine a WebGPU swapchain that a user just wants to sample from (even if that\u0027s silly), we need to be able to lazy clear, so it\u0027s not just based on the wgpu usages but additional metadata. (in this specific case I believe we add internal usages, but that type of case might still happen).",
      "parentUuid": "d51e85eb_18bcc2ed",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "192aefa7_d85cef44",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T17:58:49Z",
      "side": 1,
      "message": "Sorry. I don\u0027t understand the use case. For a swapchain texture, user can import it into dawn as readonly or rw texture, the texture usages used for importing has to be the subset of the real usages of the system texture (vulkan, meta, d3d,etc), but it is not necessary to be equal to the real usages. In this case, if users want to importing it as readonly textures, it means users want dawn never modify the content of the texture, even lazy clear, right?",
      "parentUuid": "0c509c99_b6bfbce4",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ea817a1_93d55402",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T18:54:29Z",
      "side": 1,
      "message": "import as readonly should be able to lazy clear in the non-concurrent read case. That\u0027s also why asking for concurrentRead should probably be a separate bool on the BeginAccess descriptor. So concurrentRead \u003d\u003d true means that BeginAccess must say the texture is initialized - and it will use different layout transitions on Vulkan to ensure the concurrent read layouts are compatible.",
      "parentUuid": "192aefa7_d85cef44",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "841ea931_ccafb830",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T19:11:39Z",
      "side": 1,
      "message": "RE: import as readonly should be able to lazy clear in the non-concurrent read case.\n\nWhy API users cannot make sure the textures are initialized by themself and pass `initialized \u003d\u003d true` for readonly textures? Is there any real use case? For chrome, I believe those readonly textures always have initialized content, either from webgl, webgpu, decoder, camera, etc.",
      "parentUuid": "5ea817a1_93d55402",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9267686_90b67617",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T19:16:03Z",
      "side": 1,
      "message": "I\u0027m pretty sure webgpu\u0027s backing canvas itself is created at first as uninitialized shared images. we inherit the usage from what the developer requested, so they can indeed ask for a read only TextureBinding/CopySrc usage.",
      "parentUuid": "841ea931_ccafb830",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc4b855f_2cf80905",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T20:16:40Z",
      "side": 1,
      "message": "Also - the application is allowed to use StoreOp::Discard which will leave the contents uninitialized - and then this SharedImage could be recycled and used again. Chrome could force all these things to be initialized, but it seems like unnecessary extra work when Dawn already does the lazy clearing.",
      "parentUuid": "a9267686_90b67617",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02f4e5a3_2dd39421",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T20:27:23Z",
      "side": 1,
      "message": "OK. So how do we support it? what does the API look like?",
      "parentUuid": "dc4b855f_2cf80905",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f678684_6b7d1a4f",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T20:46:42Z",
      "side": 1,
      "message": "Maybe I can always add write related usages as internal usage when the texture is created. But we just check the non internal usages in `BeginAccess()`?",
      "parentUuid": "02f4e5a3_2dd39421",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65a0a6ac_e1a592f2",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T22:07:41Z",
      "side": 1,
      "message": "For non-concurrent read, I think the API should look the same.\n\nFor WebGPU\u0027s swapchain, generally WebGPU has exclusive access to the canvas today. So whether it is read-write usage, read-only, or uninitialized read-only (actually read-write) - I don\u0027t think it matters. We shouldn\u0027t need concurrent read. So, it should be allowed to have a read-only texture that you BeginAccess with isInitialized\u003dfalse. It will be treated as a writable usage.\n\nFor concurrent read, I think there are a few possibilities:\n - Explicit concurrent read.\n   In this world, we add a bool like BeginAccessDescriptor::concurrentRead. If it is false, then the code should behave just like it does today. If it is true, then it enables concurrentRead with some additional restrictions.\n   - isInitialized must be true\n   - Vulkan layouts need to be GENERAL (or whatever is actually needed here)\n - Implicit concurrent read.\n   We infer whether concurrent read is possible based on the texture usage, isInitialized, and the Vulkan layouts\n\nIMO it\u0027s better to make things explicit here - since concurrent read can sometimes mean you\u0027re opting into worse performance. Do you think this would make it difficult for Chrome to use?",
      "parentUuid": "1f678684_6b7d1a4f",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b3c8d9a_59507238",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-09T12:27:09Z",
      "side": 1,
      "message": "(+1 for explicit concurrent read like Austin suggested, at least from the Dawn perspective)",
      "parentUuid": "65a0a6ac_e1a592f2",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2cd0679_4f652d9c",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-09T15:38:42Z",
      "side": 1,
      "message": "Could you please explain why Vulkan layouts need to be GENERAL for concurrent read? Thanks",
      "parentUuid": "8b3c8d9a_59507238",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cf56ea9_e59db828",
        "filename": "src/dawn/native/d3d/SharedTextureMemoryD3D.cpp",
        "patchSetId": 4
      },
      "lineNbr": 71,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "nit: We could have getters for things like this instead of having these members protected.",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}