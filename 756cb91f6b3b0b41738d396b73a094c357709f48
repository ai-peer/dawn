{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "fc737bd8_09f848b3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-04T20:24:38Z",
      "side": 1,
      "message": "Hi Austin, Corentin, PTAL. Thanks",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "29de324d_4678418b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T16:00:46Z",
      "side": 1,
      "message": "Corentin and Austin, kindly ping. thanks",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e2ad3cb_ed99374e",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 229,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "I think we need the read-onlyness to be part of the BeginAccessDescriptor: we need to validate the following:\n\n - The texture is marked initialized if it is accessed for read-only because we cannot do any lazy-clearing without writing.\n - The Vulkan image layout is either GENERAL or exactly the correct layout for the usage. (we need to also change the backend to assert that during readonly access we don\u0027t do any layout changes, tests that we should add will find a bug here).\n - Ditto for D3D12 although there will be what looks like barriers but they must all decay.",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6a97eb21_c954b912",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 229,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-09T20:51:14Z",
      "side": 1,
      "message": "Since this CL is not for cross device concurrent read, I think we don\u0027t need to verify those stuff. dawn can still clear the texture of readonly access.",
      "parentUuid": "9e2ad3cb_ed99374e",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d76fccd8_0c590e5c",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 233,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "Where do we validate that we can\u0027t access a destroyed texture?",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cf346795_ea464edc",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 233,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-09T20:51:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d76fccd8_0c590e5c",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbf1e965_2e4e5cb3",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 249,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "nit: Error messages conventions would have the error be more like \"%s is already used to access %s.\" And following ones like \"%s is currently accessed for reading and writing.\" \"Read-write access used while %s is accessed in a read-only.\".",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3a8799a_4f99b413",
        "filename": "src/dawn/native/SharedTextureMemory.cpp",
        "patchSetId": 4
      },
      "lineNbr": 249,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-09T20:51:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dbf1e965_2e4e5cb3",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ad0766a_fe38e873",
        "filename": "src/dawn/native/Texture.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1000,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "Why is destroyed + access not an enum? We can\u0027t access a texture if it is destroyed. State could be \"Accessible, Paused, Destroyed\" or something like that? ReadonlyAccess being another boolean because it is checked independently.",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8319468e_4de391be",
        "filename": "src/dawn/native/Texture.cpp",
        "patchSetId": 4
      },
      "lineNbr": 1000,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T18:54:29Z",
      "side": 1,
      "message": "I think we more than the three states, because destroyed-ness is checked at submit time, and access is checked at BeginAccess-time (at least with the current validation rules).\n\nSo, there are four distinct states that behave differently:\n - AliveAndAccessible for the usable state\n - DestroyedAndPaused in order to have double-access validation for destroyed textures\n - AliveAndPaused in order to have submit-time validation for inaccessible textures\n - DestroyedAndAccessible for when BeginAccess succeeds, but then submit-time validation fails b.c. it is destroyed.\n\nWe could make Destroyed a terminal state so that you can\u0027t transition back to Paused, but I\u0027m worried it will make the error handling the client more complicated. Then, the client will need to handle more cases where BeginAccess failed because the texture was destroyed - and the fences weren\u0027t actually acquired.",
      "parentUuid": "5ad0766a_fe38e873",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67530e01_399f2423",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "nit: Can we rename this to be more explicit that it is for SharedTextureMemory. MarkAccessingSharedMemory();\nIsAccessingSharedMemory();",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d894c689_e7352d5d",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T16:49:13Z",
      "side": 1,
      "message": "Actually, non shared textures also use it, just dawn will call `SetHasAccess(true),`, after creating a regular texture. If we rename it, calling it at [1] will look weird. WDYT?\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/SharedTextureMemory.cpp;drc\u003d67d90538f11c6b232dbfd716075db52aeb34fd15;bpv\u003d1;bpt\u003d1;l\u003d198",
      "parentUuid": "67530e01_399f2423",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23d7fa99_3f76c892",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T17:12:55Z",
      "side": 1,
      "message": "If we split the two enums: state (active, paused, destroyed) and sharedAccessMode (None, ReadWrite, ReadOnly) then the true/false becomes a SharedAccessMode and that\u0027s slightly more explicit. The SetHasAccess() in regular creation would be SetState(Active) which seems fine.",
      "parentUuid": "d894c689_e7352d5d",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c8f219c_8740d210",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-09T20:51:14Z",
      "side": 1,
      "message": "Since this CL is not for supporting cross device concurrent read, I think we don\u0027t need to use the access mode for explicit readonly access.",
      "parentUuid": "23d7fa99_3f76c892",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8cde2084_62563abb",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "The texture should know if it is readonly or writable access. Even a texture with readonly usages can be opened with writable access, this helps produce better barriers in Dawn potentially and allows lazy-clearing.",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d51e85eb_18bcc2ed",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T16:49:13Z",
      "side": 1,
      "message": "How about we verify `SharedTextureMemoryBeginAccessDescriptor::initialized \u003d\u003d true` in `BeginAccess()` for readonly textures? Make it the API client\u0027s responsibility.",
      "parentUuid": "8cde2084_62563abb",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c509c99_b6bfbce4",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T17:12:55Z",
      "side": 1,
      "message": "I think it could break some usages: for example imagine a WebGPU swapchain that a user just wants to sample from (even if that\u0027s silly), we need to be able to lazy clear, so it\u0027s not just based on the wgpu usages but additional metadata. (in this specific case I believe we add internal usages, but that type of case might still happen).",
      "parentUuid": "d51e85eb_18bcc2ed",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "192aefa7_d85cef44",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T17:58:49Z",
      "side": 1,
      "message": "Sorry. I don\u0027t understand the use case. For a swapchain texture, user can import it into dawn as readonly or rw texture, the texture usages used for importing has to be the subset of the real usages of the system texture (vulkan, meta, d3d,etc), but it is not necessary to be equal to the real usages. In this case, if users want to importing it as readonly textures, it means users want dawn never modify the content of the texture, even lazy clear, right?",
      "parentUuid": "0c509c99_b6bfbce4",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ea817a1_93d55402",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T18:54:29Z",
      "side": 1,
      "message": "import as readonly should be able to lazy clear in the non-concurrent read case. That\u0027s also why asking for concurrentRead should probably be a separate bool on the BeginAccess descriptor. So concurrentRead \u003d\u003d true means that BeginAccess must say the texture is initialized - and it will use different layout transitions on Vulkan to ensure the concurrent read layouts are compatible.",
      "parentUuid": "192aefa7_d85cef44",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "841ea931_ccafb830",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T19:11:39Z",
      "side": 1,
      "message": "RE: import as readonly should be able to lazy clear in the non-concurrent read case.\n\nWhy API users cannot make sure the textures are initialized by themself and pass `initialized \u003d\u003d true` for readonly textures? Is there any real use case? For chrome, I believe those readonly textures always have initialized content, either from webgl, webgpu, decoder, camera, etc.",
      "parentUuid": "5ea817a1_93d55402",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a9267686_90b67617",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T19:16:03Z",
      "side": 1,
      "message": "I\u0027m pretty sure webgpu\u0027s backing canvas itself is created at first as uninitialized shared images. we inherit the usage from what the developer requested, so they can indeed ask for a read only TextureBinding/CopySrc usage.",
      "parentUuid": "841ea931_ccafb830",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc4b855f_2cf80905",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T20:16:40Z",
      "side": 1,
      "message": "Also - the application is allowed to use StoreOp::Discard which will leave the contents uninitialized - and then this SharedImage could be recycled and used again. Chrome could force all these things to be initialized, but it seems like unnecessary extra work when Dawn already does the lazy clearing.",
      "parentUuid": "a9267686_90b67617",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02f4e5a3_2dd39421",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T20:27:23Z",
      "side": 1,
      "message": "OK. So how do we support it? what does the API look like?",
      "parentUuid": "dc4b855f_2cf80905",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f678684_6b7d1a4f",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-08T20:46:42Z",
      "side": 1,
      "message": "Maybe I can always add write related usages as internal usage when the texture is created. But we just check the non internal usages in `BeginAccess()`?",
      "parentUuid": "02f4e5a3_2dd39421",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65a0a6ac_e1a592f2",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-08T22:07:41Z",
      "side": 1,
      "message": "For non-concurrent read, I think the API should look the same.\n\nFor WebGPU\u0027s swapchain, generally WebGPU has exclusive access to the canvas today. So whether it is read-write usage, read-only, or uninitialized read-only (actually read-write) - I don\u0027t think it matters. We shouldn\u0027t need concurrent read. So, it should be allowed to have a read-only texture that you BeginAccess with isInitialized\u003dfalse. It will be treated as a writable usage.\n\nFor concurrent read, I think there are a few possibilities:\n - Explicit concurrent read.\n   In this world, we add a bool like BeginAccessDescriptor::concurrentRead. If it is false, then the code should behave just like it does today. If it is true, then it enables concurrentRead with some additional restrictions.\n   - isInitialized must be true\n   - Vulkan layouts need to be GENERAL (or whatever is actually needed here)\n - Implicit concurrent read.\n   We infer whether concurrent read is possible based on the texture usage, isInitialized, and the Vulkan layouts\n\nIMO it\u0027s better to make things explicit here - since concurrent read can sometimes mean you\u0027re opting into worse performance. Do you think this would make it difficult for Chrome to use?",
      "parentUuid": "1f678684_6b7d1a4f",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b3c8d9a_59507238",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-09T12:27:09Z",
      "side": 1,
      "message": "(+1 for explicit concurrent read like Austin suggested, at least from the Dawn perspective)",
      "parentUuid": "65a0a6ac_e1a592f2",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2cd0679_4f652d9c",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-09T15:38:42Z",
      "side": 1,
      "message": "Could you please explain why Vulkan layouts need to be GENERAL for concurrent read? Thanks",
      "parentUuid": "8b3c8d9a_59507238",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d085648c_6cc329bf",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-09T17:32:08Z",
      "side": 1,
      "message": "Layout changes in Vulkan do compression plane compression and decompression (Hi-Z, Clear color compression, etc).\n\nImagine your texture units can handle compression planes, but not the copy engine, then a SHADER_READ_OPTIMAL -\u003e TRANSFER_SRC_OPTIMAL transition will be doing a decompression, which is technically a write, and could cause another concurrent user of the same texture to read garbage.",
      "parentUuid": "c2cd0679_4f652d9c",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "58ac2a04_9b783879",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-09T20:51:14Z",
      "side": 1,
      "message": "Actually, this CL is for allowing concurrent read access from one wgpu device. It is not for cross device accessing. If we find chrome does need cross device concurrent read, we will implement it in a separate CL.\n\nI update the CL comment to make it clear.",
      "parentUuid": "d085648c_6cc329bf",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e74f31d_afd9a4d2",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-10T12:13:04Z",
      "side": 1,
      "message": "As discussed yesterday, even with concurrent access on a single wgpu device, Vulkan image layouts can get out of sync, which would cause issues. What are the exact use cases in Chromium that require this concurrent read-only access? Eventually we will need to make the semantic for concurrent read access checked consistently with all the constraints listed in this thread.\n\nTo unblock Graphite we could go forward with the change as it is now, but with extensive TODOs, bugs recorded for future work and an entry in \"Graphite/Dawn Tech Debt and Future Directions Tracking\". Ideally we have a flag that Chromium must use to say it is doing bad things and knows it (which means the test change will be undone and new tests added for that flag).\n\nAlso ideally I\u0027d like to wait for Austin\u0027s opinion on this.",
      "parentUuid": "58ac2a04_9b783879",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4b2ed052_f94403a5",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000122
      },
      "writtenOn": "2024-01-10T12:58:16Z",
      "side": 1,
      "message": "\u003e As discussed yesterday, even with concurrent access on a single wgpu device, Vulkan image layouts can get out of sync, which would cause issues. What are the exact use cases in Chromium that require this concurrent read-only access? \n\nOn Mac, once we cache the SharedTextureMemory objects in IOSurfaceImageBacking on a per-Device level, the WebGPU video decoder webcodecs sample code triggers concurrent reads. So it\u0027s a blocker for that line of work. I don\u0027t know what concrete issues Peng hit on Windows, but most SharedImage backings support concurrent reads, so I think that it will generally come up as we look to cache SharedTextureMemory objects within those backings at a per-Device level.\n\nEventually we will need to make the semantic for concurrent read access checked consistently with all the constraints listed in this thread.\n\u003e \n\u003e To unblock Graphite we could go forward with the change as it is now, but with extensive TODOs, bugs recorded for future work and an entry in \"Graphite/Dawn Tech Debt and Future Directions Tracking\". Ideally we have a flag that Chromium must use to say it is doing bad things and knows it (which means the test change will be undone and new tests added for that flag).\n\u003e \n\u003e Also ideally I\u0027d like to wait for Austin\u0027s opinion on this.\n\nWaiting for Austin\u0027s opinion definitely makes sense. I would suggest:\n\n* What if we go forward allowing concurrent access for Mac/Windows at this time with a separate TODO/bug for Vulkan? This would unblock both my and Peng\u0027s current lines of work, and Vulkan won\u0027t come up until we switch Chromium to use SharedTextureMemory for Vulkan in any case.\n* With respect to texture initialization and concurrent read access, what if we just treated a read of an uninitialized texture as having write semantics wrt concurrent access (in the implementation)? At least on Mac, I verified that all of the textures that were hitting the concurrent read access case were initialized.",
      "parentUuid": "0e74f31d_afd9a4d2",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c77664a5_61a66a96",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-10T15:55:17Z",
      "side": 1,
      "message": "Thank you for describing the use-case!\n\n\u003e With respect to texture initialization and concurrent read access, what if we just treated a read of an uninitialized texture as having write semantics wrt concurrent access (in the implementation)? At least on Mac, I verified that all of the textures that were hitting the concurrent read access case were initialized.\n\nThat\u0027s an even bigger source of inconsistency between two concurrently imported readonly textures, because one might get written to using a render pass to clear while another on is sampled / copied from. I think in the current state of this CL D3D12 happens to be correct barrier-wise, but not anymore if we allow clearing.\n\nThat\u0027s why eventually we should have all the validation mentioned and remove the mode where concurrent read accesses on the same device are assumed correct.",
      "parentUuid": "4b2ed052_f94403a5",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52324276_bdb4d625",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000122
      },
      "writtenOn": "2024-01-10T16:37:54Z",
      "side": 1,
      "message": "\u003e Thank you for describing the use-case!\n\u003e \n\u003e \u003e With respect to texture initialization and concurrent read access, what if we just treated a read of an uninitialized texture as having write semantics wrt concurrent access (in the implementation)? At least on Mac, I verified that all of the textures that were hitting the concurrent read access case were initialized.\n\u003e \n\u003e That\u0027s an even bigger source of inconsistency between two concurrently imported readonly textures, because one might get written to using a render pass to clear while another on is sampled / copied from. I think in the current state of this CL D3D12 happens to be correct barrier-wise, but not anymore if we allow clearing.\n\nI\u0027m confused: I meant that Dawn would raise an error if there were concurrent accesses and at least one was a read of an uninitialized texture, the same way it would if at least one was a write. The client specifies whether the texture is initialized or not, so they should be able to work within this constraint, right? Is there something I\u0027m missing?\n\n\u003e \n\u003e That\u0027s why eventually we should have all the validation mentioned and remove the mode where concurrent read accesses on the same device are assumed correct.",
      "parentUuid": "c77664a5_61a66a96",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d94f6db5_1e448918",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-10T17:34:07Z",
      "side": 1,
      "message": "Ah Dawn raising an error on concurrent read + not initialized solves that problem, but my understanding was that Peng was looking to not do that for now.",
      "parentUuid": "52324276_bdb4d625",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "404d06b3_186ff6fa",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1003451
      },
      "writtenOn": "2024-01-10T19:09:28Z",
      "side": 1,
      "message": "RE @cwallez@chromium.org\n\nDo you mean add a field `concurrentRead` in `SharedTextureMemoryBeginAccessDescriptor` to allow concurrent read on a single device, and verify it and `initialized` in `BeginAccess()`?\n\nIn this way, chrome has to always set `concurrentRead` to true for all read access, and there will be use cases with read access with un-initialized texture (It is because the SI backing doesn\u0027t known the if it will be read in same time in advance.). It works right now. We don\u0027t want to break it.\n\nFor vulkan layout issue, I still don\u0027t understand it. When we concurrent read a shared texture on a single device, dawn should be able to change vkImage to desired layout before each vulkan operation. Since all concurrent read are on the same wgpu device, they are serialized and submitted to the same VkQueue, right?\n\nI will wait Austin back, so we can discuss it.",
      "parentUuid": "d94f6db5_1e448918",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d764cb6_72017667",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000122
      },
      "writtenOn": "2024-01-11T12:22:12Z",
      "side": 1,
      "message": "What I had been thinking was there wouldn\u0027t be any `concurrentRead` flag but rather that the SharedTextureMemory implementation would allow concurrent read accesses of initialized textures but not concurrent accesses where at least one of the accesses was either a write or a read of an uninitialized texture. This would then work as long as Chromium doesn\u0027t have a use case for concurrent reads of an uninitialized texture - Peng, have you seen such a use case? In the Mac use case that I described above, I verified that the textures are initialized.\n\nI do recall that there is a CONCURRENT_READ_WRITE SharedImageUsage flag that we might need to deal with, but for that use case it does seem to me that we could have a client-specified `allow_concurrent_read_write` and then all bets are off from Dawn\u0027s POV if the client specifies that. That could be for followup when we hit that.",
      "parentUuid": "404d06b3_186ff6fa",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3727bca_b1117726",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-11T12:34:07Z",
      "side": 1,
      "message": "I understand that:\n\n 1 - Chromium has use cases that work with concurrent read right now, including uninitialized texture getting lazy-cleared.\n 2 - The behavior was not seen to be problematic so far.\n 3 - For Graphite we need to move forward.\n\nSo we can land this CL or some variant of it (with a preference for having an explicit flag to make it clear that *bad stuff can happen*, and has much validation as Graphite is comfortable with in Dawn). However, Chromium\u0027s behavior right now happens to work but isn\u0027t correct and could lead to subtle, flaky issues. We need to fix Chromium\u0027s behavior to be correct and data-race free at some point.\n\nDynamicCompoundSharedImage will provide a way to correctly have opportunistic concurrent read-only access with a fallback if a write access needs to be done. (performing a copy to the new backing for the write is only reading from the previous backing). Historical data gathered with a SharedImageStream-like concept will allow repeated uses of such copies to be optimized away if possible by adding more usages, using more general layouts, etc. This is complex but needs to be fixed at some point or we\u0027ll get rare breakages in the wild when the GPUs do read-write data races with what Chromium thinks are only read-only accesses. Dawn and SI can work together to add validation that the behavior is correct, while making it easy for users of SI to do the correct thing.",
      "parentUuid": "6d764cb6_72017667",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a5bc2e3_a56e4799",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000122
      },
      "writtenOn": "2024-01-11T13:09:20Z",
      "side": 1,
      "message": "\u003e I understand that:\n\u003e \n\u003e  1 - Chromium has use cases that work with concurrent read right now, including uninitialized texture getting lazy-cleared.\n\nCorentin and I just discussed - I\u0027m not 100% that the Chromium use cases for concurrent read include concurrent read of uninitialized textures. I haven\u0027t seen any such use cases on Mac. Peng, are you aware of any on Windows?\n\n\u003e  2 - The behavior was not seen to be problematic so far.\n\u003e  3 - For Graphite we need to move forward.\n\u003e \n\u003e So we can land this CL or some variant of it (with a preference for having an explicit flag to make it clear that *bad stuff can happen*, and has much validation as Graphite is comfortable with in Dawn). However, Chromium\u0027s behavior right now happens to work but isn\u0027t correct and could lead to subtle, flaky issues. We need to fix Chromium\u0027s behavior to be correct and data-race free at some point.\n\u003e \n\u003e DynamicCompoundSharedImage will provide a way to correctly have opportunistic concurrent read-only access with a fallback if a write access needs to be done. (performing a copy to the new backing for the write is only reading from the previous backing). Historical data gathered with a SharedImageStream-like concept will allow repeated uses of such copies to be optimized away if possible by adding more usages, using more general layouts, etc. This is complex but needs to be fixed at some point or we\u0027ll get rare breakages in the wild when the GPUs do read-write data races with what Chromium thinks are only read-only accesses. Dawn and SI can work together to add validation that the behavior is correct, while making it easy for users of SI to do the correct thing.",
      "parentUuid": "a3727bca_b1117726",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bae37e5_02d86fda",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-11T18:13:23Z",
      "side": 1,
      "message": "My understanding is today (pre-SharedTextureMemory), concurrent read indeed happens-to-work because in most cases we aren\u0027t accessing uninitialized textures. I\u0027m fairly sure, however, there are very few guarantees that that invariant holds true - so it is very fragile and may already be the cause of some of our test failures / test flakes / synchronization issues seen in applications. Please keep in mind that with Dawn/WebGPU, the application itself can force textures to become uninitialized. Even if we don\u0027t know of situations today, they can easily be added in the future - and Javascript applications can always do whatever they want here.\n\nI understand that what Colin/Peng are suggesting is to do implicit-mode concurrent read for now. That is - if the texture has readonly usage and the texture is initialized, we consider it OK for concurrent read. I think this would match the current potentially-broken, fragile behavior to make SharedTextureMemory on-par with the prior approach on Windows and Mac.\n\nFor Vulkan, I don\u0027t think this approach will be sufficient to be correct - because of the need to make the layouts compatible. I don\u0027t fully understand how it actually works today. Perhaps it also happens-to-work because WebGPU\u0027s external video import and Chrome are both sampling videos when they are concurrently read - so the layouts happen to match. I don\u0027t know all the cases, and this would break if one of the usages became a copy. In the fullness of time, I think we will eventually need to add a `concurrentRead` flag to this for correctness on Vulkan.\n\nI am hesitant about making SharedTextureMemory work implicitly on the same kinda-broken assumptions as the current system because STM was intended to be a robust solution based on our learnings of how things need to work. If we add a stopgap hack now, it\u0027ll be more added tech debt and we would have failed to actually solve the original problem. We\u0027ll do a bunch of engineering to replace the old thing with STM - only to still have more multi-sided-patches to do to fix up STM to work more robustly and work on Vulkan later. Maybe this is fine and it can happen incrementally without a lot of churn - but it\u0027s hard to say without a clear picture of what we\u0027re going to do after this. I have a fair amount of confidence that we will eventually need a `concurrentRead` flag so that we can make WebGPU work with dual-GPU windows and Linux. Currently, we don\u0027t let you use the other GPU because of issues like this.\n\nOpen to hearing other options, but I think the least-mess way to do it would be to add the explicit `concurrentRead` flag in Dawn, and then have Chrome pass true for all read usages. Later, Chrome can be smarter about this, but we can do that without needing to change Dawn\u0027s API. In the immediate term, this would be ~2 patches - one in Dawn to add the flag and one in Chrome to use STM with concurrentRead all the time, which would then unblock Graphite on Win/Mac - so it wouldn\u0027t delay things significantly.",
      "parentUuid": "3a5bc2e3_a56e4799",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "179b28b8_fb183822",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000122
      },
      "writtenOn": "2024-01-12T12:49:41Z",
      "side": 1,
      "message": "Thanks, Austin! I have no problem with adding a `concurrentRead` flag - we just need to address the subtlety that Peng mentioned in his last comment, which is that Chromium will both need concurrent reads and will need reads of uninitialized textures (but *not* AFAIK concurrent reads *of* uninitialized textures). So Dawn having an invariant of \"concurrent reads flag implies that all reads are to initialized textures\" wouldn\u0027t work. What I would suggest instead is \"concurrent read flag -\u003e concurrent reads of *initialized* textures are allowed instead of being disallowed\", with a read of an uninitialized texture always being traced and treated as an exclusive access just as a write access would be.\n\nAgree about tackling for Windows and Mac now and opening up a broader discussion about what is currently going on in Chromium wrt Vulkan to figure out the best path forward there overall. Clearly we have time on that front.",
      "parentUuid": "2bae37e5_02d86fda",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3cf92ba_6d85f25e",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-01-12T17:11:08Z",
      "side": 1,
      "message": "Chromium is responsible for passing both the isInitialized state and the concurrentRead flag. if it is passing isInitialized\u003d\u003dfalse, it can also pass concurrentRead\u003d\u003dfalse.\nthis way, it\u0027s explicit that you are *not* doing a concurrent read.\n\nwith this approach, I think it is then possible for concurrentRead to require all reads to be of initialized textures. if chromium needs to read an uninitialized texture, it doesn\u0027t use the concurrentRead mode.",
      "parentUuid": "179b28b8_fb183822",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e24e52d_c458df2b",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000122
      },
      "writtenOn": "2024-01-15T13:30:24Z",
      "side": 1,
      "message": "Thanks! I had mistakenly understood that you were thinking of passing an \"are concurrent reads allowed\" configuration flag when *creating* the SharedTextureMemory object and allowing uninitialized reads only if that flag wasn\u0027t set.\n\nIn any case, we had an illuminating conversation on #gpu-shared-images on Friday. Chromium disallows reads of uninitialized textures at the SI level, e.g. for Dawn this happens here [1] (AllowUnclearedAccess is always set to kNo for reads). So things are fine from that POV. (Vasiliy also mentioned that we can all have a discussion about Vulkan in this context when the time comes to make sure that we\u0027re all on the right page and figure out the way forward there).\n\nHowever, Vasiliy reminded us that we currently basically always set write usages on Dawn textures created for Graphite [2][3][4]. I think we\u0027ll have to solve [5] to get the benefits of concurrent read access.\n\nPeng, WDYT?\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/shared_image_representation.cc;l\u003d799-802\n[2] https://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/shared_image_format_service_utils.cc;drc\u003d98a01e556dc3c775db2a129120504518b3e9b7e0;l\u003d517\n[3] https://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/skia_graphite_dawn_image_representation.cc;l\u003d5?q\u003dgraphite_dawn_ima\u0026sq\u003d\u0026ss\u003dchromium\n[4] https://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/skia_graphite_dawn_image_representation.cc;l\u003d206-207?q\u003dgraphite_dawn_ima\u0026ss\u003dchromium\n[5] https://bugs.chromium.org/p/chromium/issues/detail?id\u003d1451784",
      "parentUuid": "a3cf92ba_6d85f25e",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "35350e93_0d6a029f",
        "filename": "src/dawn/native/Texture.h",
        "patchSetId": 4
      },
      "lineNbr": 114,
      "author": {
        "id": 1000122
      },
      "writtenOn": "2024-01-15T13:32:51Z",
      "side": 1,
      "message": "^ [3] https://source.chromium.org/chromium/chromium/src/+/main:gpu/command_buffer/service/shared_image/skia_graphite_dawn_image_representation.cc;l\u003d59-61?q\u003dgraphite_dawn_ima\u0026ss\u003dchromium",
      "parentUuid": "4e24e52d_c458df2b",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cf56ea9_e59db828",
        "filename": "src/dawn/native/d3d/SharedTextureMemoryD3D.cpp",
        "patchSetId": 4
      },
      "lineNbr": 71,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-01-08T16:31:02Z",
      "side": 1,
      "message": "nit: We could have getters for things like this instead of having these members protected.",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b7a74702_ee338fc0",
        "filename": "src/dawn/native/d3d/SharedTextureMemoryD3D.cpp",
        "patchSetId": 4
      },
      "lineNbr": 71,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-01-09T20:51:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7cf56ea9_e59db828",
      "revId": "756cb91f6b3b0b41738d396b73a094c357709f48",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}