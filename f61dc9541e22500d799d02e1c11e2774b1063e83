{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "766ab9a1_44a9a564",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-02T21:46:19Z",
      "side": 1,
      "message": "PTAL",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68156161_5937cd69",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "LGTM overall with some comments.\n\nAlso, one problem I realized that we will need to fix in Chrome.\nIn WebGPU, it is legal to texture.destroy() your canvas texture.\nSo you can: \n 1. get the canvas texture and render to it, and queue.submit\n 2. canvasTexture.destroy() // simply revokes write access from js\n 3. oh no! chrome doesn\u0027t synchronize the writes we made!\n \nSpec says:\n\u003e Destroying the currentTexture has no effect on the drawing buffer contents; it only terminates write-access to the drawing buffer early. During the same frame, getCurrentTexture() continues returning the same destroyed texture.\n\nThat means to fix this in Chrome, we may need to make canvas textures special so that when you .destroy() them, we can dissociate mailbox for proper synchronization first.",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7342b9a5_d144625b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-03T00:36:42Z",
      "side": 1,
      "message": "I think this is already handled with a small tweak in blink GPUTexture::destroy() - mailbox_texture_ should be released before calling GetProcs().textureDestroy() so that we go through the DestroyTexture() call in DissociateTexture() path first before attempting Destroy() which will then be a no-op.\n\nI\u0027ll put up a CL for this if you agree with the suggested fix.",
      "parentUuid": "68156161_5937cd69",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2b8b412_96630e96",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-03T00:36:42Z",
      "side": 1,
      "message": "I removed the special handling of the 0 fence signal value and made the parameters required. The default fence signal value when not specified in the descriptor or if client calls Destroy() before ExternalImageDXGI::DestroyTexture() is UINT64_MAX - this is a better default than 0 because it will most likely cause future waits to block indefinitely making any bug apparent - there are also warning logs in both cases where we use UINT64_MAX to help with debugging if such a case does arise.\n\nPTAL again, thanks!",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7c40c53d_86cc53af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-03T04:37:40Z",
      "side": 1,
      "message": "oh, nice I think that will work indeed (unless someone intended to have the particular current ordering)",
      "parentUuid": "7342b9a5_d144625b",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8f7c86d_e608500f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-03T04:37:40Z",
      "side": 1,
      "message": "Wouldn\u0027t UINT64_MAX cause no waits to happen?\n\n`ID3D12CommandQueue::Wait` does\n\u003e Queues a GPU-side wait, and returns immediately. A GPU-side wait is where the GPU waits until the specified fence reaches or exceeds the specified value.\n\nSo if we signal UINT64_MAX, nearly all waits will be marked complete since the fence will exceed nearly all values\n\nI think it might be best to never signal at all if there is an unsynchronized destroy.\nI was thinking:\n\n```\nDestroyExternalTexture(signalValue) {\n  if (fence !\u003d null) {\n    Signal(fence, signalValue);\n    fence \u003d null; // clear out fence so DestroyImpl knows it\u0027s been signaled\n  }\n  DestroyImpl();\n}\n\nDestroyImpl() {\n  ...\n  if (fence) {\n    dawn::WarningLog() \u003c\u003c \"wrong usage\";\n    fence \u003d nullptr;\n  }\n  ...\n}\n```",
      "parentUuid": "d2b8b412_96630e96",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ffcd70b_cd8ff80e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-03T20:23:07Z",
      "side": 1,
      "message": "UINT64_MAX when specified as the fenceWaitValue in the begin access descriptor is treated as a no-op, but here we\u0027re talking about cases where the client either uses wgpuTextureDestroy instead of ExternalImageDXGI::DestroyTexture or forgets to set a fenceSignalValue. We\u0027re passing UINT64_MAX to the D3D12 fence signal command, but the client doesn\u0027t know this and the next wait will block indefinitely.\n\nYou\u0027re right that this doesn\u0027t protect against the client also passing the default value in the begin access descriptor and therefore the wait gets treated as a no-op, and the bug wouldn\u0027t be caught assuming that there are no other waits (e.g. in D3D11). We can protect against that by setting the default wait value in the begin access descriptor to 0. WDYT?",
      "parentUuid": "b8f7c86d_e608500f",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a145c8b6_19f5858b",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 86,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "do we need to have 0 mean it is not signaled?\n\nIf not, then we could remove the \"0\" special-conditioning that we have around the fence path.",
      "range": {
        "startLine": 84,
        "startChar": 70,
        "endLine": 86,
        "endChar": 34
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf48bdcf_6387bdc6",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 86,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-03T00:36:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a145c8b6_19f5858b",
      "range": {
        "startLine": 84,
        "startChar": 70,
        "endLine": 86,
        "endChar": 34
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae717511_77223e36",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 122,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "const?",
      "range": {
        "startLine": 122,
        "startChar": 24,
        "endLine": 122,
        "endChar": 60
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd28fbeb_f0ed2647",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 122,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "do we need a default of \u003d nullptr, or should all users always pass a descriptor (and we ASSERT it is non-null).\n\nIf the nullptr situation is needed, I think it might be preferable to pass its absence with std::optional directly down instead of of passing 0 if the desc is null.",
      "range": {
        "startLine": 122,
        "startChar": 72,
        "endLine": 122,
        "endChar": 82
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c98762f1_1e171165",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 122,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-03T00:36:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cd28fbeb_f0ed2647",
      "range": {
        "startLine": 122,
        "startChar": 72,
        "endLine": 122,
        "endChar": 82
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "51946aed_d8e34c14",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 122,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-03T00:36:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ae717511_77223e36",
      "range": {
        "startLine": 122,
        "startChar": 24,
        "endLine": 122,
        "endChar": 60
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8db045e9_8b92942d",
        "filename": "src/dawn/native/d3d12/TextureD3D12.cpp",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "old include, probably from local debugging",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 28
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cdacfc8b_e8aaa927",
        "filename": "src/dawn/native/d3d12/TextureD3D12.cpp",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-03T00:36:42Z",
      "side": 1,
      "message": "Isn\u0027t this needed for the WarningLog() in DestroyImpl()?",
      "parentUuid": "8db045e9_8b92942d",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 28
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd4d5aae_d81c1561",
        "filename": "src/dawn/native/d3d12/TextureD3D12.cpp",
        "patchSetId": 3
      },
      "lineNbr": 698,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "Again, would prefer not to have the default `\u003d 0` if it\u0027s not going to do anything. And even better if we can make 0 not magic.\n\nperhaps an alternate structure: move the fence signaling so it only happens in DestroyExternalTexture and then free the fence. Then, call DestroyImpl which will warn if the fence is non-null (destroy called directly, instead of via DestroyExternalTexture)",
      "range": {
        "startLine": 698,
        "startChar": 0,
        "endLine": 698,
        "endChar": 20
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c238a72_0808215c",
        "filename": "src/dawn/native/d3d12/TextureD3D12.cpp",
        "patchSetId": 3
      },
      "lineNbr": 698,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-03T00:36:42Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "bd4d5aae_d81c1561",
      "range": {
        "startLine": 698,
        "startChar": 0,
        "endLine": 698,
        "endChar": 20
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}