{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "766ab9a1_44a9a564",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2022-08-02T21:46:19Z",
      "side": 1,
      "message": "PTAL",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68156161_5937cd69",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "LGTM overall with some comments.\n\nAlso, one problem I realized that we will need to fix in Chrome.\nIn WebGPU, it is legal to texture.destroy() your canvas texture.\nSo you can: \n 1. get the canvas texture and render to it, and queue.submit\n 2. canvasTexture.destroy() // simply revokes write access from js\n 3. oh no! chrome doesn\u0027t synchronize the writes we made!\n \nSpec says:\n\u003e Destroying the currentTexture has no effect on the drawing buffer contents; it only terminates write-access to the drawing buffer early. During the same frame, getCurrentTexture() continues returning the same destroyed texture.\n\nThat means to fix this in Chrome, we may need to make canvas textures special so that when you .destroy() them, we can dissociate mailbox for proper synchronization first.",
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a145c8b6_19f5858b",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 86,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "do we need to have 0 mean it is not signaled?\n\nIf not, then we could remove the \"0\" special-conditioning that we have around the fence path.",
      "range": {
        "startLine": 84,
        "startChar": 70,
        "endLine": 86,
        "endChar": 34
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae717511_77223e36",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 122,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "const?",
      "range": {
        "startLine": 122,
        "startChar": 24,
        "endLine": 122,
        "endChar": 60
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd28fbeb_f0ed2647",
        "filename": "include/dawn/native/D3D12Backend.h",
        "patchSetId": 3
      },
      "lineNbr": 122,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "do we need a default of \u003d nullptr, or should all users always pass a descriptor (and we ASSERT it is non-null).\n\nIf the nullptr situation is needed, I think it might be preferable to pass its absence with std::optional directly down instead of of passing 0 if the desc is null.",
      "range": {
        "startLine": 122,
        "startChar": 72,
        "endLine": 122,
        "endChar": 82
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8db045e9_8b92942d",
        "filename": "src/dawn/native/d3d12/TextureD3D12.cpp",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "old include, probably from local debugging",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 21,
        "endChar": 28
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd4d5aae_d81c1561",
        "filename": "src/dawn/native/d3d12/TextureD3D12.cpp",
        "patchSetId": 3
      },
      "lineNbr": 698,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-08-02T23:00:08Z",
      "side": 1,
      "message": "Again, would prefer not to have the default `\u003d 0` if it\u0027s not going to do anything. And even better if we can make 0 not magic.\n\nperhaps an alternate structure: move the fence signaling so it only happens in DestroyExternalTexture and then free the fence. Then, call DestroyImpl which will warn if the fence is non-null (destroy called directly, instead of via DestroyExternalTexture)",
      "range": {
        "startLine": 698,
        "startChar": 0,
        "endLine": 698,
        "endChar": 20
      },
      "revId": "f61dc9541e22500d799d02e1c11e2774b1063e83",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}