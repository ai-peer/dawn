{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "88fee737_23b1da05",
        "filename": "src/dawn/native/d3d12/ExternalImageDXGIImpl.cpp",
        "patchSetId": 23
      },
      "lineNbr": 74,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-11T20:17:09Z",
      "side": 1,
      "message": "won\u0027t this deadlock? \n\nAPIDestroy and WillDropLastExternalRef both acquire the scoped lock, then call Device::Destroy\n\nwhich iterates the external image list and calls Destroy on each one.\n\nWhy can\u0027t we use an atomic to mark it as destroyed?",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 74,
        "endChar": 58
      },
      "revId": "9cb45e9c59a440e113bcbb33a60a98ac54d3d58c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0421ea5e_376b0bdb",
        "filename": "src/dawn/native/d3d12/ExternalImageDXGIImpl.cpp",
        "patchSetId": 23
      },
      "lineNbr": 74,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-12T02:04:10Z",
      "side": 1,
      "message": "\u003e won\u0027t this deadlock?\n\nOk Thanks, I missed this case. `Destroy` looks like it would have been called directly from public API.\nThe locking has been removed from here, replaced by an assertion instead. Added the locking to dtor.\nI have also created a test case to this CL to catch this deadlock and another test case to verify there is no race when using the external image and destroying the device simultaneously.\n\n\n\u003e Why can\u0027t we use an atomic to mark it as destroyed?\n\nHow do you suggest the atomic to be used? AFAIK, atomic alone is not useful in this class. Without locking, the device could be destroyed between the time the atomic is checked and the time the image is used. e.g.\n```\nif (!mDestroyed.load()) {\n  // the device could be destroyed on another thread at this point.\n  lock(device) --\u003e crash since device is null\n  RemoveFromList();\n  \n  mDestroyed.store(true);\n}\n```\n\nWe can rework to make `ExternalImageDXGIImpl` \u0027s lifetime tracking consistent with other objects in future.",
      "parentUuid": "88fee737_23b1da05",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 74,
        "endChar": 58
      },
      "revId": "9cb45e9c59a440e113bcbb33a60a98ac54d3d58c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a8ebe780_cd1ee817",
        "filename": "src/dawn/native/d3d12/ExternalImageDXGIImpl.cpp",
        "patchSetId": 23
      },
      "lineNbr": 74,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-04-12T02:27:25Z",
      "side": 1,
      "message": "Using an atomic could be useful to avoid a locking in `IsValid` method. But the locking is still required in `BeginAccess`/`EndAccess`.\n\nI think the `IsValid` method should be removed in future after we add multithreading support to this class. Using that method to check before accessing the image is not thread safe. Chrome should only use those methods that do \"IsValid check + other works\" in one \"atomic\" sequence.",
      "parentUuid": "0421ea5e_376b0bdb",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 74,
        "endChar": 58
      },
      "revId": "9cb45e9c59a440e113bcbb33a60a98ac54d3d58c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a03cf11_e3f94cec",
        "filename": "src/dawn/native/d3d12/ExternalImageDXGIImpl.cpp",
        "patchSetId": 23
      },
      "lineNbr": 74,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-04-12T06:01:17Z",
      "side": 1,
      "message": "Thanks for the extra tests!\nI see - we still need the mutex ref. We could have the atomic would only be used for answering IsValid. But since we already have the mutex, your way is simpler.\n\nLooking at how we handle other object destruction though.. the Destroy calls do not set ObjectBase::mDevice to nullptr. Is it necessary for ExternalImageDXGI to set mBackendDevice to nullptr inside Destroy? If not, then we can always acquire the device\u0027s mutex without worrying about the device being null. This would be nice so we can avoid exposing DeviceBase::GetMutex.\n\nIsValid is odd and it\u0027s something we can reconsider when we revisit the shared image code. Its original intent was not for the purpose of checking IsValid, then doing something else with the image. The reason it exists is because sunnyps@ added it so that ExternalImageDXGI can outlive the device in a cache. Chrome needs to know when to remove ExternalImageDXGI from the cache (when the device it was created from has been destroyed or lost all external references). It means that ExternalImageDXGI is ~kinda like a weak ref where IsValid returns false when the device is gone - and any further usage of it does nothing and logs an error.",
      "parentUuid": "a8ebe780_cd1ee817",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 74,
        "endChar": 58
      },
      "revId": "9cb45e9c59a440e113bcbb33a60a98ac54d3d58c",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}