{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6b57fc3a_5942bbab",
        "filename": "src/tint/type/array.cc",
        "patchSetId": 2
      },
      "lineNbr": 109,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2023-06-08T18:52:02Z",
      "side": 1,
      "message": "This API is surprising to me because we\u0027re only using _part_ of the `invalid` input. So `invalid` isn\u0027t the value that gets returned if `Elements` cannot be computed, but rather, `invalid` contains _parts_ of things that will get returned if those parts cannot be computed. A bit weird.",
      "range": {
        "startLine": 109,
        "startChar": 13,
        "endLine": 109,
        "endChar": 31
      },
      "revId": "366b65dc258316cc8d5dee329f37d12b01838b42",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79fd9199_67d3306a",
        "filename": "src/tint/type/array.cc",
        "patchSetId": 2
      },
      "lineNbr": 109,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-06-08T19:21:31Z",
      "side": 1,
      "message": "Updated the documentation to make this behaviour clearer.",
      "parentUuid": "6b57fc3a_5942bbab",
      "range": {
        "startLine": 109,
        "startChar": 13,
        "endLine": 109,
        "endChar": 31
      },
      "revId": "366b65dc258316cc8d5dee329f37d12b01838b42",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34e66206_83eb6891",
        "filename": "src/tint/type/struct.cc",
        "patchSetId": 2
      },
      "lineNbr": 164,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2023-06-08T18:52:02Z",
      "side": 1,
      "message": "Again this API seems weird to me as we only use `type` from `invalid`.\n\nI wonder if a better API would be to make TypeAndCount hold std::optionals for both the type and the count. Then we remove the `invalid` input, and at the call site, you use `result.type.value_or()` and `result.count.value_or()` in the cases where they may come back as unset. In cases where you expect them to always be valid, you just dereference the optional.\n\n```\nstruct TypeAndCount {\n    /// The type\n    std::optional\u003cconst Type*\u003e type{nullptr};\n    /// The count\n    std::optional\u003cuint32_t\u003e count{0};\n};\n\n...\n\nauto* ty \u003d a.Elements().type.value_or(MyType);\n\nauto c \u003d b.Elements().count.value_or(10);\n\n```",
      "range": {
        "startLine": 164,
        "startChar": 12,
        "endLine": 164,
        "endChar": 66
      },
      "revId": "366b65dc258316cc8d5dee329f37d12b01838b42",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3916e0d7_8f987b80",
        "filename": "src/tint/type/struct.cc",
        "patchSetId": 2
      },
      "lineNbr": 164,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-06-08T18:54:10Z",
      "side": 1,
      "message": "That makes usage awkward. Look at the existing usages.",
      "parentUuid": "34e66206_83eb6891",
      "range": {
        "startLine": 164,
        "startChar": 12,
        "endLine": 164,
        "endChar": 66
      },
      "revId": "366b65dc258316cc8d5dee329f37d12b01838b42",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5528a143_624f6df5",
        "filename": "src/tint/type/struct.cc",
        "patchSetId": 2
      },
      "lineNbr": 164,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-06-08T19:08:09Z",
      "side": 1,
      "message": "There are a few common usages of `ty-\u003eElements()`:\n\n1. where you want `[nullptr, 0]` if there is no element. This the the most natural thing to return, hence why its defaulted.\n2. where you want `[ty, 1]` if there is no element. This was the old behaviour, and works well if you want to expand a vector, or treat it as a scalar.\n3. The separation of default-type from default-count is handy for specifying a default for `array-\u003eElements()`, so you can pick `0` or `1` for runtime sized arrays.",
      "parentUuid": "3916e0d7_8f987b80",
      "range": {
        "startLine": 164,
        "startChar": 12,
        "endLine": 164,
        "endChar": 66
      },
      "revId": "366b65dc258316cc8d5dee329f37d12b01838b42",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a1254b2_6a8c4f9c",
        "filename": "src/tint/type/struct.cc",
        "patchSetId": 2
      },
      "lineNbr": 164,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2023-06-08T19:36:20Z",
      "side": 1,
      "message": "I see your point. I think what bothers me is the fact that we\u0027re passing in the `TypeAndCount` struct as the `invalid` arg, but this copy we pass in isn\u0027t what gets returned wholesale if part can\u0027t be determined. What if, instead, we pass in each thing as a separate argument? Like:\n\n```\nTypeAndCount Struct::Elements(const Type* type_if_invalid \u003d nullptr, size_t count_if_invalid \u003d 0) const;\n```\n\nAlmost the same, but at least the API makes clear that each part is separate.",
      "parentUuid": "3916e0d7_8f987b80",
      "range": {
        "startLine": 164,
        "startChar": 12,
        "endLine": 164,
        "endChar": 66
      },
      "revId": "366b65dc258316cc8d5dee329f37d12b01838b42",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}