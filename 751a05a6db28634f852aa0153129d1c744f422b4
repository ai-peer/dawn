{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d969f22b_7a301fa9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-13T00:37:37Z",
      "side": 1,
      "message": "here\u0027s an idea\n\neven on UMA, based on the D3D11 restrictions, we can only map readonly GPU buffers.\nWe can\u0027t map storage buffers, etc. So there will need to be a bunch of workarounds on D3D11 to make that work in the same way that UMA will work on other platforms.\nAnd, those workarounds should be written so ideally we don\u0027t have two different UMA extensions.\n\nSo instead... what about not exposing extended map usages on D3D11 at all, and instead, do some frequency tracking on uniform/vertex/index buffers to measure how often they are updated? When updated very often, they could be replaced with a DYNAMIC d3d11 buffers. And DYNAMIC buffers can have a special path in WriteBuffer.\nThen, we don\u0027t need to do anything about other types of buffers which would have expensive emulation anyway.",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6141318d_d4955e38",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-13T01:10:53Z",
      "side": 1,
      "message": "Majority of CPU map then GPU readonly buffers are still useful a lot to Graphite. That\u0027s the most common use case. Even storage buffers, Graphite also uses them as \"big\" uniform buffers, which only CPU write and GPU read. Also in the perf tests, it showed that mapping uniform/storage buffers are faster than current way we are doing:\n- i.e. mapping a memory buffer.\n- Then copy that memory buffer into D3D_USAGE_DEFAULT buffer.\n- we don\u0027t use queue.WriteBuffer in Graphite, we only use encoder.WriteBuffer and it requires another memory copy.\n\nEven so the current code only uses memory buffer for \u003c 1MB sized buffers. Larger than that, it switches to D3D_USAGE_STAGING buffers, which are even more slower than D3D_USAGE_DYNAMIC esp on UMA system like intel.\n\nThis CL doesn\u0027t change the behaviors much tbh, it just creates a new Buffer class that is useful for CPU write + GPU read cases.",
      "parentUuid": "d969f22b_7a301fa9",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04f3d094_49c378b0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-13T01:14:15Z",
      "side": 1,
      "message": "If you prefer, probably we can remove the general purpose BufferMapExtendedUsages feature. It\u0027s not used that much by Graphite anw. We could add it in future but with another name like \"UMA\" feature which might contain additional functionalities for UMA systems.",
      "parentUuid": "6141318d_d4955e38",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e46128a6_9c0c7577",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-13T01:20:31Z",
      "side": 1,
      "message": "I meant the extra features in BufferMapExtendedUsages like CPU reading a storage buffer or allowing both CPU and GPU to write to a buffer are not used that much in Graphite. We can be fine by just exposing the same restrictions for D3D11 on all platforms for now. Those extras could be moved the theoretically future \"UMA\" feature instead.",
      "parentUuid": "04f3d094_49c378b0",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "848c4997_0418c680",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-14T01:56:56Z",
      "side": 1,
      "message": "to be clear, I\u0027m not suggesting we continue with the current way of using a cpu memory buffer, and then copy that into the default buffer for usage.\n\nWebGPU will have an UMA feature, and it will support mapping for all types of buffers. I understand Graphite doesn\u0027t need mapping on all buffers, but I don\u0027t want to end up in a state where there are two eventual mapping features - where one of them is a subset that D3D11 supports. It doesn\u0027t help much to only expose the more restricted feature now, because we need to expose the full version in the future. So if we implement extended mapping usages in D3D11, it should work for all types of buffers, with emulation where needed.\nSo that means this CL plus even more buffer types and other copy paths.\n\nSo I\u0027m thinking about maybe there are alternative options for how graphite uploads data. when UMA is not supported, Graphite could use WriteBuffer to update draw buffers instead of mapping. In D3D11 this could write directly into a DYNAMIC vertex/uniform buffer.\nIf that\u0027s sufficient, then we don\u0027t need to implement extended map usages on d3d11 at all.\n\nIf some alternative approach in graphite doesn\u0027t work, this CL is fine but we need to implement mapping for the other usages too",
      "parentUuid": "e46128a6_9c0c7577",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e52e9d8_85ffb75f",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 13
      },
      "lineNbr": 101,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-13T14:33:27Z",
      "side": 1,
      "message": "Given the comment do we need the check instead of an ASSERT?",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39c1785a_bdae1d1c",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 13
      },
      "lineNbr": 151,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-13T14:33:27Z",
      "side": 1,
      "message": "super-nit: in this CL and the previous one I find it slightly weird that we declare the class far before the members as finding their definition requires much jumping around in the file. Given how simple most members functions are we could just define them inline.",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8db2c0d5_e1de095c",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 13
      },
      "lineNbr": 352,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-13T14:33:27Z",
      "side": 1,
      "message": "It seems that d3dUsage is only used for these helpers. Instead of passing an enum for the type of the child class, WDYT of passing a bitfield with the \"Capabilities\" of the child class?",
      "range": {
        "startLine": 341,
        "startChar": 0,
        "endLine": 352,
        "endChar": 1
      },
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d482f464_e064f6bc",
        "filename": "src/dawn/native/d3d11/BufferD3D11.h",
        "patchSetId": 13
      },
      "lineNbr": 176,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-14T01:56:56Z",
      "side": 1,
      "message": "if this is always initialized by the constructor, it doesn\u0027t need a default value",
      "range": {
        "startLine": 176,
        "startChar": 29,
        "endLine": 176,
        "endChar": 49
      },
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}