{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d969f22b_7a301fa9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-13T00:37:37Z",
      "side": 1,
      "message": "here\u0027s an idea\n\neven on UMA, based on the D3D11 restrictions, we can only map readonly GPU buffers.\nWe can\u0027t map storage buffers, etc. So there will need to be a bunch of workarounds on D3D11 to make that work in the same way that UMA will work on other platforms.\nAnd, those workarounds should be written so ideally we don\u0027t have two different UMA extensions.\n\nSo instead... what about not exposing extended map usages on D3D11 at all, and instead, do some frequency tracking on uniform/vertex/index buffers to measure how often they are updated? When updated very often, they could be replaced with a DYNAMIC d3d11 buffers. And DYNAMIC buffers can have a special path in WriteBuffer.\nThen, we don\u0027t need to do anything about other types of buffers which would have expensive emulation anyway.",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6141318d_d4955e38",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-13T01:10:53Z",
      "side": 1,
      "message": "Majority of CPU map then GPU readonly buffers are still useful a lot to Graphite. That\u0027s the most common use case. Even storage buffers, Graphite also uses them as \"big\" uniform buffers, which only CPU write and GPU read. Also in the perf tests, it showed that mapping uniform/storage buffers are faster than current way we are doing:\n- i.e. mapping a memory buffer.\n- Then copy that memory buffer into D3D_USAGE_DEFAULT buffer.\n- we don\u0027t use queue.WriteBuffer in Graphite, we only use encoder.WriteBuffer and it requires another memory copy.\n\nEven so the current code only uses memory buffer for \u003c 1MB sized buffers. Larger than that, it switches to D3D_USAGE_STAGING buffers, which are even more slower than D3D_USAGE_DYNAMIC esp on UMA system like intel.\n\nThis CL doesn\u0027t change the behaviors much tbh, it just creates a new Buffer class that is useful for CPU write + GPU read cases.",
      "parentUuid": "d969f22b_7a301fa9",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04f3d094_49c378b0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-13T01:14:15Z",
      "side": 1,
      "message": "If you prefer, probably we can remove the general purpose BufferMapExtendedUsages feature. It\u0027s not used that much by Graphite anw. We could add it in future but with another name like \"UMA\" feature which might contain additional functionalities for UMA systems.",
      "parentUuid": "6141318d_d4955e38",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e46128a6_9c0c7577",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-13T01:20:31Z",
      "side": 1,
      "message": "I meant the extra features in BufferMapExtendedUsages like CPU reading a storage buffer or allowing both CPU and GPU to write to a buffer are not used that much in Graphite. We can be fine by just exposing the same restrictions for D3D11 on all platforms for now. Those extras could be moved the theoretically future \"UMA\" feature instead.",
      "parentUuid": "04f3d094_49c378b0",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "848c4997_0418c680",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-14T01:56:56Z",
      "side": 1,
      "message": "to be clear, I\u0027m not suggesting we continue with the current way of using a cpu memory buffer, and then copy that into the default buffer for usage.\n\nWebGPU will have an UMA feature, and it will support mapping for all types of buffers. I understand Graphite doesn\u0027t need mapping on all buffers, but I don\u0027t want to end up in a state where there are two eventual mapping features - where one of them is a subset that D3D11 supports. It doesn\u0027t help much to only expose the more restricted feature now, because we need to expose the full version in the future. So if we implement extended mapping usages in D3D11, it should work for all types of buffers, with emulation where needed.\nSo that means this CL plus even more buffer types and other copy paths.\n\nSo I\u0027m thinking about maybe there are alternative options for how graphite uploads data. when UMA is not supported, Graphite could use WriteBuffer to update draw buffers instead of mapping. In D3D11 this could write directly into a DYNAMIC vertex/uniform buffer.\nIf that\u0027s sufficient, then we don\u0027t need to implement extended map usages on d3d11 at all.\n\nIf some alternative approach in graphite doesn\u0027t work, this CL is fine but we need to implement mapping for the other usages too",
      "parentUuid": "e46128a6_9c0c7577",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e9b1a5af_7dcd6bdc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-14T23:14:59Z",
      "side": 1,
      "message": "`WriteBuffer` is only great if we assume the client side always has another copy of the data ready. So the client would then only need to call `WriteBuffer(data)` to update the buffer.\n\nThat\u0027s not always the case. Sometimes Graphite needs to map a buffer, computes values on the fly then writes directly via the mapped pointer instead of writing to an intermediate memory buffer. The latter is basically the same as using CPU memory buffer then uploading anw.\n\nI feel like having tiered features is not that bad. D3D12, even metal which is supposed to be the simplest modern API also has that.\n\nOtherwise I can make general purposes mapping work in D3D11. The other mapping usages would need extra copies but theoretically they shouldn\u0027t be too bad.\nFor example,\n- For writing on GPU to a CPU writable buffer, we can issue a copy after GPU works. The MapAsync will guarantee that the mapping would only be ready by the time the GPU writes + GPU copy are completed -\u003e no stall.\n- Similarly, for supporting `CopyDst` on a CPU writable buffer, a intermediate staging buffer would be needed:\n  - CopyB2B(dst\u003ddynamic buffer) -\u003e Copy to a staging buffer -\u003e tracked by serial -\u003e MapAsync ready -\u003e map staging buffer for read -\u003e map dynamic buffer with DISCARD flag -\u003e copy data to dynamic buffer -\u003e there won\u0027t be any stall.",
      "parentUuid": "848c4997_0418c680",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bcb65db7_d82230ac",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-17T23:40:55Z",
      "side": 1,
      "message": "What if we have a version of wgpuQueueWriteBuffer that gives you back the pointer to write into? wgpu-rs has something similar. https://wgpu.rs/doc/wgpu/struct.Queue.html#method.write_buffer_with",
      "parentUuid": "e9b1a5af_7dcd6bdc",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "68b45990_8faa516d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-18T12:15:12Z",
      "side": 1,
      "message": "That would work. However we could need another special case for D3D11 if we go that route. WriteBuffer requires a buffer to have CopyDst usage. That doesn\u0027t work with D3D11_USAGE_DYNAMIC.\n\nIf we rely on heuristic such as frequency of WriteBuffer to convert a buffer to dynamic buffer, at some point after that, user might call CopyB2B to copy to the dynamic buffer. And it either wouldn\u0027t work or we would need another intermediate buffer to act as CopyDst proxy (yet one more special case).\n\nUnless we add another extension for WriteBuffer on D3D11 which doesn\u0027t require CopyDst. Then why not adding this BufferMapWriteExtendedUsages extension instead?",
      "parentUuid": "bcb65db7_d82230ac",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a812c21a_a4bc4da0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-18T15:15:49Z",
      "side": 1,
      "message": "A WriteBufferWith is likely going to break down in multithreaded mode, and we don\u0027t have the RAII semantics that Rust has.\n\nIf you think there are reasonable simple ways to add `BufferMapWriteExtendedUsages` in D3D11 IMHO we can do that and use transfer buffers as needed. Though it seems that this CL would be step 1) and step 2) would be to add the two additional edges that you mentioned earlier.",
      "parentUuid": "bcb65db7_d82230ac",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2f60c996_10275d1f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 13
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2024-06-18T16:05:40Z",
      "side": 1,
      "message": "\u003e If you think there are reasonable simple ways to add BufferMapWriteExtendedUsages in D3D11 IMHO we can do that\n\nDo you mean `BufferMapExtendedUsages`? `BufferMapWriteExtendedUsages` only requires this CL. But the former will require additional changes in D3D11.",
      "parentUuid": "a812c21a_a4bc4da0",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e52e9d8_85ffb75f",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 13
      },
      "lineNbr": 101,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-13T14:33:27Z",
      "side": 1,
      "message": "Given the comment do we need the check instead of an ASSERT?",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39c1785a_bdae1d1c",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 13
      },
      "lineNbr": 151,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-13T14:33:27Z",
      "side": 1,
      "message": "super-nit: in this CL and the previous one I find it slightly weird that we declare the class far before the members as finding their definition requires much jumping around in the file. Given how simple most members functions are we could just define them inline.",
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8db2c0d5_e1de095c",
        "filename": "src/dawn/native/d3d11/BufferD3D11.cpp",
        "patchSetId": 13
      },
      "lineNbr": 352,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-13T14:33:27Z",
      "side": 1,
      "message": "It seems that d3dUsage is only used for these helpers. Instead of passing an enum for the type of the child class, WDYT of passing a bitfield with the \"Capabilities\" of the child class?",
      "range": {
        "startLine": 341,
        "startChar": 0,
        "endLine": 352,
        "endChar": 1
      },
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d482f464_e064f6bc",
        "filename": "src/dawn/native/d3d11/BufferD3D11.h",
        "patchSetId": 13
      },
      "lineNbr": 176,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-14T01:56:56Z",
      "side": 1,
      "message": "if this is always initialized by the constructor, it doesn\u0027t need a default value",
      "range": {
        "startLine": 176,
        "startChar": 29,
        "endLine": 176,
        "endChar": 49
      },
      "revId": "751a05a6db28634f852aa0153129d1c744f422b4",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}