{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "85662f31_80de1a79",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-10T06:07:33Z",
      "side": 1,
      "message": "[1] where do you see that the spec says to check this first, such that an OOM error would be raised and no validation error?\n\nim wondering if it would be possible for us to simply the implementation such that we always raise the validation error if there is one, and then afterward check the OOM error",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa58ecce_05ce6157",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-11T07:10:55Z",
      "side": 1,
      "message": "According to SPEC, we should first check if there is OOM on the content timeline when mappedAtCreation \u003d\u003d true, then validate BufferDescriptor on the device timeline, so",
      "parentUuid": "85662f31_80de1a79",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdffb753_ceaea276",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-11T07:12:11Z",
      "side": 1,
      "message": "Sry I forgot to clear this reply. Please ignore it.",
      "parentUuid": "aa58ecce_05ce6157",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0a448ef_4afc61e7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 14,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-15T01:01:37Z",
      "side": 1,
      "message": "\u003e im wondering if it would be possible for us to simply the implementation such that we always raise the validation error if there is one, and then afterward check the OOM error\n\nI think this is valid to do in the device timeline. The content-timeline OOM would result in an exception, so in a sense it happens before even triggering device-timeline validation.",
      "parentUuid": "fdffb753_ceaea276",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3bd138ac_43b662d9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-09T02:19:07Z",
      "side": 1,
      "message": "Hi Corentin, Austin and Kai,\n\nI\u0027ve rebased this CL. PTAL, thanks!",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "285382d9_f630d167",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1217,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-10T06:07:33Z",
      "side": 1,
      "message": "my worry is that here and the mappedAtCreation check, we\u0027re baking in buffer mapping details of the wire into CreateErrorBuffer. methods in Dawn native should make sense without dawn wire in the picture.\n\nI\u0027m wondering if in this function, instead we always check the validation error first (see [1]) and then check for other errors. other errors could be passed inside the descriptor or as a chained struct indicating the error reason. see also [2])",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a8305826_4e59740e",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1445,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-10T06:07:33Z",
      "side": 1,
      "message": "instead of adding this method, could we move the deprecation warning into ValidateBufferDescriptor?",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9925c6ab_3517667c",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1445,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-11T07:10:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a8305826_4e59740e",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30470647_c66c8462",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1445,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-11T07:12:11Z",
      "side": 1,
      "message": "Sry I forgot to clear this reply.",
      "parentUuid": "9925c6ab_3517667c",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d262876_a3dec99a",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 38,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-10T06:07:33Z",
      "side": 1,
      "message": "[2] instead of inject error here, what if we put the error reason as a chained struct on the buffer descriptor?\nwe would handle the error in dawn::native where we can decide whether to surface the OOM or another error (like validation errors).\nthe other benefit of this is that we can use dawn::native\u0027s good error message formatting.",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bad3e5dc_3e152751",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-10T05:49:52Z",
      "side": 1,
      "message": "I don\u0027t think InjectError is really any different from generating an error in DeviceBase::APICreateErrorBuffer. Both are WebGPU errors (reported asynchronously, can be caught by error scopes). So I\u0027m not sure why we need to InjectError if mappedAtCreation is true, but generate an error inside DeviceBase::APICreateErrorBuffer if it\u0027s false.\n\nThe thing that\u0027s different about mappedAtCreation, from a JS application perspective, is whether the createBuffer call can throw an exception (https://dawn-review.googlesource.com/c/dawn/+/106840/comments/21f18b0a_11970022). If it throws an exception, we shouldn\u0027t _also_ InjectError a WebGPU error.",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0f0d266_74b01585",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-10T05:49:52Z",
      "side": 1,
      "message": "nit: I believe this is a real OOM condition, so better to say something like \"Failed to allocate memory for buffer mapping\".",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62e49e6c_a0859644",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-10T06:25:39Z",
      "side": 1,
      "message": "to confirm: is the part that can throw an exception the CreateByteDataBlock part of \"initialize an active buffer mapping\"\n\nreading that, it seems like what we should be doing is asking the embedder to create the buffer allocation shmem, and then pass that into the wire to get wrapped as a WGPUBuffer. that way it can fail before we get to creating a WGPUBuffer. right now the shmem gets allocated inside deviceCreateBuffer which is too late. we\u0027d have to return nullptr which is not ideal.\n\n[3] I suppose for now we can return nullptr and rework this in the future?",
      "parentUuid": "bad3e5dc_3e152751",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66edc76c_176758b9",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-11T00:40:09Z",
      "side": 1,
      "message": "If we can return a nullptr WGPUBuffer here (and send nothing to the wire server) then I think that would be fine, though I don\u0027t think Corentin was convinced in that other thread. In theory we want some kind of native API answer for fallible allocation in mappedAtCreation but",
      "parentUuid": "62e49e6c_a0859644",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59326ebd_c354495f",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-11-11T06:53:09Z",
      "side": 1,
      "message": "IIUC, Corentin\u0027s reservations are about the service side returning nullptr without the client side knowing. that\u0027s not the case here - the client is returning nullptr, and in that situation (all the ones were we currently InjectError), we wouldn\u0027t need to send any messages to the server (so no duplicate errors)\n\nas I said above, I think this would be better done by having a separate method to make the mapped buffer, and then wrap that as a buffer - but that can be reworked in the future.\nreturning nullptr in the client should be enough to get us spec compliant",
      "parentUuid": "66edc76c_176758b9",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "261dd878_bebc2756",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2022-11-11T07:10:55Z",
      "side": 1,
      "message": "Hi Austin, do you mean we should\n1. return nullptr directly at wire client when OOM happens and mappedAtCreation \u003d\u003d true\n2. put a structure with information about OOM at client to ChainedStruct at BufferDescriptor when OOM happens and mappedAtCreation \u003d\u003d false",
      "parentUuid": "59326ebd_c354495f",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e823a723_8233edcd",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 64,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-15T01:01:37Z",
      "side": 1,
      "message": "Seems part of my last reply got lost, sorry.\n\n\u003e to confirm: is the part that can throw an exception the CreateByteDataBlock part of \"initialize an active buffer mapping\"\n\nYes.\n\n\u003e In theory we want some kind of native API answer for fallible allocation in mappedAtCreation but\n\n... we don\u0027t need to figure that out immediately.\n\n\u003e as I said above, I think this would be better done by having a separate method to make the mapped buffer, and then wrap that as a buffer - but that can be reworked in the future.\n\u003e returning nullptr in the client should be enough to get us spec compliant\n\nAgreed.\n\n@jiawei.shao@intel.com I think that makes the most sense to me.",
      "parentUuid": "261dd878_bebc2756",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f91f3f0f_4bc618e3",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 6
      },
      "lineNbr": 80,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2022-11-10T05:49:52Z",
      "side": 1,
      "message": "nit: \"Failed to allocate memory for buffer mapping\"",
      "revId": "fb432c705e92a4daadd9015a0e0393ac6f531abe",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}