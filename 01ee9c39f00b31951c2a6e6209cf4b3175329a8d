{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d75f64bc_b0f3b24f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-03-05T02:39:38Z",
      "side": 1,
      "message": "PTAL",
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3b626fb_942a629b",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 197,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-03-05T03:54:05Z",
      "side": 1,
      "message": "hi @enga@chromium.org\nIs it safe to call Device::ConsumedError() with the mBufferOrEarlyStatus locked? And is it called with device lock?",
      "range": {
        "startLine": 197,
        "startChar": 44,
        "endLine": 197,
        "endChar": 57
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "acec2088_e38828a4",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 197,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-03-05T23:52:58Z",
      "side": 1,
      "message": "it\u0027s probably better to save the MaybeError into a variable outside the `mBufferOrEarlyStatus` scope. This way you derisk a deadlock if ConsumedError calls an error callback which then goes and touches the buffer again.\n\nalso, you do need to acquire the device lock here before calling ConsumedError.\n\nSecondly, for this, it\u0027s probably better to split the call to FinalizeMapAsync and ConsumedError. That way we don\u0027t need to lock if there is no error.\n\n```\nauto maybeError \u003d (*buffer)-\u003eFinalizeMapAsync();\nif (maybeError.IsError()) {\n  auto deviceLock(GetDevice()-\u003eGetScopedLock());\n  GetDevice()-\u003eConsumedError(std::move(maybeError));\n}\n```",
      "parentUuid": "e3b626fb_942a629b",
      "range": {
        "startLine": 197,
        "startChar": 44,
        "endLine": 197,
        "endChar": 57
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67c5e777_358cbd9a",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 197,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-03-06T11:16:00Z",
      "side": 1,
      "message": "Thanks, really helpful! One more thing needs your clarification.\nAs we need the device lock for `ConsumedError`, and probably `FinalizeMapAsync`. Even likely the buffer state changes here should have been within the device lock. So we will be holding 2 locks simultaneously. As `UnmapEarly(...)` below may hold the same 2 locks in another thread. To avoid circular deadlock, we should request the locks in the same order. So we need a device lock before the `mBufferOrEarlyStatus` here. Is my understanding right?",
      "parentUuid": "acec2088_e38828a4",
      "range": {
        "startLine": 197,
        "startChar": 44,
        "endLine": 197,
        "endChar": 57
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1e97a33_2a982df5",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 197,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-03-06T14:58:28Z",
      "side": 1,
      "message": "As my understanding, `wgpu::Device` should be thread-safe (external synchronization is not needed). Other objects are not necessary to be thread-safe (external synchronization is needed). So the device lock is used for protecting data in `wgpu::Device`, and `FinializeMapAsync()` doesn\u0027t need the device lock.",
      "parentUuid": "67c5e777_358cbd9a",
      "range": {
        "startLine": 197,
        "startChar": 44,
        "endLine": 197,
        "endChar": 57
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5f714b9_2ae4c5d6",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 197,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-03-07T22:42:05Z",
      "side": 1,
      "message": "Since we have to hold the device lock for all buffer API call, probably we don\u0027t need a separate lock for `mBufferOrEarlyStatus`. We just need to assert the device lock is acquired  before accessing `mBufferOrEarlyStatus`. right?",
      "parentUuid": "e1e97a33_2a982df5",
      "range": {
        "startLine": 197,
        "startChar": 44,
        "endLine": 197,
        "endChar": 57
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eff550be_2cf147fe",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 197,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-03-08T01:15:26Z",
      "side": 1,
      "message": "Yes, I think so. That\u0027s basically to say, we acquire a scoped device lock in `Complete`, and assert the device lock `IsLockedByCurrentThread` in `UnmapEarly`.\nThere could never be a chance for`ConsumedError` to call this `Complete` recursively, right? @enga@chromium.org",
      "parentUuid": "e5f714b9_2ae4c5d6",
      "range": {
        "startLine": 197,
        "startChar": 44,
        "endLine": 197,
        "endChar": 57
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b76ef595_85567609",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 197,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-03-08T06:33:09Z",
      "side": 1,
      "message": "yes, it shouldn\u0027t be called recursively.\n\nthat said, all this lock stuff is getting quite complicated. I think what we need now is to more clearly synchronize mutations to the buffer state by making it atomic. Note that there are already some TODOs in this code about fixing it.\nI suggest we do one of the following:\n - fix up the buffer state transitions to be thread safe without needing the device lock first, then come back and introduce FinalizeMapAsync()\nOR\n - introduce FinalizeMapAsync() but only take the device lock around ConsumedError. Leave the same TODOs about making buffer state thread-safe, and we fix that after.\n \nEither of these orderings should simplify things such that we don\u0027t have as complicated nested locks.\n\nAnother thing that would greatly help our situatiom here would be to split out the parts of ConsumedError into an \"error handling service\" on the device that is internally synchronized. Once that service is thread-safe, then we don\u0027t need to worry about acquiring the device lock to perform ConsumedError. See for example, how the D3D12 device has a lot of MutexProtected subservices that it provides.\n```\n    std::unique_ptr\u003cMutexProtected\u003cStagingDescriptorAllocator\u003e\u003e mRenderTargetViewAllocator;\n    std::unique_ptr\u003cMutexProtected\u003cStagingDescriptorAllocator\u003e\u003e mDepthStencilViewAllocator;\n    std::unique_ptr\u003cMutexProtected\u003cShaderVisibleDescriptorAllocator\u003e\u003e\n        mViewShaderVisibleDescriptorAllocator;\n    std::unique_ptr\u003cMutexProtected\u003cShaderVisibleDescriptorAllocator\u003e\u003e\n        mSamplerShaderVisibleDescriptorAllocator;\n```",
      "parentUuid": "eff550be_2cf147fe",
      "range": {
        "startLine": 197,
        "startChar": 44,
        "endLine": 197,
        "endChar": 57
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d595807_b176a63f",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 842,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-03-05T03:54:05Z",
      "side": 1,
      "message": "same here. Is it called with device lock?",
      "range": {
        "startLine": 842,
        "startChar": 25,
        "endLine": 842,
        "endChar": 38
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc75b6b9_f433aff6",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 842,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-03-05T23:52:58Z",
      "side": 1,
      "message": "this one should be ok. ConsumedError does not acquire the lock itself",
      "parentUuid": "9d595807_b176a63f",
      "range": {
        "startLine": 842,
        "startChar": 25,
        "endLine": 842,
        "endChar": 38
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19578182_998f619b",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 842,
      "author": {
        "id": 1000028
      },
      "writtenOn": "2024-03-06T11:16:00Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "cc75b6b9_f433aff6",
      "range": {
        "startLine": 842,
        "startChar": 25,
        "endLine": 842,
        "endChar": 38
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40ede3fd_db541816",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 842,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-03-06T14:58:28Z",
      "side": 1,
      "message": "Sorry. I missed the `GetScopedLock()` just above.",
      "parentUuid": "19578182_998f619b",
      "range": {
        "startLine": 842,
        "startChar": 25,
        "endLine": 842,
        "endChar": 38
      },
      "revId": "01ee9c39f00b31951c2a6e6209cf4b3175329a8d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}