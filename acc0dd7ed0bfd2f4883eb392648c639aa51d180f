{
  "comments": [
    {
      "key": {
        "uuid": "64951842_b8b72634",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2020-06-25T19:17:43Z",
      "side": 1,
      "message": "I wonder what situations you want to optimize. My patch at https://dawn-review.googlesource.com/c/dawn/+/23503 only optimizes the situation in which all of subresources\u0027 usages are the same. It seems that you tend to optimize more than that. For example, per array layer compresseion, per plane compression, and per entire resource compression (this is what I did at https://dawn-review.googlesource.com/c/dawn/+/23503). \n\nI don\u0027t want to do per plane compression at this moment. I don\u0027t think that it is necessary to do optimization for depth/stencil planes, which make the compress-or-not decision more complicated. And there are only two subresources. It is absolutely acceptable to iterate each subresources one by one (only two in total). If I missed other common cases of per plane situations, please let me know. For example, multiple arrays of depth/stencil textures (I don\u0027t think this is common in real world)? support Y, U, V planes for video and you need an array of Y, U, V planes (Again, a single video texture with Y, U, V planes only has 3 subresources, iteration over 3 subresources is acceptable)? Even if we do have some common cases for per plane situation, we can do this later, considering that you have no separated depth/stencil plane at all in Dawn\u0027s implementation (I think this is a clear sign that per plane situation is not important). \n\nFor per array layer compression, are these requirements common? 1) we need a big array of mipmap textures, and 2) Each time we have access to these mipmap textures per entire mipmap chains, we rarely access a single (or a part of) mip level(s). If anyone of these two assumptions is not common. Then it\u0027s not necessary to do such an optimization. For example, if we broke 1), say web devs typically don\u0027t need a lot of mipmap textures in one shot (they just need a few mipmap textures), or web devs create mipmap textures one by one. They don\u0027t need a big array to store a lot of mipmap textures. Then A big array of mipmap textures might be an uncommon case. we don\u0027t need to optimize this corner case with a lot of complexity. If we broke 2), even web devs need a big array of mipmap textures, but they access to the entire mipmap chains sometimes, then they access to a single mip level (or a part of mip levels) frequently, which means that web devs need to break the so-called per-array-layer assumption very often. Then it\u0027s not necessary to do this optimization either (we will compress and then decompress soon). You know, we can optimize the performance only if decompression is rare. So, I want to know your assessment about the situations (common or uncommon) in real world applications before we dive deep to optimize the per-array-layer situation. Well, I may misunderstood per array layer compression, please correct me if so. \n\nPer-(entire-)resource compression is needed, we have consensus on this point.",
      "range": {
        "startLine": 24,
        "startChar": 4,
        "endLine": 29,
        "endChar": 6
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d087244c_21a22731",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-06-25T20:48:11Z",
      "side": 1,
      "message": "You make good points that the number of planes is usually pretty small. I don\u0027t think we need to compress them independently right now, and overall, I don\u0027t think that we really need to track array layers independently *yet*.\n\nHowever, I do think we should keep it in mind when designing the interface so that it might be possible in the future. I think it would be reasonable for an app to have a big array of textures and use different slices at different times. Even if we \"compress and decompress soon\" we want to compress and decompress the mip chain of a single array layer instead of the entire subresource. If it were the entire subresource we could be churning alloc/dealloc of memory a lot.",
      "parentUuid": "64951842_b8b72634",
      "range": {
        "startLine": 24,
        "startChar": 4,
        "endLine": 29,
        "endChar": 6
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "476e0d9d_a3bc0152",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-06-25T16:16:32Z",
      "side": 1,
      "message": "I wonder if it\u0027s necessary to provide this. In the general case, the caller shouldn\u0027t need to know the compression level to iterate over the subresources. Perhaps I\u0027m unclear on what the size_t is. Is it computed flattened subresource index? or is it the plane index / layer index, depending on what compression arg you pass in?\n\nAlso, not sure about the \"decompresses if it needs to\" part. I can see it reasonable to iterate over subresources one-by-one without decompressing the data. We should try to avoid aggressively decompressing if we\u0027re not mutating *all* of the usages. I think we could have a non-const \".at\" method that returns a proxy object. Assigning to that proxy object would compress / decompress the data.",
      "range": {
        "startLine": 36,
        "startChar": 34,
        "endLine": 36,
        "endChar": 47
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e9e9bf1_04d13877",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-06-25T16:16:32Z",
      "side": 1,
      "message": "side note: I am happy about this being only 8-bits. I wanted to change it in a few other places as well.",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 11
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}