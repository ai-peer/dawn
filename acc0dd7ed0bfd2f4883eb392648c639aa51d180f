{
  "comments": [
    {
      "key": {
        "uuid": "64951842_b8b72634",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2020-06-25T19:17:43Z",
      "side": 1,
      "message": "I wonder what situations you want to optimize. My patch at https://dawn-review.googlesource.com/c/dawn/+/23503 only optimizes the situation in which all of subresources\u0027 usages are the same. It seems that you tend to optimize more than that. For example, per array layer compresseion, per plane compression, and per entire resource compression (this is what I did at https://dawn-review.googlesource.com/c/dawn/+/23503). \n\nI don\u0027t want to do per plane compression at this moment. I don\u0027t think that it is necessary to do optimization for depth/stencil planes, which make the compress-or-not decision more complicated. And there are only two subresources. It is absolutely acceptable to iterate each subresources one by one (only two in total). If I missed other common cases of per plane situations, please let me know. For example, multiple arrays of depth/stencil textures (I don\u0027t think this is common in real world)? support Y, U, V planes for video and you need an array of Y, U, V planes (Again, a single video texture with Y, U, V planes only has 3 subresources, iteration over 3 subresources is acceptable)? Even if we do have some common cases for per plane situation, we can do this later, considering that you have no separated depth/stencil plane at all in Dawn\u0027s implementation (I think this is a clear sign that per plane situation is not important). \n\nFor per array layer compression, are these requirements common? 1) we need a big array of mipmap textures, and 2) Each time we have access to these mipmap textures per entire mipmap chains, we rarely access a single (or a part of) mip level(s). If anyone of these two assumptions is not common. Then it\u0027s not necessary to do such an optimization. For example, if we broke 1), say web devs typically don\u0027t need a lot of mipmap textures in one shot (they just need a few mipmap textures), or web devs create mipmap textures one by one. They don\u0027t need a big array to store a lot of mipmap textures. Then A big array of mipmap textures might be an uncommon case. we don\u0027t need to optimize this corner case with a lot of complexity. If we broke 2), even web devs need a big array of mipmap textures, but they access to the entire mipmap chains sometimes, then they access to a single mip level (or a part of mip levels) frequently, which means that web devs need to break the so-called per-array-layer assumption very often. Then it\u0027s not necessary to do this optimization either (we will compress and then decompress soon). You know, we can optimize the performance only if decompression is rare. So, I want to know your assessment about the situations (common or uncommon) in real world applications before we dive deep to optimize the per-array-layer situation. Well, I may misunderstood per array layer compression, please correct me if so. \n\nPer-(entire-)resource compression is needed, we have consensus on this point.",
      "range": {
        "startLine": 24,
        "startChar": 4,
        "endLine": 29,
        "endChar": 6
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d087244c_21a22731",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-06-25T20:48:11Z",
      "side": 1,
      "message": "You make good points that the number of planes is usually pretty small. I don\u0027t think we need to compress them independently right now, and overall, I don\u0027t think that we really need to track array layers independently *yet*.\n\nHowever, I do think we should keep it in mind when designing the interface so that it might be possible in the future. I think it would be reasonable for an app to have a big array of textures and use different slices at different times. Even if we \"compress and decompress soon\" we want to compress and decompress the mip chain of a single array layer instead of the entire subresource. If it were the entire subresource we could be churning alloc/dealloc of memory a lot.",
      "parentUuid": "64951842_b8b72634",
      "range": {
        "startLine": 24,
        "startChar": 4,
        "endLine": 29,
        "endChar": 6
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3db9e858_9f57757e",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2020-06-25T21:45:47Z",
      "side": 1,
      "message": "For the per-array-layer compression/decompression, I think if we need to decompress, then we need to decompress the entire subresource (all array layer), not only decompress a single array layer. It is possible to compress/decompress a mip chain of a single array layer, but that will require a \"Compression enum\" on every array layer, not upon the entire resource (But that will make the design even more complicated). If we only has one single enum upon the entire resource like the current design, then every time we need to decompress, then we need to decompress all subresources (all layers), not a single array layer. So I pointed out that it might not be useful to do per-array-layer compression like this because it is really fragile (it might be decompressed for all subresources quite often).",
      "parentUuid": "d087244c_21a22731",
      "range": {
        "startLine": 24,
        "startChar": 4,
        "endLine": 29,
        "endChar": 6
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d001ad0c_c60662b8",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-06-26T15:30:00Z",
      "side": 1,
      "message": "## Per plane.\n\n\u003e For example, multiple arrays of depth/stencil textures (I don\u0027t think this is common in real world)?\n\n2d array depth textures are incredibly useful when doing depth cubemaps arrays for point light shadow maps. Stencil would be more rare.\n\n\u003e Even if we do have some common cases for per plane situation, we can do this later, considering that you have no separated depth/stencil plane at all in Dawn\u0027s implementation (I think this is a clear sign that per plane situation is not important). \n\nActually that\u0027s a big deficiency in Dawn that we need to fix to be WebGPU conformant. Austin has it as a task this sprint: \"Support depth-only / stencil-only aspect\" this will be important for copies, but also for depthReadOnly and stencilReadOnly https://gpuweb.github.io/gpuweb/#dom-gpurenderpassdepthstencilattachmentdescriptor-depthreadonly\n\nI think it is ok to treat each plane separately and iterator from 0 to 2 in some cases (and in most cases, iterate from 0 to 0 ^^). That matches the PerPlane compression level in this example, and maybe PerResource isn\u0027t really useful.\n\n## Per layer\n\nI think per layer compression will be important in the cases that Austin outlined, for example when there is a 2D array texture atlas that\u0027s sometimes updated with a copy. But you\u0027re right that in most cases it wouldn\u0027t be all miplevels of an array layer that are changed, but just a couple. The solution outlined here doesn\u0027t allow handling this case efficiently. We\u0027d probably need a bitset of per-arraylayer compression etc. That makes the interface more complicated so let\u0027s first design something for per-plane vs. per-subresource that forces safety of the compression, see what idioms it introduces, and then thing about per-arraylayer later.",
      "parentUuid": "3db9e858_9f57757e",
      "range": {
        "startLine": 24,
        "startChar": 4,
        "endLine": 29,
        "endChar": 6
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c6e0db6_0ae0d909",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 29,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2020-06-26T16:18:12Z",
      "side": 1,
      "message": "Hmm, if the only common situation for per plane case is 2D array depth textures for point light shadow maps. Then web devs can use Depth32Float texture format. Per my understanding, for experienced developers, it is not necessary to introduce redundant stencil plane if they only want an array of depth textures as shadow textures. They can use a real depth/stencil combined format for rendertaget\u0027s depth/stencil attachment though. If this assuption is correct, there is no stencil plane at all for this common situation. Then the only common per-plane situation falls into per-resource.",
      "parentUuid": "d001ad0c_c60662b8",
      "range": {
        "startLine": 24,
        "startChar": 4,
        "endLine": 29,
        "endChar": 6
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "476e0d9d_a3bc0152",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-06-25T16:16:32Z",
      "side": 1,
      "message": "I wonder if it\u0027s necessary to provide this. In the general case, the caller shouldn\u0027t need to know the compression level to iterate over the subresources. Perhaps I\u0027m unclear on what the size_t is. Is it computed flattened subresource index? or is it the plane index / layer index, depending on what compression arg you pass in?\n\nAlso, not sure about the \"decompresses if it needs to\" part. I can see it reasonable to iterate over subresources one-by-one without decompressing the data. We should try to avoid aggressively decompressing if we\u0027re not mutating *all* of the usages. I think we could have a non-const \".at\" method that returns a proxy object. Assigning to that proxy object would compress / decompress the data.",
      "range": {
        "startLine": 36,
        "startChar": 34,
        "endLine": 36,
        "endChar": 47
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "902d1e38_f6c15a00",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 36,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-06-26T15:30:00Z",
      "side": 1,
      "message": "That\u0027s a good point, maybe we could have Get(plane, layer, mip) and Set(plane, layer, mip, value) that do what you said? And similarly GetPlane(plane) that ASSERTS we are in the right compression level, and SetPlane(plane) that modifies the compression level for that plane. (then we have an std::bitset or std::vector\u003cbool\u003e to track the compression per plane)",
      "parentUuid": "476e0d9d_a3bc0152",
      "range": {
        "startLine": 36,
        "startChar": 34,
        "endLine": 36,
        "endChar": 47
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e9e9bf1_04d13877",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-06-25T16:16:32Z",
      "side": 1,
      "message": "side note: I am happy about this being only 8-bits. I wanted to change it in a few other places as well.",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 11
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a3d46df_6e323a6e",
        "filename": "src/common/CompressedPerSubresource.h",
        "patchSetId": 1
      },
      "lineNbr": 42,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-06-26T15:30:00Z",
      "side": 1,
      "message": "Should probably have a typedef for it though :)",
      "parentUuid": "9e9e9bf1_04d13877",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 11
      },
      "revId": "acc0dd7ed0bfd2f4883eb392648c639aa51d180f",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}