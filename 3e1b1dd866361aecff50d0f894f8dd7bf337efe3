{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d9b82748_a38b39ca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-01-16T13:28:50Z",
      "side": 1,
      "message": "LGTM with the removal of the unnecessary allocation. Thanks for the iteration!",
      "revId": "3e1b1dd866361aecff50d0f894f8dd7bf337efe3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdd00222_a5f701f7",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 9
      },
      "lineNbr": 479,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-01-16T13:28:50Z",
      "side": 1,
      "message": "This would become\n\n  PendingMappingCallback toCall;\n  \n  if (stuff) {\n    toCall \u003d WillCallMappingCallback(...);\n  }\n  \n  return std::move(toCall);",
      "revId": "3e1b1dd866361aecff50d0f894f8dd7bf337efe3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b18accc9_5cf9da84",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 9
      },
      "lineNbr": 479,
      "author": {
        "id": 1003201
      },
      "writtenOn": "2023-01-17T07:10:46Z",
      "side": 1,
      "message": "Sorry, I couldn\u0027t get well. Does it mean I don\u0027t need to use smart pointer?",
      "parentUuid": "fdd00222_a5f701f7",
      "revId": "3e1b1dd866361aecff50d0f894f8dd7bf337efe3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47061d76_65415198",
        "filename": "src/dawn/native/Buffer.cpp",
        "patchSetId": 9
      },
      "lineNbr": 479,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-01-17T12:05:34Z",
      "side": 1,
      "message": "See https://dawn-review.googlesource.com/c/dawn/+/117201/1..2 for what I mean :)",
      "parentUuid": "b18accc9_5cf9da84",
      "revId": "3e1b1dd866361aecff50d0f894f8dd7bf337efe3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fae95d14_b77cdc21",
        "filename": "src/dawn/native/Buffer.h",
        "patchSetId": 9
      },
      "lineNbr": 118,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-01-16T13:28:50Z",
      "side": 1,
      "message": "nit: This can use this helper: https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/common/NonCopyable.h;drc\u003d479dc6b7ebc7675e72d0c16441f17fc985ffbded;l\u003d33\n\nBut it seems it should use NonCopyable and implement the move semantics itself such that callback is cleared when moved from. This way there is no need to make an allocation to hold the object. Note that you\u0027ll need to implement both the move constructor and the move assignment to be correct.",
      "revId": "3e1b1dd866361aecff50d0f894f8dd7bf337efe3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e4bb8fff_51d85ff9",
        "filename": "src/dawn/native/Buffer.h",
        "patchSetId": 9
      },
      "lineNbr": 118,
      "author": {
        "id": 1003201
      },
      "writtenOn": "2023-01-17T11:00:00Z",
      "side": 1,
      "message": "Thanks, updated.",
      "parentUuid": "fae95d14_b77cdc21",
      "revId": "3e1b1dd866361aecff50d0f894f8dd7bf337efe3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1bc00145_631d8118",
        "filename": "src/dawn/native/Buffer.h",
        "patchSetId": 9
      },
      "lineNbr": 122,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-01-16T13:28:50Z",
      "side": 1,
      "message": "nit: Can we have implementations in the .cpp file? Same for the constructors / destructors. It\u0027s something we usually do so that headers are smaller and compile time don\u0027t balloon (they are already largeish :( )",
      "revId": "3e1b1dd866361aecff50d0f894f8dd7bf337efe3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cbe50b55_eb9eaf2e",
        "filename": "src/dawn/native/Buffer.h",
        "patchSetId": 9
      },
      "lineNbr": 122,
      "author": {
        "id": 1003201
      },
      "writtenOn": "2023-01-17T07:04:15Z",
      "side": 1,
      "message": "OK, I will try.\n\nBy the way, I have a question. What is the best practice to define and implement a class/structure that is used only in a certain class? (Sorry, I\u0027m still new to C++.)\n\nI used inner structure but I don\u0027t think it really needs to be or it is elegant. Using namespace?",
      "parentUuid": "1bc00145_631d8118",
      "revId": "3e1b1dd866361aecff50d0f894f8dd7bf337efe3",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}