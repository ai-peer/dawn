{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8c98496b_99abe9ad",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 68
      },
      "lineNbr": 0,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2024-03-23T01:57:13Z",
      "side": 1,
      "message": "not reviewing tonight but quick replies",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b99acfb3_73116235",
        "filename": "src/dawn/dawn.json",
        "patchSetId": 68
      },
      "lineNbr": 1529,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-23T01:43:16Z",
      "side": 1,
      "message": "Note I added these... I **think** it\u0027s fine? Needed them for consistency and also to make cases where the device lost happens when we failed requestDevice to be clear.",
      "range": {
        "startLine": 1528,
        "startChar": 12,
        "endLine": 1529,
        "endChar": 51
      },
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62d55632_0ad92ff9",
        "filename": "src/dawn/dawn.json",
        "patchSetId": 68
      },
      "lineNbr": 1529,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2024-03-23T01:57:13Z",
      "side": 1,
      "message": "Never thought about that but yeah, if the device lost callback is passed into requestDevice, then we still have to call it on rejection. Seems good.",
      "parentUuid": "b99acfb3_73116235",
      "range": {
        "startLine": 1528,
        "startChar": 12,
        "endLine": 1529,
        "endChar": 51
      },
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52f7698b_5a296c97",
        "filename": "src/dawn/dawn.json",
        "patchSetId": 68
      },
      "lineNbr": 1529,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2024-03-26T00:17:04Z",
      "side": 1,
      "message": "The fact that it\u0027s redundant is a little annoying, especially because it arises from the API not quite matching JS. We could solve it by:\n- Not calling it when requestDevice fails\n- Undoing https://github.com/webgpu-native/webgpu-headers/issues/173 and going back to SetDeviceLostCallback, BUT address the problem there by doing what JS promises do: call the callback if the device is already lost when you set it. This seems like a pain though.\n\nProbably the best option is to do what you\u0027ve done here, but I wanted to write that down.",
      "parentUuid": "62d55632_0ad92ff9",
      "range": {
        "startLine": 1528,
        "startChar": 12,
        "endLine": 1529,
        "endChar": 51
      },
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4d2aaf59_64492c79",
        "filename": "src/dawn/dawn.json",
        "patchSetId": 68
      },
      "lineNbr": 1529,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-27T00:08:28Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "52f7698b_5a296c97",
      "range": {
        "startLine": 1528,
        "startChar": 12,
        "endLine": 1529,
        "endChar": 51
      },
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a8f2943b_c0a3e6e8",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 202,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2024-03-26T00:17:04Z",
      "side": 1,
      "message": "nit: `deviceLostEvent`",
      "range": {
        "startLine": 202,
        "startChar": 10,
        "endLine": 202,
        "endChar": 15
      },
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2bb39a1a_2819c08f",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 202,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-27T00:08:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a8f2943b_c0a3e6e8",
      "range": {
        "startLine": 202,
        "startChar": 10,
        "endLine": 202,
        "endChar": 15
      },
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f2ce3e8_3d3c6482",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 203,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "[1]",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "98f163f6_5b65cc91",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 203,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-26T11:14:01Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "8f2ce3e8_3d3c6482",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a295707b_3f496205",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 275,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "I have a slight preference to have something like the following as it makes it less magic where `mDeviceLostEvent` is set:\n\nstatic Ref\u003cDeviceBase::DeviceLostEvent\u003e DeviceBase::CreateLostEvent(descriptor);\n\nThen at [1], only in the error case, do: `eventManager-\u003eTrackEvent(CreateLostEvent(desc))`.\n\nAnd then in the DeviceBase constructor set `mDeviceLostEvent` to `CreateLostEvent` and track it.",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1c9a8ed_1ec3fc5a",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 275,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "So the one thing I was trying to solve with this was avoiding creating the device lost event in the `DeviceBase` ctor, or at least the tracking of it in the `ctor`. This is particularly important because otherwise, we will have the device lost event preceed the request device event in some cases given we attempt construction of the device and pass it into the ctor of the `RequestDeviceEvent`.\n\nI think this is solvable by exposing a getter on `DeviceBase`, say `Ref\u003cTrackedEvent\u003e GetDeviceLostEvent()` or something like `void TrackDeviceLostEvent()`, and calling those after tracking the `RequestDeviceEvent`, but I wasn\u0027t convinced it was easier to follow that just having one helper that creates both a device and a `DeviceLostEvent` that matches the resulting `Device`. It\u0027s also a bit annoying if we fail `Device::Initialize` because we would\u0027ve already created the `DeviceLostEvent` via the ctor but still return an error which could cause duplicate `DeviceLostEvent`s at [1].\n\nAlso, since the `DeviceLostEvent` needs a ref to the `Device`, we would either need to set `DeviceBase::mDeviceLostEvent` in `DeviceLostEvent` ctor, or set `DeviceLostEvent::mDevice` in `DeviceBase` ctor. Either one will have a bit of magic involved.\n\nNot sure if this is compelling enough, but would be down to chat about it offline a bit more if you think there could be a better way!",
      "parentUuid": "a295707b_3f496205",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b57f9361_40912603",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 275,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-26T11:14:01Z",
      "side": 1,
      "message": "\u003e So the one thing I was trying to solve with this was avoiding creating the device lost event in the DeviceBase ctor, or at least the tracking of it in the ctor. This is particularly important because otherwise, we will have the device lost event preceed the request device event in some cases given we attempt construction of the device and pass it into the ctor of the RequestDeviceEvent.\n\nIf I understand correctly the problem is that the order of the callbacks on the client-side would be DeviceLostEvent, RequestDevice, which could be confusing for applications? Given that the device is never created (so DeviceLostEvent gets a nullptr WGPUDevice argument) maybe that\u0027s ok?\n\nOtherwise what you suggested with a getter seems simpler IMHO as it makes things very clear in the handling of error / success cases.\n\n\u003e Also, since the DeviceLostEvent needs a ref to the Device, we would either need to set DeviceBase::mDeviceLostEvent in DeviceLostEvent ctor, or set DeviceLostEvent::mDevice in DeviceBase ctor. Either one will have a bit of magic involved.\n\nMaking the device pass itself to the `DeviceLostEvent` constructor seems ok? That\u0027s a fairly common pattern. Happy to chat offline, I might be missing things.",
      "parentUuid": "c1c9a8ed_1ec3fc5a",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "147aa545_1d3c8658",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 275,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-27T00:08:28Z",
      "side": 1,
      "message": "Changed to using a factory func on `DeviceLostEvent`. I\u0027m honestly not sure if much changed though? Just some shuffling around where the code is? The setting of `DeviceBase::mDeviceLostEvent` is still buried in the factory function atm. I guess the up-side is that it\u0027s documented more in `Device.h`? I could add an explicit `DeviceBase::SetDeviceLostEvent`, but I don\u0027t see much value in that since it only happens once exactly when the `DeviceLostEvent` is created... Plus it would have to be public which just makes it feel more cluttered?\n\nI also tried the getter way, but since the getter would need to happen lazily anyways, it honestly looked identical to this?",
      "parentUuid": "b57f9361_40912603",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc3f6362_a0bb5c49",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 275,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-03-27T15:47:09Z",
      "side": 1,
      "message": "IIUC, the difference between this and the getter is that right now we have:\n\n```\n    result \u003d CreateDevice(...);\n    if (result.IsSuccess()) {\n        Ref\u003cDeviceBase\u003e device \u003d result.AcquireSuccess();\n\n        // device-\u003emLostDeviceEvent gets set inside here!\n        FutureID futureID \u003d mPhysicalDevice-\u003eGetInstance()-\u003eGetEventManager()-\u003eTrackEvent(\n            AcquireRef(new RequestDeviceEvent(\n                callbackInfo, mPhysicalDevice,\n                DeviceBase::DeviceLostEvent::Create(device.Get(), descriptor), std::move(device))));\n        return {futureID};\n    } else {\n        FutureID futureID \u003d mPhysicalDevice-\u003eGetInstance()-\u003eGetEventManager()-\u003eTrackEvent(\n            AcquireRef(new RequestDeviceEvent(\n                callbackInfo, mPhysicalDevice,\n                DeviceBase::DeviceLostEvent::Create(nullptr, descriptor), std::move(result))));\n        return {futureID};\n    }\n```\n\nthe getter would look like:\n\n```\n// DeviceBase ctor does:\n  mLostEvent \u003d DeviceLostEvent::Create(this, descriptor);\n\n// APIRequestDeviceF does\n\n    result \u003d CreateDevice(...);\n    if (result.IsSuccess()) {\n        Ref\u003cDeviceBase\u003e device \u003d result.AcquireSuccess();\n        FutureID futureID \u003d mPhysicalDevice-\u003eGetInstance()-\u003eGetEventManager()-\u003eTrackEvent(device-\u003eGetLostEvent());\n        return {futureID};\n    } else {\n        FutureID futureID \u003d mPhysicalDevice-\u003eGetInstance()-\u003eGetEventManager()-\u003eTrackEvent(\n            AcquireRef(new RequestDeviceEvent(\n                callbackInfo, mPhysicalDevice,\n                DeviceBase::DeviceLostEvent::Create(nullptr, descriptor), std::move(result))));\n        return {futureID};\n    }\n```\n\n\nIMO I do like the getter too. It also matches were the mLostEvent is set up for the DeviceBase mock constructor - so a lot more consistent",
      "parentUuid": "147aa545_1d3c8658",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca9444f6_4a96ee90",
        "filename": "src/dawn/native/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 275,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-27T18:09:52Z",
      "side": 1,
      "message": "In general, yea that\u0027s what it would look like with the minor exception that we cannot create the lost event in the `DeviceBase` ctor because we can create a `DeviceBase` and then fail `Initialize` which would cause duplicate device lost events. (That\u0027s what I meant about needing the getter to be lazy). So basically the getter would create the device exactly in the same place that we are creating the device lost for the device via the explicit factory function. Which is why I decided that the getter doesn\u0027t really provide anything at that point.\n\n(Note that we would get device lost duplicates because we are using the event dtors to make sure they are cleaned up and as long as they are created, then the dtors would run.)",
      "parentUuid": "bc3f6362_a0bb5c49",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "186a6e8c_31e37248",
        "filename": "src/dawn/native/Adapter.h",
        "patchSetId": 68
      },
      "lineNbr": 68,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "Is this every used outside of APIRequest/CreateDevice methods? It could be made private.",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d72e44f9_877c91ae",
        "filename": "src/dawn/native/Adapter.h",
        "patchSetId": 68
      },
      "lineNbr": 68,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "186a6e8c_31e37248",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75198e7b_b8bb7c72",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 68
      },
      "lineNbr": 285,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "Shouldn\u0027t this set the `mUncapturedErrorCallbackInfo` to the one in the descriptor if there is one?",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5200244b_6bf4e360",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 68
      },
      "lineNbr": 285,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "I think it does?",
      "parentUuid": "75198e7b_b8bb7c72",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b56422ac_5626ac66",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 68
      },
      "lineNbr": 285,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-26T11:14:01Z",
      "side": 1,
      "message": "Whoops.",
      "parentUuid": "5200244b_6bf4e360",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76a94f1a_80050916",
        "filename": "src/dawn/native/Device.h",
        "patchSetId": 68
      },
      "lineNbr": 170,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "Maybe add a TODO to remove this virtual when we make a mock for the adapter?",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "474e26f0_f2a5941f",
        "filename": "src/dawn/native/Device.h",
        "patchSetId": 68
      },
      "lineNbr": 170,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "76a94f1a_80050916",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f5be360_060fc360",
        "filename": "src/dawn/native/Device.h",
        "patchSetId": 68
      },
      "lineNbr": 509,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "```suggestion\n    // TODO(dawn:1702) Make this private and move the class in the implementation file when we mock the adapter.\n```",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4b182c60_96cae124",
        "filename": "src/dawn/native/Device.h",
        "patchSetId": 68
      },
      "lineNbr": 509,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1f5be360_060fc360",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a5e07e9_99d96b5d",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 68
      },
      "lineNbr": 350,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "```suggestion\n    // Handle the event now if it\u0027s spontaneous and ready.\n```",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b481fd93_11d1816c",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 68
      },
      "lineNbr": 350,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9a5e07e9_99d96b5d",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f66de2c_afc8af33",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 68
      },
      "lineNbr": 457,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2024-03-26T00:17:04Z",
      "side": 1,
      "message": "I think in a PollEvents call that clears the last progressing events, hasIncompleteEvents will be true and hasProgressingEvents will be true, but it would be more correct to return false. Probably not a huge deal though.",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "866fe478_2574d22c",
        "filename": "src/dawn/native/EventManager.cpp",
        "patchSetId": 68
      },
      "lineNbr": 457,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-27T00:08:28Z",
      "side": 1,
      "message": "Yea I realized this also when I implemented it, but since it would only be once, i.e. the next call would return false I just left it as is. I added a comment for now. I think a decent amount of extra logic would be needed to return false that one call earlier, so we could do it later on if performance is actually an issue.",
      "parentUuid": "0f66de2c_afc8af33",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aba7313f_faada137",
        "filename": "src/dawn/native/EventManager.h",
        "patchSetId": 68
      },
      "lineNbr": 76,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "nit: Why not `TrackedEvent* event`? We never use the ref. Is it to ensure that the caller holds a ref so the event doesn\u0027t get destroyed during this function call? Can we document that?",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b84fa90c_9d776709",
        "filename": "src/dawn/native/EventManager.h",
        "patchSetId": 68
      },
      "lineNbr": 76,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "Actually, I think either would work, I think I just had this because pretty much anywhere that would call this has a `Ref\u003cTrackedEvent\u003e`, not a raw pointer, so it was just easier to pass that directly than explicitly call `Get()` at the call site. WDYT?",
      "parentUuid": "aba7313f_faada137",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85c5c3ff_6a3b44fb",
        "filename": "src/dawn/native/EventManager.h",
        "patchSetId": 68
      },
      "lineNbr": 76,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-26T11:14:01Z",
      "side": 1,
      "message": "I have a slight preference to make the function signature have the semantic of what the function actually needs, and it only needs a pointer, not a ref.",
      "parentUuid": "b84fa90c_9d776709",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7baf61fe_1c7778a1",
        "filename": "src/dawn/native/EventManager.h",
        "patchSetId": 68
      },
      "lineNbr": 76,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-27T00:08:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "85c5c3ff_6a3b44fb",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a27e7ce_545d86fd",
        "filename": "src/dawn/wire/client/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 94,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2024-03-26T00:17:04Z",
      "side": 1,
      "message": "set mDevice \u003d nullptr after releasing",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "113f101a_94dbcc64",
        "filename": "src/dawn/wire/client/Adapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 94,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-27T00:08:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a27e7ce_545d86fd",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4d8b882_a2e202fb",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 68
      },
      "lineNbr": 183,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "Can we detail the reason for this change?",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9018aa29_dd653369",
        "filename": "src/dawn/wire/client/Buffer.cpp",
        "patchSetId": 68
      },
      "lineNbr": 183,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "Ah I think it\u0027s not needed anymore.",
      "parentUuid": "f4d8b882_a2e202fb",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "275e6f95_8496e9de",
        "filename": "src/dawn/wire/server/ObjectStorage.h",
        "patchSetId": 68
      },
      "lineNbr": 149,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "Won\u0027t this cause potential crashes when a pipeline ID is reverved for CreatePipelinAsync if the client starts referring to the pipeline before it is done being created (dawn::native would try to use a nullptr pipeline and crash).",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcaecea3_40d8e264",
        "filename": "src/dawn/wire/server/ObjectStorage.h",
        "patchSetId": 68
      },
      "lineNbr": 149,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "IIUC, isn\u0027t it impossible for the user to start referring to the pipeline before it\u0027s created? The user only gets the pipeline when the async callback happens? Or are you suggesting a case where a user is injecting something and doing something bad?",
      "parentUuid": "275e6f95_8496e9de",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2f8fc81_644f1b6b",
        "filename": "src/dawn/wire/server/ObjectStorage.h",
        "patchSetId": 68
      },
      "lineNbr": 149,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2024-03-26T00:17:04Z",
      "side": 1,
      "message": "I think the latter. Server has to be resilient to arbitrary inputs because of the IPC security boundary (which we fuzz).",
      "parentUuid": "bcaecea3_40d8e264",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10b1b191_a18d3b28",
        "filename": "src/dawn/wire/server/ObjectStorage.h",
        "patchSetId": 68
      },
      "lineNbr": 149,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-26T11:14:01Z",
      "side": 1,
      "message": "Yeah that was the latter, the server needs to be resilient to malicious command streams.",
      "parentUuid": "d2f8fc81_644f1b6b",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f3877288_2fb22bfe",
        "filename": "src/dawn/wire/server/ObjectStorage.h",
        "patchSetId": 68
      },
      "lineNbr": 149,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-27T00:08:28Z",
      "side": 1,
      "message": "Ok, I changed the client-side code a bit to track whether we successfully created the device and during the dtor it should properly clean up the allocations now. Lmk what you guys think.",
      "parentUuid": "10b1b191_a18d3b28",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19288091_7912e008",
        "filename": "src/dawn/wire/server/ServerAdapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 36,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-03-25T16:22:48Z",
      "side": 1,
      "message": "Another question related to eventManager, can\u0027t the server store it in the KnownAdapter since it is always going to be the ID of the instance for that adapter?",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b17567f_9ca5e406",
        "filename": "src/dawn/wire/server/ServerAdapter.cpp",
        "patchSetId": 68
      },
      "lineNbr": 36,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2024-03-25T23:53:28Z",
      "side": 1,
      "message": "Hmm that might be possible... But again I\u0027ll defer such change to a follow up since that might be true for multiple future related `Doers` atm...",
      "parentUuid": "19288091_7912e008",
      "revId": "1e4a52dca4b2ebb791f59ec029c3c43782d32e4d",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}