{
  "comments": [
    {
      "key": {
        "uuid": "0d180b6f_f9dba7c2",
        "filename": "src/dawn_native/metal/CommandBufferMTL.mm",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T08:11:08Z",
      "side": 1,
      "message": "We should only do this if the store action is store (which is the only option now but we\u0027ll have discard soon)",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e4f2a80_5e15b4e3",
        "filename": "src/dawn_native/metal/CommandBufferMTL.mm",
        "patchSetId": 9
      },
      "lineNbr": 75,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T08:55:06Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0d180b6f_f9dba7c2",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "be8fba31_fe392702",
        "filename": "src/dawn_native/metal/CommandBufferMTL.mm",
        "patchSetId": 9
      },
      "lineNbr": 672,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T08:11:08Z",
      "side": 1,
      "message": "ditto, this should only happen if the store action is store.",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "baceecbe_953fc614",
        "filename": "src/dawn_native/metal/CommandBufferMTL.mm",
        "patchSetId": 9
      },
      "lineNbr": 672,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T08:55:06Z",
      "side": 1,
      "message": "Done in [1]",
      "parentUuid": "be8fba31_fe392702",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "91114528_9f0e08b3",
        "filename": "src/include/dawn_native/DawnNative.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T08:11:08Z",
      "side": 1,
      "message": "We\u0027re going to add many more optional creation parameters over time (like memory tracking, tracing, stats reporting, and also extensions and limits...), I suggest making a DeviceDescriptor and passing it to CreateDevice (plus having it default to nullptr, and all values in DeviceDescriptor having defaults).\n\nAnother thing is that this misses the Chromium requirements:\n\u003e For Chromium, we need to be able to surface workarounds in about:gpu and override them with command line flags:\n\u003e  - Chromium must get a callback for each workaround/emulation, even if it disabled.\n\u003e  - For each workaround we should have a name, description, URL and URL text.\n\u003e  - Chromium should have a chance to override the decision Dawn took for a workaround/emulation so we can force disable or force enable from the command line.\n\nNote that the callback would likely be a pure virtual class like WorkaroundsObserver or Overrides or Chooser with default-deleted methods that are the callbacks. Also the requirements weren\u0027t clear but the callback is what should get the name, description, URL etc. so it can display it in about:gpu.",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4586984_5b80e8ef",
        "filename": "src/include/dawn_native/DawnNative.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-17T08:40:13Z",
      "side": 1,
      "message": "OK so should DeviceDescriptor be added into dawn.json?\n\nAlso, do you mean the CreateDevice() function and all the constructors of Device should be something like this:\n\nCreateDevice(const DeviceDescriptor* descriptor, WorkaroundsObserver* observer)\nDevice(const DeviceDescriptor* descriptor, WorkaroundsObserver* observer)\n\nAnd from the observer we will find out whether a workaround is enabled or not after the creation of Device? I just wonder the information about each workaround like name and description should be hard-coded and pre-defined and do not need to be added in observer.",
      "parentUuid": "91114528_9f0e08b3",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68f36a1b_fb037aa0",
        "filename": "src/include/dawn_native/DawnNative.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T09:01:04Z",
      "side": 1,
      "message": "DeviceDescriptor is before device creation so for now let\u0027s not have it in dawn.json. What I meant is that Device constructors should look like:\n\n  Device(const DeviceDescriptor* descriptor \u003d nullptr);\n\nAnd DeviceDescriptor like:\n\n  struct DeviceDescriptor {\n      WorkaroundsObserver* workaroundsObserver \u003d nullptr;\n\n      // Not now, but eventually\n      DeviceLimits limits;\n      DeviceExtensions extensions;\n  };\n\nThe need for an observer object is because dawn_native and its embedder (Chromium) need to negotiate which workarounds to use. You\u0027re right that the description URL etc could be queried separately by Chromium. We just need to be careful to not do static initialization of hashmaps but we\u0027ll see that later.",
      "parentUuid": "f4586984_5b80e8ef",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "038d21ee_d31c3221",
        "filename": "src/include/dawn_native/DawnNative.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-17T10:26:35Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "68f36a1b_fb037aa0",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04b45cc7_25a8adcf",
        "filename": "src/include/dawn_native/DawnNative.h",
        "patchSetId": 9
      },
      "lineNbr": 73,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T08:55:06Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "038d21ee_d31c3221",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "51dbab1f_ba308452",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T08:11:08Z",
      "side": 1,
      "message": "Workarounds are part of the dawn_native API so we don\u0027t need a new folder for them. They can just be next to DawnNative.h",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ecaa9fb6_a7d11587",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T08:55:06Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "51dbab1f_ba308452",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a803850d_b5c09347",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T08:11:08Z",
      "side": 1,
      "message": "Workarounds being enums allows packing them in a bitfields but we will also need to interact with them as strings. Maybe the interface outside Dawn could be with const char* and internally we use enums and bitfields?\n\nStrings are slower but they help with extensibility and not breaking compatibility as we add and remove workarounds.",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9e27c5c_38a1c806",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-17T08:40:13Z",
      "side": 1,
      "message": "So do you mean in the DeviceDescriptor we should record if we should enable a workaround or not with a Map? Map\u003cconst char*, bool\u003e?\n\nI am just considering that maybe a more common use-case should be just testing disable or enable one workarounds and leaving others \"don\u0027t care\", so in this patch I use two bitsets to specify the workarounds we really care about. What\u0027s your thought about it?",
      "parentUuid": "a803850d_b5c09347",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03ca4370_0bf50ed0",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T09:01:04Z",
      "side": 1,
      "message": "Dawn and Chromium need to be able to negotiate what to enable (if only to override Dawn\u0027s choice from Chromium command line for testing) which is why I\u0027m suggesting a callback based methods with the WorkaroundsObserver (probably should be called WorkaroundsController?). It would something like:\n\n  class WorkaroundsController {\n    public:\n      bool ShouldWorkaroundBeUsed(const char* name, bool decision) \u003d 0;\n  };\n\n  Don\u0027t care would be the same as making the function just return \"decision\"",
      "parentUuid": "a9e27c5c_38a1c806",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94035145_f7df4393",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-17T10:26:35Z",
      "side": 1,
      "message": "Got it. Thanks for your explanation!",
      "parentUuid": "03ca4370_0bf50ed0",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97050e76_ea5bb944",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T08:55:06Z",
      "side": 1,
      "message": "I implement this with a map for simplicity. With a map, we only need to care about the item in the map, and the workarounds not included in the map will be treated as \"don\u0027t care\".\n\nPTAL, thanks!",
      "parentUuid": "94035145_f7df4393",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57ffdb61_2071afcd",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-18T12:38:01Z",
      "side": 1,
      "message": "The map misses the requirement that Chromium needs to know which workarounds are used (and which ones are not used). If you don\u0027t like the virtual method thing we could have something where workarounds and features are each represented with an enum value (which we can never remove to not break compatibility). The device descriptors take a list of forceEnabledWorkarounds and forceDisabledWorkarounds. Then given a device we can ask for a list of enabled workarounds, and there are query functions to get data like description url etc for a given workaround.",
      "parentUuid": "97050e76_ea5bb944",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4e7759c_b5bb20ad",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T12:55:25Z",
      "side": 1,
      "message": "Oh in fact the map will be updated in [1] and all the information about the workarounds that are added by the driver or not will be added into the map, so when CreateDevice() returns you can get the details of each workaround that is actually being set or not.",
      "parentUuid": "57ffdb61_2071afcd",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d3df3de0_20f3af3f",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T13:15:13Z",
      "side": 1,
      "message": "I agree that we should use enums instead of strings to represent a workaround in the communication between Dawn and its caller to keep the interface simpler. \n\nThe details about a workaround (name, description, url, etc) are constant and I think we can organize all of them as a \u003cenum_of_the_workaround, details\u003e map so that we can easily query the details we need with the enum of the workaround.",
      "parentUuid": "e4e7759c_b5bb20ad",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7216303b_3f9573fa",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 22,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-19T07:48:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d3df3de0_20f3af3f",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d2a6a6f1_2cf211ea",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 34,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T08:11:08Z",
      "side": 1,
      "message": "We should separate the two cases because they are for different backends and results in different types of code paths. No need to mention OpenGL since it doesn\u0027t need this code path.\n\nAlso Workarounds is ok for code paths that add complexity to support the base level of the API but we\u0027ll also need something for code paths that optimize using new API features (Features, should the two of them together be called CodePaths not sure.)",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9792d067_f7af1f50",
        "filename": "src/include/platform/Workarounds.h",
        "patchSetId": 9
      },
      "lineNbr": 34,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T08:55:06Z",
      "side": 1,
      "message": "Done\nThis patch will only handle Metal issue.",
      "parentUuid": "d2a6a6f1_2cf211ea",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "09ab68df_79a957d0",
        "filename": "src/tests/end2end/MultisampledRenderingTests.cpp",
        "patchSetId": 9
      },
      "lineNbr": 514,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T08:11:08Z",
      "side": 1,
      "message": "I have concerns that this duplicates the number of test for all backends even those who don\u0027t care about the workaround. This gets even worse as more workarounds are added because the number of test runs grows in NxM.\n\nThe test template parameter could be a new class that has constructors from dawn_native::BackendType but also other constructors so we can do the ForceWorkaround(MetalBackend, \"copy_for_nonzero_subresource_resolve\").",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa21d2bf_dfd780fc",
        "filename": "src/tests/end2end/MultisampledRenderingTests.cpp",
        "patchSetId": 9
      },
      "lineNbr": 514,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-17T08:40:13Z",
      "side": 1,
      "message": "I add this duplicates because I think it necessary to test both with and without user-set workarounds on Metal, and it is also necessary to ensure the newly added workarounds won\u0027t affect other backends.\n\nActually you can test multiple workarounds in one run through setting multiple flags in DawnTestOptions, so it seems we don\u0027t need to run NxM tests.",
      "parentUuid": "09ab68df_79a957d0",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c9175b06_f65f78ed",
        "filename": "src/tests/end2end/MultisampledRenderingTests.cpp",
        "patchSetId": 9
      },
      "lineNbr": 514,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-17T08:46:17Z",
      "side": 1,
      "message": "Also I find if I call DAWN_INSTANTIATE_TEST twice with same tests, I will get compile errors. For example:\n\nDAWN_INSTANTIATE_TEST(MultisampledRenderingTest, D3D12Backend);\n\nDAWN_INSTANTIATE_TEST_WITH_OPTIONS(MultisampledRenderingTest,\n                                   kMultisampledRenderingTestOptions,\n                                   D3D12Backend);\n\nWill get \"error : redefinition of \u0027gtest_MultisampledRenderingTest_EvalGenerator_\u0027\" error, so I failed to find a better way to run the test twice on Metal backends with and without the workaround.. sorry about that.",
      "parentUuid": "fa21d2bf_dfd780fc",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7916baad_3fd8b452",
        "filename": "src/tests/end2end/MultisampledRenderingTests.cpp",
        "patchSetId": 9
      },
      "lineNbr": 514,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-17T09:01:04Z",
      "side": 1,
      "message": "\u003e I add this duplicates because I think it necessary to test both with and without user-set workarounds on Metal, and it is also necessary to ensure the newly added workarounds won\u0027t affect other backends.\n\nCorrect, but I don\u0027t think we need to test that the workarounds do nothing on other backends.\n\n\u003e Actually you can test multiple workarounds in one run through setting multiple flags in DawnTestOptions, so it seems we don\u0027t need to run NxM tests.\n\nFor testing my thinking was that it would be best to test things separately, and only test combinations if we expect there are interactions.\n\nWith the comment above we should be able to do this:\n\n  DAWN_INSTANTIATE_TEST(D3D12Backend, MetalBackend, ForceWorkaround(MetalBackend, \"copy_for_nonzero_subresource_resolve\"), OpenGLBackend, VulkanBackend);",
      "parentUuid": "c9175b06_f65f78ed",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "136eff90_bfdabb28",
        "filename": "src/tests/end2end/MultisampledRenderingTests.cpp",
        "patchSetId": 9
      },
      "lineNbr": 514,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-17T10:26:35Z",
      "side": 1,
      "message": "Got it. Thanks for your explanations!",
      "parentUuid": "7916baad_3fd8b452",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "76b8a15f_f4808fd7",
        "filename": "src/tests/end2end/MultisampledRenderingTests.cpp",
        "patchSetId": 9
      },
      "lineNbr": 514,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-18T08:55:06Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "136eff90_bfdabb28",
      "revId": "e1230cedb65602522c9b7e926a59b74361ef7253",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    }
  ]
}