{
  "comments": [
    {
      "key": {
        "uuid": "e6803125_51ddb2f4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 37
      },
      "lineNbr": 7,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-12-19T18:47:46Z",
      "side": 1,
      "message": "I would like to see one or more of the samples be modified to handle device removed gracefully. LoseForTesting is great but nothing beats testing with real device removed on an application that has a frameloop.",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 23
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97debb12_642c15eb",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 37
      },
      "lineNbr": 193,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-19T10:10:11Z",
      "side": 1,
      "message": "nit: AssertSuccessOrDeviceLossError?",
      "range": {
        "startLine": 193,
        "startChar": 8,
        "endLine": 193,
        "endChar": 29
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e735ad3e_7927c820",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 37
      },
      "lineNbr": 194,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-19T01:44:41Z",
      "side": 1,
      "message": "nit: Device lost for testing",
      "range": {
        "startLine": 194,
        "startChar": 50,
        "endLine": 194,
        "endChar": 61
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bec82bca_3d0e89b7",
        "filename": "src/dawn_native/Device.h",
        "patchSetId": 37
      },
      "lineNbr": 57,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-19T01:44:41Z",
      "side": 1,
      "message": "nit: This can be defined in the cpp file, it doesn\u0027t need to be in the header.",
      "range": {
        "startLine": 57,
        "startChar": 13,
        "endLine": 57,
        "endChar": 34
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62c36fe9_b581c78d",
        "filename": "src/dawn_native/Device.h",
        "patchSetId": 37
      },
      "lineNbr": 57,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-19T10:10:11Z",
      "side": 1,
      "message": "nit: And it doesn\u0027t need to be a method but can be a freestanding function.",
      "parentUuid": "bec82bca_3d0e89b7",
      "range": {
        "startLine": 57,
        "startChar": 13,
        "endLine": 57,
        "endChar": 34
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ab3101b_24140193",
        "filename": "src/dawn_native/Device.h",
        "patchSetId": 37
      },
      "lineNbr": 60,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-19T01:44:41Z",
      "side": 1,
      "message": "nit: after Acquiring the error, we need to delete it, otherwise it\u0027ll be leaked.\n\nErrorData* err \u003d maybeError.AcquireError();\nASSERT(...);\ndelete err\n\nLooks like we missed this bug previously in DeviceBase::BaseDestructor()\n\n(side note)\ncwallez@: we should make AcquireError return a unique_ptr",
      "range": {
        "startLine": 60,
        "startChar": 23,
        "endLine": 60,
        "endChar": 48
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84157278_74df96c1",
        "filename": "src/dawn_native/Device.h",
        "patchSetId": 37
      },
      "lineNbr": 60,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-19T10:10:11Z",
      "side": 1,
      "message": "Error is a Result\u003cvoid, ErrorData*\u003e so we should make all Results of pointer return unique_ptr? Let\u0027s think about how to make this happen offline. It\u0027s more complicated than it looks because of the tagged pointer mechanism used for MaybeError and ResultOrError",
      "parentUuid": "0ab3101b_24140193",
      "range": {
        "startLine": 60,
        "startChar": 23,
        "endLine": 60,
        "endChar": 48
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "072f5550_98a19be3",
        "filename": "src/dawn_native/metal/DeviceMTL.mm",
        "patchSetId": 37
      },
      "lineNbr": 304,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-12-19T18:47:46Z",
      "side": 1,
      "message": "Since mLossStatus is defined in the base class, I think it is best to have it own setting the variable in the right places like we do for \u0027LoseForTesting\u0027. \n\nHence, we we should add a Destroy in the base class and have these callsites call it as the last thing they do. DeviceBase::Destroy should set mLossStatus to AlreadyLost.",
      "range": {
        "startLine": 304,
        "startChar": 8,
        "endLine": 304,
        "endChar": 46
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f75b93af_7213d8f0",
        "filename": "src/dawn_native/vulkan/DeviceVk.cpp",
        "patchSetId": 37
      },
      "lineNbr": 748,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-19T01:44:41Z",
      "side": 1,
      "message": "Comment, but not for this CL:\n\nRight now, wgpu::ErrorType::DeviceLost doesn\u0027t differentiate between fatal errors we don\u0027t know how to handle, and real VK_ERROR_DEVICE_LOST.\n\nIf we lost the device for real, we\u0027re going to want to NOT do stuff like fn.DestroyCommandPool, fn.DestroyDevice, etc..",
      "range": {
        "startLine": 748,
        "startChar": 8,
        "endLine": 748,
        "endChar": 42
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ff2f9f15_5f69ecd2",
        "filename": "src/dawn_native/vulkan/DeviceVk.cpp",
        "patchSetId": 37
      },
      "lineNbr": 748,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-19T10:10:11Z",
      "side": 1,
      "message": "There\u0027s few things that we need to change on a real device loss because we are manipulating the driver\u0027s CPU side allocations.\n\nThat said we don\u0027t know the difference between a real device loss and \"we got an error we don\u0027t know how to handle\". We\u0027ll probably need to differentiate between them in the future.",
      "parentUuid": "f75b93af_7213d8f0",
      "range": {
        "startLine": 748,
        "startChar": 8,
        "endLine": 748,
        "endChar": 42
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9cb609de_62c3afc2",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 37
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-12-19T10:10:11Z",
      "side": 1,
      "message": "Again, this is testing few of the important interactions:\n\n\u003e Third what we should check for are the following after device.LoseForTesting (in different test cases):\n\u003e - check that the DeviceLossCallback, if set, is called. (you can use mocks like in the ErrorScopeValidationTests.cpp)\n\u003e - check that device loss cases all error scopes to resolve in a device loss.\n\u003e - check that all further error scopes resolve in a device loss\n\u003e - check that buffer mapping, createBufferMappedAsync and fence.OnCompletion (basically all callbacks) return status device loss after it.\n\nAlso we are missing device loss checks in many entrypoints, please go through all methods in dawn.json to make sure they handle device loss. What we could do is instead of validating by hand everywhere in sub-objects, we could change ValidateObject\u0027s device check to check against a copy of \"this\" stored in \"this\" but on device loss, change it to nullptr so the check fail (and when it fails then deduce the correct error). Then the only additional loss checks we need to do are for device methods.\n\nAlso we\u0027ll likely need device loss handling in backend-specific functions like WrapImage etc.",
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c78c7bf_6900ace8",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 37
      },
      "lineNbr": 0,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2019-12-19T18:47:46Z",
      "side": 1,
      "message": "What if we add a call to ValidateIsAlive in the body of ValidateObject?  \n\nIf we plan to add additional entry point validation in the future, perhaps now is the time to create a ValidateEntrypoint method to DeviceBase which, for now, only calls ValidateIsAlive. Then, you only need to pay the cost of finding entrypoints once as part of this change.",
      "parentUuid": "9cb609de_62c3afc2",
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "42adada9_757af000",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 37
      },
      "lineNbr": 59,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-19T01:44:41Z",
      "side": 1,
      "message": "nit: We don\u0027t need this in the TEST_P block -- we can just DAWN_SKIP_TEST_IF(UsesWire()) in TestSetUp() and that will skip all of these as well.",
      "range": {
        "startLine": 59,
        "startChar": 4,
        "endLine": 59,
        "endChar": 34
      },
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4e7513a8_b26b0390",
        "filename": "src/tests/end2end/DeviceLostTests.cpp",
        "patchSetId": 37
      },
      "lineNbr": 87,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2019-12-19T01:44:41Z",
      "side": 1,
      "message": "nit: Also test, that stuff like buffer.Map, buffer.Unmap, fail\n\nWe should also check that if we lose the device right after calling Map (so the callback is still in flight), the callback is called with wgpu::ErrorType::DeviceLost",
      "revId": "4b339f837909100e2019ba4d540a77359bde0051",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}