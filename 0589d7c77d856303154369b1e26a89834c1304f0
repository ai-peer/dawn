{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "65068eb2_dc825e1d",
        "filename": "src/tint/utils/result.h",
        "patchSetId": 5
      },
      "lineNbr": 35,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-05-24T17:33:28Z",
      "side": 1,
      "message": "This reminds me a lot of llvm::Expected (which is based on many other proposals). See: https://weliveindetail.github.io/blog/post/2017/10/22/llvm-expected.html\n\nI think there are some design ideas from there that we should consider. For example, llvm::Expected::takeError() returns a pointer to the error object, if it\u0027s an error, or nullptr. I\u0027m not a fan of the UB Get() and Failure() functions in this class. I would make these safely return pointers, instead so we can write conditionals like:\n\n```\nif (auto* g \u003d r.Get()) {\n  ...\n}\n```\nor\n```\nif (auto* f \u003d r.Failure()*) {\n  ...\n}\n```\n\nWith that, we wouldn\u0027t need `operator-\u003e`, and `operator bool()` can be written in terms of `Get() !\u003d nullptr`.\n\nIn other words, let\u0027s not make this type too smart. Also, I\u0027m not sure about calling it `Result`. I like `Expected` because it conveys that we expect it to be a certain value type, otherwise it\u0027s an error. There\u0027s also `llvm::ErrorOr\u003c\u003e` which is similar, but puts the idea that it might be an error first.",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 35,
        "endChar": 13
      },
      "revId": "0589d7c77d856303154369b1e26a89834c1304f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c861732_a1ddedd3",
        "filename": "src/tint/utils/result.h",
        "patchSetId": 5
      },
      "lineNbr": 35,
      "author": {
        "id": 1002421
      },
      "writtenOn": "2022-05-24T18:53:43Z",
      "side": 1,
      "message": "I really would prefer to avoid returning pointers here, as I don\u0027t think this grants you any additional safety - you\u0027re just pushing the problem out to all the callers, and now you have a bunch of `*` smell for dereferencing.\n\nThe shape of this type is based on Tint\u0027s existing `wgsl::ParserImpl::Expect` and `wgsl::ParserImpl::Maybe`:\nhttps://dawn.googlesource.com/dawn/+/refs/heads/main/src/tint/reader/wgsl/parser_impl.h\n\nand matches the general shape of `std::optional`.\n\nFWIW, for most of our builds, doing the Wrong Thingâ„¢ will immediately explode as a `std::bad_variant_access` (or the no-exception alternative). The error given is obvious, pointing you at the place where you\u0027ve done the wrong thing (i.e. `Get()` is on the callstack). The pointer approach means `Get()` is not on the callstack, and you may have propagated the pointer somewhere else (passed to a function, etc).\n\nTo revisit another point you make:\n\n\u003e  I would make these safely return pointers, instead so we can write conditionals like:\n\nThat\u0027s what the `operator bool()` and `operator !()` is for. Examples:\n\n```\nif (auto val \u003d FunctionThatReturnsResult()) {\n  // Success\n} else {\n  // Failure\n}\n```\n\n\n```\nauto val \u003d FunctionThatReturnsResult();\nif (!val) {\n  return;  // Failure\n}\n// Success\n```",
      "parentUuid": "65068eb2_dc825e1d",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 35,
        "endChar": 13
      },
      "revId": "0589d7c77d856303154369b1e26a89834c1304f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72b06869_93484788",
        "filename": "src/tint/utils/result.h",
        "patchSetId": 5
      },
      "lineNbr": 35,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-05-24T20:01:27Z",
      "side": 1,
      "message": "In your examples, you don\u0027t show how after calling `operator bool()` you then need to call `operator-\u003e` or `Get()` to get at the value, which is basically doing the operation twice. This is very much like our RTTI `Is` and `As` functions: you don\u0027t call `Is\u003cType\u003e()` followed `As\u003cType\u003e()`.\n\nHaving said that, you\u0027re right that `std::optional` does offer a similar interface, though I never liked the double-access usage myself. `std::variant`, on the other hand, which is what you actually use for storage here, offers `std::get_if\u003cT\u003e` which returns a pointer, and allows the single call pattern (https://en.cppreference.com/w/cpp/utility/variant/get_if).\n\nIf you really insist on this design, then I won\u0027t say more. Just wanted to put the information out there.",
      "parentUuid": "9c861732_a1ddedd3",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 35,
        "endChar": 13
      },
      "revId": "0589d7c77d856303154369b1e26a89834c1304f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "110079e7_93293a75",
        "filename": "src/tint/utils/result.h",
        "patchSetId": 5
      },
      "lineNbr": 35,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2022-05-24T21:46:46Z",
      "side": 1,
      "message": "\u003e This is very much like our RTTI  Is  and  As  functions: you don\u0027t call `Is\u003cType\u003e()` followed  `As\u003cType\u003e()`.\n\nTrue - there might be overhead here, but I\u0027d _hope_ it\u0027s at least an order of magnitude cheaper than the RTTI cost of N vtable hits, as this is an inlined integer check, and I\u0027d really hope that the compiler would remove the redundant repeat tests. I admit I haven\u0027t looked at the disassembly though.\n\nAs you might have guessed, I\u0027m not massively fond of `std::get_if`. I feel the resort to pointers is a C-API version of `std::optional`.\n\nIdeally, we have a construct where you could say:\n\n`if(success_type val \u003d result) {`\n\nwhere `success_type` is the true unboxed type, and somehow the conditional operated on an intermediate was-it-a-success, but yeah, not doable directly.\n\n`if(success_type success; result.is(success)) {`\n\nis possible, but you\u0027ve now lost the ability to call a result-returning function in the `if` and store it to a `if`-scoped variable for the `else` / failure block.\n\n\u003e If you really insist on this design, then I won\u0027t say more. Just wanted to put the information out there.\n\nI\u0027m not going to stick my heels in the ground over this, but I\u0027m unconvinced that pointers make a substantially better API. I suspect you feel more strongly than I do, so I can try as you suggest to find compromise.",
      "parentUuid": "72b06869_93484788",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 35,
        "endChar": 13
      },
      "revId": "0589d7c77d856303154369b1e26a89834c1304f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "548a36b1_8ea52a52",
        "filename": "src/tint/utils/result.h",
        "patchSetId": 5
      },
      "lineNbr": 35,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-05-25T13:30:04Z",
      "side": 1,
      "message": "You\u0027re right that this case is not nearly as expensive as with RTTI. Btw, I\u0027m also not a fan of `std::get_if`, was just saying that `std::variant` offers the return as pointer in its API for better ergonomics. The C++ standard generally offers two APIs for most types: return as reference and throw exception if invalid, or return as pointer and return nullptr if invalid.\n\nI\u0027m fine with keeping the API this way, but I suggest we rename it to `Expect` instead of `Result`.",
      "parentUuid": "110079e7_93293a75",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 35,
        "endChar": 13
      },
      "revId": "0589d7c77d856303154369b1e26a89834c1304f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef08198e_32d1ae8c",
        "filename": "src/tint/utils/result.h",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2022-05-24T17:33:28Z",
      "side": 1,
      "message": "Although unlikely to occur, should add a static_assert that these two are not the same type.",
      "range": {
        "startLine": 85,
        "startChar": 17,
        "endLine": 85,
        "endChar": 43
      },
      "revId": "0589d7c77d856303154369b1e26a89834c1304f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "91a3ff9a_03fd8425",
        "filename": "src/tint/utils/result.h",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1002421
      },
      "writtenOn": "2022-05-24T18:53:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ef08198e_32d1ae8c",
      "range": {
        "startLine": 85,
        "startChar": 17,
        "endLine": 85,
        "endChar": 43
      },
      "revId": "0589d7c77d856303154369b1e26a89834c1304f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}