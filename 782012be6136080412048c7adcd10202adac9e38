{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "baa6f8ec_2bb6e835",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T01:38:51Z",
      "side": 1,
      "message": "LGTM",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a8fe22c_d5460034",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T01:40:21Z",
      "side": 1,
      "message": "also, maybe we should add some unittests of the serialization",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4aa460c6_55f6561f",
        "filename": "generator/dawn_json_generator.py",
        "patchSetId": 6
      },
      "lineNbr": 693,
      "author": {
        "id": 1001591
      },
      "writtenOn": "2022-03-03T01:11:08Z",
      "side": 1,
      "message": "Do we want/need support for floats here?",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b743c1f4_36757972",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1001591
      },
      "writtenOn": "2022-03-03T01:11:08Z",
      "side": 1,
      "message": "This is a nice generalization of the serialization output!\n\nNot a problem that needs to be solved now, but I feel like we\u0027re likely to hit a point in the not-so-distant future where we may want an object to have both a nice formatting for error messages AND a serialized format. It\u0027s not clear to me how we\u0027d manage that with the Abseil formatting, but something to keep in mind.",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf9c7728_a973982d",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T01:38:51Z",
      "side": 1,
      "message": "indeed. for key generation, this is currently pretty fat. We don\u0027t really need to fully stringify member names, etc. Also don\u0027t need to fully stringify enums. It is more concise to turn the enum into a number. Type names as well could be integer ids.\n\nBut, probably ok that it\u0027s fat for now until we measure it to be a big problem.",
      "parentUuid": "b743c1f4_36757972",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63415645_661f7217",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T17:48:08Z",
      "side": 1,
      "message": "hmm but basically, I\u0027m still questioning whether serializing the BGLs is what we really want to do for the cache key.\n\nI think it certainly happens to be easy and convenient because we have already have a generator for these descriptors.\n\nHowever, it would also still be easy if we generated serialization helpers for inputs to compilation. I think that\u0027s just strings, primitives, and std::maps of stuff. Seems not too bad to generate or templatize serialization for that? I also haven\u0027t tried it myself - so who knows.\nBut again, not clear from the WIP CL how you plan to use stuff, so this concern may not apply.\n\nOne example is that the tint team is talking about having a step just for Shader -\u003e Shader w/ Defines - which has fairly minimal inputs. We should make sure our caching strategy is flexible enough for stuff like that",
      "parentUuid": "bf9c7728_a973982d",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c7cdffa_d5c5723a",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-03-03T19:13:22Z",
      "side": 1,
      "message": "Hmm thought about this some more, and there\u0027s 2 separate questions here.\n\n(1) Compact serialization vs more readable serialization: One possible way I can think of is sort of \"hacky\", which is to supply another non-string (%s) formatter for the types and use that one for serialization and use %s for readable serialization, and (say) %d for cache key serialization.\n\n(2) Serialization for inputs to compilation: I am a little confused about this point. Is that referring to shaders? Or does that apply to pipelines as well? I was under the impression that the BGLs would be important for the pipelines which is why I thought I would need to serialize them (regardless of backend), and then backends can add more stuff if necessary.",
      "parentUuid": "63415645_661f7217",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87c15814_0fdf0a24",
        "filename": "src/dawn/native/BindingInfo.cpp",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T01:38:51Z",
      "side": 1,
      "message": "so this looks like:\n\nmyBindingInfoType: { ...stuff }\n\nwhat if we exclude myBindingInfoType and instead serialization of \"stuff\" (buffer binding layout, sampling binding layout, etc.) includes the name of the struct in front?\n\n\nSo \"BufferBindingLayout {  ...contents  }\"\nthen, we might not need myBindingInfoType\n\nBecause right now, the serialization of two structs, with different types, looks identical since it doesn\u0027t include the struct name. I don\u0027t think we have such structs with identical layouts, but if could be a source of obscure bugs in the future if two keys collide because they serialized in this way.",
      "range": {
        "startLine": 52,
        "startChar": 87,
        "endLine": 52,
        "endChar": 93
      },
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "163d47bf_4d2799aa",
        "filename": "src/dawn/native/BindingInfo.cpp",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-03-03T19:13:22Z",
      "side": 1,
      "message": "myBindingInfoType is actually formatted into the name of the struct via the formatter above. So we actually end up with something like what you mention already:\n\nbuffer { ..contents }\n\nsampler { .. contents }",
      "parentUuid": "87c15814_0fdf0a24",
      "range": {
        "startLine": 52,
        "startChar": 87,
        "endLine": 52,
        "endChar": 93
      },
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}