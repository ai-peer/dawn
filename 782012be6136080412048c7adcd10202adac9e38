{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "baa6f8ec_2bb6e835",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T01:38:51Z",
      "side": 1,
      "message": "LGTM",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a8fe22c_d5460034",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T01:40:21Z",
      "side": 1,
      "message": "also, maybe we should add some unittests of the serialization",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4aa460c6_55f6561f",
        "filename": "generator/dawn_json_generator.py",
        "patchSetId": 6
      },
      "lineNbr": 693,
      "author": {
        "id": 1001591
      },
      "writtenOn": "2022-03-03T01:11:08Z",
      "side": 1,
      "message": "Do we want/need support for floats here?",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b743c1f4_36757972",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1001591
      },
      "writtenOn": "2022-03-03T01:11:08Z",
      "side": 1,
      "message": "This is a nice generalization of the serialization output!\n\nNot a problem that needs to be solved now, but I feel like we\u0027re likely to hit a point in the not-so-distant future where we may want an object to have both a nice formatting for error messages AND a serialized format. It\u0027s not clear to me how we\u0027d manage that with the Abseil formatting, but something to keep in mind.",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf9c7728_a973982d",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T01:38:51Z",
      "side": 1,
      "message": "indeed. for key generation, this is currently pretty fat. We don\u0027t really need to fully stringify member names, etc. Also don\u0027t need to fully stringify enums. It is more concise to turn the enum into a number. Type names as well could be integer ids.\n\nBut, probably ok that it\u0027s fat for now until we measure it to be a big problem.",
      "parentUuid": "b743c1f4_36757972",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63415645_661f7217",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T17:48:08Z",
      "side": 1,
      "message": "hmm but basically, I\u0027m still questioning whether serializing the BGLs is what we really want to do for the cache key.\n\nI think it certainly happens to be easy and convenient because we have already have a generator for these descriptors.\n\nHowever, it would also still be easy if we generated serialization helpers for inputs to compilation. I think that\u0027s just strings, primitives, and std::maps of stuff. Seems not too bad to generate or templatize serialization for that? I also haven\u0027t tried it myself - so who knows.\nBut again, not clear from the WIP CL how you plan to use stuff, so this concern may not apply.\n\nOne example is that the tint team is talking about having a step just for Shader -\u003e Shader w/ Defines - which has fairly minimal inputs. We should make sure our caching strategy is flexible enough for stuff like that",
      "parentUuid": "bf9c7728_a973982d",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c7cdffa_d5c5723a",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-03-03T19:13:22Z",
      "side": 1,
      "message": "Hmm thought about this some more, and there\u0027s 2 separate questions here.\n\n(1) Compact serialization vs more readable serialization: One possible way I can think of is sort of \"hacky\", which is to supply another non-string (%s) formatter for the types and use that one for serialization and use %s for readable serialization, and (say) %d for cache key serialization.\n\n(2) Serialization for inputs to compilation: I am a little confused about this point. Is that referring to shaders? Or does that apply to pipelines as well? I was under the impression that the BGLs would be important for the pipelines which is why I thought I would need to serialize them (regardless of backend), and then backends can add more stuff if necessary.",
      "parentUuid": "63415645_661f7217",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1e2ffce_3f38edcf",
        "filename": "generator/templates/dawn/native/api_absl_format.h",
        "patchSetId": 6
      },
      "lineNbr": 56,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T20:11:48Z",
      "side": 1,
      "message": "(2) that\u0027s why seeing how we do the caching would be instructive. Definitely BGLs are important. But, taking current examples of how stuff works:\n\nShader translation for D3D12 takes:\n - WGSL shader\n - bunch of boolean/integer flags\n - some strings\n - version/device info\n - ArrayLengthFromUniformOptions (map produced from bindings + stuff?)\n - BindingRemapper::BindingPoints (map produced from bindings + stuff?)\n - BindingRemapper::AccessControls (map produced from bindings + stuff?)\n\nPipeline compilation:\n - bunch of enums, booleans, numbers\n - shader bytecode\n - root signature\n   - produced from BGLs, but it\u0027s also serialized to a blob https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/native/d3d12/PipelineLayoutD3D12.cpp;l\u003d258\n   \nSo there definitely is a bunch of stuff that\u0027s produced from BGLs and bindings, and so I think it would probably be sufficient to serialize the way you\u0027re doing. My question is how necessary it is. Either way, we need to generate code, or write generalized code that can serialize a bunch of stuff. It seems like it should be possible to have the data produced from BGLs get serialized instead of the BGLs themselves.\n\nIt would be more code shuffling because we need to reorganize functions like d3d12::RenderPipeline::Initialize which gets a ton of stuff from |this| and populates a D3D12_GRAPHICS_PIPELINE_STATE_DESC, to instead have a layer of indirection.\nCurrently: (inputs from |this|) -\u003e D3D12_GRAPHICS_PIPELINE_STATE_DESC\nCould be: (inputs from |this|) -\u003e (key from inputs, inputs w/out from |this|) -\u003e D3D12_GRAPHICS_PIPELINE_STATE_DESC **\n\nI think the advantage though is that it\u0027s both the precise, minimal set of things we need to serialize, and we can structurally guarantee that everything in the middle step becomes part of the key.\n\nI guess all of this depends on this hypothetical easy-to-use indirection layer that I\u0027m just assuming exists. So maybe I should try to hack up what I think it could look like. We primarily need something that works well, so I don\u0027t want to distract with \"but what if... etc.\" What do you think?\n\n**But wait! in reality we can probably just zero-initialize D3D12_GRAPHICS_PIPELINE_STATE_DESC, populate it w/out pointer members, dump that to memory, replace the root signature pointer with the serialized root signature and bytecode pointers with serialized bytecode, and prefix with the cache isolation key. And that\u0027s the entire key. Precise, and as small as possible.\nProbably not all backends can do this, so the extra layer of indirection might still be applicable for other backends.",
      "parentUuid": "7c7cdffa_d5c5723a",
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87c15814_0fdf0a24",
        "filename": "src/dawn/native/BindingInfo.cpp",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T01:38:51Z",
      "side": 1,
      "message": "so this looks like:\n\nmyBindingInfoType: { ...stuff }\n\nwhat if we exclude myBindingInfoType and instead serialization of \"stuff\" (buffer binding layout, sampling binding layout, etc.) includes the name of the struct in front?\n\n\nSo \"BufferBindingLayout {  ...contents  }\"\nthen, we might not need myBindingInfoType\n\nBecause right now, the serialization of two structs, with different types, looks identical since it doesn\u0027t include the struct name. I don\u0027t think we have such structs with identical layouts, but if could be a source of obscure bugs in the future if two keys collide because they serialized in this way.",
      "range": {
        "startLine": 52,
        "startChar": 87,
        "endLine": 52,
        "endChar": 93
      },
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "163d47bf_4d2799aa",
        "filename": "src/dawn/native/BindingInfo.cpp",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2022-03-03T19:13:22Z",
      "side": 1,
      "message": "myBindingInfoType is actually formatted into the name of the struct via the formatter above. So we actually end up with something like what you mention already:\n\nbuffer { ..contents }\n\nsampler { .. contents }",
      "parentUuid": "87c15814_0fdf0a24",
      "range": {
        "startLine": 52,
        "startChar": 87,
        "endLine": 52,
        "endChar": 93
      },
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "547bd9aa_ab4ae53a",
        "filename": "src/dawn/native/BindingInfo.cpp",
        "patchSetId": 6
      },
      "lineNbr": 52,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2022-03-03T20:32:23Z",
      "side": 1,
      "message": "that\u0027s only the case because this specific serialization comes paired with an enum. If you were to serialize SamplerBindingLayout or BufferBindingLayout by itself elsewhere, it wouldn\u0027t have that. So the concern is that it could be easy to mess it up by accident.",
      "parentUuid": "163d47bf_4d2799aa",
      "range": {
        "startLine": 52,
        "startChar": 87,
        "endLine": 52,
        "endChar": 93
      },
      "revId": "782012be6136080412048c7adcd10202adac9e38",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}