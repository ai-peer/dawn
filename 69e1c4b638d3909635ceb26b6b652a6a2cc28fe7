{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "aa1b6b51_2c8111e9",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 12
      },
      "lineNbr": 223,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-14T22:14:54Z",
      "side": 0,
      "message": "trying to see if there\u0027s a simpler solution than adding full on weak refs\n\nCan we remove the device in WillDropLastExternalRef? After that, it won\u0027t be producing any more callbacks since we Destroy() and FlushCallbackTaskQueue() - so it should no longer be necessary to track it in the instance\n\nIf we remove it from the list there, then I think?? we don\u0027t have the same issue since a race of WillDropLastExternalRef and InstanceProcessEvents happens strictly before we check if the refcount drops to zero, then call DeleteThis.",
      "range": {
        "startLine": 221,
        "startChar": 5,
        "endLine": 223,
        "endChar": 5
      },
      "revId": "69e1c4b638d3909635ceb26b6b652a6a2cc28fe7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4faba5e3_a1ea98ac",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 12
      },
      "lineNbr": 223,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-15T09:46:17Z",
      "side": 0,
      "message": "As discovered in the previous CL, people could still call something like `MapAsync` after device is dropped externally. Doing something like that will generate a `DeviceLost` error and schedule a callback to let the user know.\n\nIf we remove the device from the Instance when we drop last external ref, that\u0027s like going back to previous version, i.e. there was no way for the user to trigger the pending error related callback anymore. And the above callback will sit inside a queue managed by the (Destroyed) device forever.\n\nOfc there are other approaches to solve this:-\n- We could store the callbacks inside a queue managed by `Instance` instead. Calling `ProcessEvents` to flush this queue. However, this is like a big architecture change. I don\u0027t think it\u0027s anything simpler than the weak ref approach. This will also force any other projects (chrome, skia, examples?) that are using `device.Tick()` to change to `instance.ProcessEvents()`\nLet\u0027s say a graphite\u0027s thread is trying to map a buffer, it has to keep polling for the callback to trigger, isn\u0027t using `instance.ProcessEvents()` a bit waste? Because we only care about graphite\u0027s device on this thread, but we have to poll for other devices\u0027 callbacks as well (WebGPU\u0027s, chrome\u0027s, etc).\nFurthermore, it would carry risks because we might miss some `device.Tick()` usages in some projects/places. Hence I propose we do small step at a time 1st. Changing `instance.ProcessEvents` to just being a wrapper of `device.Tick()`, and then we can change it to have its own callbacks queue later.\n\n- Alternatively, after a device is destroyed, any callback added to its queue will be executed immediately instead of being delayed. I think this would complicate the logic unnecessarily. We are trying to isolate the callbacks\u0027 executions to single/few places like `device.Tick()`. But doing this approach means any function could trigger callbacks (if the device is already destroyed). And there is nothing stopping the user from calling the public API again in the callbacks \u003d\u003e re-entrance.",
      "parentUuid": "aa1b6b51_2c8111e9",
      "range": {
        "startLine": 221,
        "startChar": 5,
        "endLine": 223,
        "endChar": 5
      },
      "revId": "69e1c4b638d3909635ceb26b6b652a6a2cc28fe7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfa2c129_d9aec226",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 12
      },
      "lineNbr": 223,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-15T09:49:35Z",
      "side": 0,
      "message": "The weak ref approach doesn\u0027t change the existing system\u0027s behaviors, doesn\u0027t need any refactor from other code bases.",
      "parentUuid": "4faba5e3_a1ea98ac",
      "range": {
        "startLine": 221,
        "startChar": 5,
        "endLine": 223,
        "endChar": 5
      },
      "revId": "69e1c4b638d3909635ceb26b6b652a6a2cc28fe7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae5c9828_dd3cf520",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 12
      },
      "lineNbr": 223,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-15T09:57:38Z",
      "side": 0,
      "message": "I think there is another question about how `instance.ProcessEvents` should behave (in future). Do we still want `device.Tick` to trigger its own callbacks or only `instance.ProcessEvents` can do that for all devices? If it\u0027s the latter, what about use cases where users only want to poll for their own device\u0027s callbacks like the graphite example above?",
      "parentUuid": "cfa2c129_d9aec226",
      "range": {
        "startLine": 221,
        "startChar": 5,
        "endLine": 223,
        "endChar": 5
      },
      "revId": "69e1c4b638d3909635ceb26b6b652a6a2cc28fe7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3c36175_86399bc0",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 12
      },
      "lineNbr": 223,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-15T17:05:52Z",
      "side": 0,
      "message": "Agree that we should preserve existing semantics in the short term so we don\u0027t need to refactor everything now.\nIMO, eventually we will only have the callback queue on the instance. Then we don\u0027t need to track the devices as at all.\nBut you\u0027re right that it could need more consideration if graphite only wants to poll for one device. It might not be so bad though since graphite will probably use its own instance which only has one device.\nIMO I also think it\u0027ll be better if Dawn can add a no-callback API and have the \"WGPUFuture\" concept, but that needs more thought and work.\n\nHere\u0027s an alternative idea for now:\n - add a callback queue to the instance that is only used after a device has been destroyed. If the device is not lost, we add to the device\u0027s callback queue. If it is lost, we add to the instance\u0027s callback queue.\n \nIn the future we can incrementally:\n - Add a warning that applications should call instanceProcessEvents instead of deviceTick\n - in DeviceBase::WillDropLastExternalRef, move device callbacks into the instance callback queue - instead of calling them.\n - incrementally change other callsites to push callbacks into the instance queue instead of the device queue.\n - delete the device callback queue",
      "parentUuid": "ae5c9828_dd3cf520",
      "range": {
        "startLine": 221,
        "startChar": 5,
        "endLine": 223,
        "endChar": 5
      },
      "revId": "69e1c4b638d3909635ceb26b6b652a6a2cc28fe7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "743e112a_eb6552bf",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 12
      },
      "lineNbr": 223,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-15T17:16:46Z",
      "side": 0,
      "message": "\u003e add a callback queue to the instance that is only used after a device has been destroyed. If the device is not lost, we add to the device\u0027s callback queue. If it is lost, we add to the instance\u0027s callback queue.\n\nI already tried the exact idea above but it seems too error prone to me. We could change the callback queue to instance\u0027s after the device is destroyed. But it\u0027s easy to make a mistake in the code and use the device\u0027s old calback queue instead of the instance\u0027s queue.\n\nInstead I already created another but rather similar approach:\nWe could treat the device having last external ref dropped as \"zombie\" device. Once that happens, we remove its pointer from `InstanceBase` and let `InstanceBase` track its `mCallbackTaskManager`\u0027s weak reference instead.\n\nThis should work because once the device becomes \"zombie\", literally only its callbacks task queue is what we should care about, there is no need to call full-blown `Tick` anymore.\n\nHere is the alternative approach\u0027s CL: https://dawn-review.googlesource.com/c/dawn/+/124280\nWDYT.",
      "parentUuid": "f3c36175_86399bc0",
      "range": {
        "startLine": 221,
        "startChar": 5,
        "endLine": 223,
        "endChar": 5
      },
      "revId": "69e1c4b638d3909635ceb26b6b652a6a2cc28fe7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c113c3a_77a43b1d",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 12
      },
      "lineNbr": 223,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-15T18:43:14Z",
      "side": 0,
      "message": "OK, here is another simple attempt which implements the exact idea above https://dawn-review.googlesource.com/c/dawn/+/124281 (use instance\u0027s callback queue after the device is destroyed)",
      "parentUuid": "743e112a_eb6552bf",
      "range": {
        "startLine": 221,
        "startChar": 5,
        "endLine": 223,
        "endChar": 5
      },
      "revId": "69e1c4b638d3909635ceb26b6b652a6a2cc28fe7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}