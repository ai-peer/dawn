{
  "comments": [
    {
      "key": {
        "uuid": "333f1354_588915a4",
        "filename": "src/common/Math.h",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "nit: using unsigned_type \u003d typename ...",
      "range": {
        "startLine": 49,
        "startChar": 8,
        "endLine": 49,
        "endChar": 67
      },
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21ed89dd_d0c12d17",
        "filename": "src/common/Math.h",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2019-04-09T23:41:09Z",
      "side": 1,
      "message": "Instead of min, this should static_assert that the sizes are equal.",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16ab0027_b48d2c4d",
        "filename": "src/common/Math.h",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "The implementation could be in the .cpp file. Also we should use uint32_t and int32_t so that we know exactly what the bit widths are.",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6a77ff80_1dc11353",
        "filename": "src/common/Math.h",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2019-04-09T23:41:09Z",
      "side": 1,
      "message": "uint32_t and uint16_t, I think",
      "parentUuid": "16ab0027_b48d2c4d",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "63116ec9_5144f034",
        "filename": "src/common/Math.h",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2019-04-09T23:41:09Z",
      "side": 1,
      "message": "nit: sign16?",
      "range": {
        "startLine": 67,
        "startChar": 17,
        "endLine": 67,
        "endChar": 21
      },
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e640cb38_96d854d1",
        "filename": "src/common/Math.h",
        "patchSetId": 2
      },
      "lineNbr": 68,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2019-04-09T23:41:09Z",
      "side": 1,
      "message": "nit: name isn\u0027t very descriptive",
      "range": {
        "startLine": 68,
        "startChar": 17,
        "endLine": 68,
        "endChar": 20
      },
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a66aa333_c8d14dc5",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 204,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "nit: type / typeName / variableType",
      "range": {
        "startLine": 204,
        "startChar": 20,
        "endLine": 204,
        "endChar": 30
      },
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90eb86db_4aefe48f",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 228,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "Is there the same issue if we use std::to_string?",
      "range": {
        "startLine": 228,
        "startChar": 16,
        "endLine": 228,
        "endChar": 76
      },
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59b6cbd2_244212d5",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 235,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "Instead of having a separate commaPos variable, we could have the following just after the loop on j:\n\n if (j !\u003d 0) {\n   vs \u003c\u003c \", \";\n }",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28c5d9ac_cdcdb98a",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 240,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "This seems like a really big threshold, normally vertex data should be perfectly forwarded so we have at max one (or maybe two) ULP differences. If the problem is that text-based representations of the data aren\u0027t precise enough (because not all digits after the comma are written), we could upload a UBO with the expected data and have perfect forwarding of bits.",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7098e0c5_cb91e79f",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 241,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2019-04-09T06:54:14Z",
      "side": 1,
      "message": "For integer and unsigned integer vertex formats, I think you can directly compare if test is exactly equal to expected.",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c27626a_baeb29b3",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 241,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2019-04-09T06:58:26Z",
      "side": 1,
      "message": "Yes, but the code generation logic will be a bit more complicated.",
      "parentUuid": "7098e0c5_cb91e79f",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6637cf4c_cecc84d4",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 313,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "Can you explain how these numbers were chosen? max() and min() make sense but the others are just random?",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0cd3863_6dc3cfa0",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 313,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2019-04-09T01:02:07Z",
      "side": 1,
      "message": "Yes, the others are just random.",
      "parentUuid": "6637cf4c_cecc84d4",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6510c8c9_12fb6b69",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 323,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "nit: here and in other places, just pass vertexData twice :)",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb03dd85_3f9b0436",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 323,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2019-04-09T01:02:07Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "6510c8c9_12fb6b69",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eeba3f04_7d67c53c",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 323,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2019-04-09T23:41:09Z",
      "side": 1,
      "message": "marking unresolved",
      "parentUuid": "bb03dd85_3f9b0436",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce475249_07f039e2",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 399,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "We could also have a helper in this file that takes a vector and normalizes all elements, so that we can just do DoVertexFormatTest(dawn::VertexFormat::UChar2Norm, vertexData, Normalize(vertexData));",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f02ae672_c81c82d9",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 399,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2019-04-09T01:02:07Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "ce475249_07f039e2",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4676cb27_85766505",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 649,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2019-04-08T16:04:00Z",
      "side": 1,
      "message": "Can we have floats for +0, -0 (assuming exact comparison) as well as values that aren\u0027t representable in half floats? Not sure about NaN and infinites though.",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf128d63_a99db22c",
        "filename": "src/tests/end2end/VertexFormatTests.cpp",
        "patchSetId": 2
      },
      "lineNbr": 649,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2019-04-09T01:02:07Z",
      "side": 1,
      "message": "Hmm, good point. TBH, I just pick some random value to check float. I agree with you and I\u0027ll think about the value.",
      "parentUuid": "4676cb27_85766505",
      "revId": "b14bac68fc5850d2192d31a7d6fca22c8c39e8c8",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}