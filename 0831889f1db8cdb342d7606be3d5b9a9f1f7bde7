{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4e6df307_7e80a4c1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001591
      },
      "writtenOn": "2021-01-06T19:25:00Z",
      "side": 1,
      "message": "PTAL! Not sure if there\u0027s a more appropriate place in the E2E tests to put this.\n\nOn my machine it\u0027s giving me the following result:\n[ RUN      ] ComputeStorageBufferBarrierTests.ArrayAccessCrash/D3D12_NVIDIA_GeForce_GTX_1660_SUPER\nunknown file: error: SEH exception with code 0xc0000005 thrown in the test body.",
      "revId": "0831889f1db8cdb342d7606be3d5b9a9f1f7bde7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2db7c7c7_0fefcf9a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001591
      },
      "writtenOn": "2021-01-06T19:31:58Z",
      "side": 1,
      "message": "Huh! Based on the dry run, seems like this is a problem on Macs too! Wouldn\u0027t be surprised if it also fails on Linux.",
      "revId": "0831889f1db8cdb342d7606be3d5b9a9f1f7bde7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2dee9a36_fdd8f28f",
        "filename": "src/tests/end2end/ComputeStorageBufferBarrierTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T19:46:12Z",
      "side": 1,
      "message": "I\u0027m not sure if the syntax is valid or if it\u0027s a Tint translation bug. Either way it\u0027s a Tint bug - missing validation or incorrect translation.\n\nstorage_buffer requires an access(read) or access(read_write). I\u0027m not sure if that\u0027s valid on an array or if it must be on a [[block]]\n\nThe following works:\n\n        struct Particle {\n            [[offset(0)]] pos : vec2\u003cf32\u003e;\n            [[offset(8)]] vel : vec2\u003cf32\u003e;\n        };\n        [[block]] struct Buf {\n            [[offset(0)]] particles : [[stride(16)]] array\u003cParticle, 1024\u003e;\n        };\n        [[binding(0), set(0)]] var\u003cstorage_buffer\u003e buf : [[access(read_write)]] Buf;\n        [[builtin(global_invocation_id)]] var\u003cin\u003e globalId : vec3\u003cu32\u003e;\n        [[stage(compute)]] fn main() -\u003e void {\n            buf.particles[globalId.x].pos \u003d buf.particles[globalId.x].pos + buf.particles[globalId.x].vel;\n        }",
      "range": {
        "startLine": 358,
        "startChar": 8,
        "endLine": 366,
        "endChar": 9
      },
      "revId": "0831889f1db8cdb342d7606be3d5b9a9f1f7bde7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1556d8d_f5ad8bec",
        "filename": "src/tests/end2end/ComputeStorageBufferBarrierTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1001591
      },
      "writtenOn": "2021-01-06T20:29:29Z",
      "side": 1,
      "message": "I knew that the version inside a [[block]] worked. I wasn\u0027t sure if the direct array was a use case that was supposed to work or not when I filed https://bugs.chromium.org/p/dawn/issues/detail?id\u003d617. (For the record it would be convenient for developers if it did.) And sorry for missing the access type! Definitely needs validation for that.",
      "parentUuid": "2dee9a36_fdd8f28f",
      "range": {
        "startLine": 358,
        "startChar": 8,
        "endLine": 366,
        "endChar": 9
      },
      "revId": "0831889f1db8cdb342d7606be3d5b9a9f1f7bde7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7012f9d6_3c3a3ff4",
        "filename": "src/tests/end2end/ComputeStorageBufferBarrierTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-01-06T20:37:30Z",
      "side": 1,
      "message": "Yea I\u0027m not sure if it\u0027s supposed to work. The syntax in your test case though could also be interpreted as an array of storage buffer descriptors (webgpu doesn\u0027t have descriptor arrays though) instead of a single binding containing an array.\n\nI think it is indeed getting translated as an array of descriptors though. I was getting errors on Metal that the buffer slot must be between 0 and 30 - so it\u0027s likely producing shader code that has 1024 distinct bindings. We could verify by dumping the backend shader.",
      "parentUuid": "d1556d8d_f5ad8bec",
      "range": {
        "startLine": 358,
        "startChar": 8,
        "endLine": 366,
        "endChar": 9
      },
      "revId": "0831889f1db8cdb342d7606be3d5b9a9f1f7bde7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e667289_8cc75732",
        "filename": "src/tests/end2end/ComputeStorageBufferBarrierTests.cpp",
        "patchSetId": 1
      },
      "lineNbr": 366,
      "author": {
        "id": 1001736
      },
      "writtenOn": "2021-01-07T13:13:12Z",
      "side": 1,
      "message": "Generated SPIR-V:\n; SPIR-V\n; Version: 1.3\n; Generator: Google Tint Compiler; 0\n; Bound: 32\n; Schema: 0\n                                              OpCapability Shader\n                                              OpMemoryModel Logical GLSL450\n                                              OpEntryPoint GLCompute %main \"main\" %globalId\n                                              OpExecutionMode %main LocalSize 1 1 1\n                                              OpName %Particle \"Particle\"\n                                              OpMemberName %Particle 0 \"pos\"\n                                              OpMemberName %Particle 1 \"vel\"\n                                              OpName %particles \"particles\"\n                                              OpName %globalId \"globalId\"\n                                              OpName %main \"main\"\n                                              OpDecorate %Particle Block\n                                              OpMemberDecorate %Particle 0 Offset 0\n                                              OpMemberDecorate %Particle 1 Offset 8\n                                              OpDecorate %_arr_Particle_uint_1024 ArrayStride 16\n                                              OpDecorate %particles Binding 0\n                                              OpDecorate %particles DescriptorSet 0\n                                              OpDecorate %globalId BuiltIn GlobalInvocationId\n                                     %float \u003d OpTypeFloat 32\n                                   %v2float \u003d OpTypeVector %float 2\n                                  %Particle \u003d OpTypeStruct %v2float %v2float\n                                      %uint \u003d OpTypeInt 32 0\n                                 %uint_1024 \u003d OpConstant %uint 1024\n                   %_arr_Particle_uint_1024 \u003d OpTypeArray %Particle %uint_1024\n%_ptr_StorageBuffer__arr_Particle_uint_1024 \u003d OpTypePointer StorageBuffer %_arr_Particle_uint_1024\n                                 %particles \u003d OpVariable %_ptr_StorageBuffer__arr_Particle_uint_1024 StorageBuffer\n                                    %v3uint \u003d OpTypeVector %uint 3\n                         %_ptr_Input_v3uint \u003d OpTypePointer Input %v3uint\n                                  %globalId \u003d OpVariable %_ptr_Input_v3uint Input\n                                      %void \u003d OpTypeVoid\n                                        %12 \u003d OpTypeFunction %void\n                                    %uint_0 \u003d OpConstant %uint 0\n                           %_ptr_Input_uint \u003d OpTypePointer Input %uint\n                %_ptr_StorageBuffer_v2float \u003d OpTypePointer StorageBuffer %v2float\n                                    %uint_1 \u003d OpConstant %uint 1\n                                      %main \u003d OpFunction %void None %12\n                                        %15 \u003d OpLabel\n                                        %18 \u003d OpAccessChain %_ptr_Input_uint %globalId %uint_0\n                                        %19 \u003d OpLoad %uint %18\n                                        %21 \u003d OpAccessChain %_ptr_StorageBuffer_v2float %particles %19 %uint_0\n                                        %22 \u003d OpAccessChain %_ptr_Input_uint %globalId %uint_0\n                                        %23 \u003d OpLoad %uint %22\n                                        %24 \u003d OpAccessChain %_ptr_StorageBuffer_v2float %particles %23 %uint_0\n                                        %25 \u003d OpLoad %v2float %24\n                                        %26 \u003d OpAccessChain %_ptr_Input_uint %globalId %uint_0\n                                        %27 \u003d OpLoad %uint %26\n                                        %29 \u003d OpAccessChain %_ptr_StorageBuffer_v2float %particles %27 %uint_1\n                                        %30 \u003d OpLoad %v2float %29\n                                        %31 \u003d OpFAdd %v2float %25 %30\n                                              OpStore %21 %31\n                                              OpReturn\n                                              OpFunctionEnd\n\n\nWith SPIRV-Cross this translates to:\n\nGLSL:\n\n    #version 450\n    layout(local_size_x \u003d 1, local_size_y \u003d 1, local_size_z \u003d 1) in;\n\n    layout(binding \u003d 0, std430) buffer Particle\n    {\n        vec2 pos;\n        vec2 vel;\n    } particles[1024];\n\n    void main()\n    {\n        particles[gl_GlobalInvocationID.x].pos +\u003d particles[gl_GlobalInvocationID.x].vel;\n    }\n\nHLSL:\n\n    RWByteAddressBuffer particles[1024] : register(u0);\n\n    static uint3 gl_GlobalInvocationID;\n    struct SPIRV_Cross_Input\n    {\n        uint3 gl_GlobalInvocationID : SV_DispatchThreadID;\n    };\n\n    void comp_main()\n    {\n        particles[gl_GlobalInvocationID.x].Store2(0, asuint(asfloat(particles[gl_GlobalInvocationID.x].Load2(0)) + asfloat(particles[gl_GlobalInvocationID.x].Load2(8))));\n    }\n\n    [numthreads(1, 1, 1)]\n    void main(SPIRV_Cross_Input stage_input)\n    {\n        gl_GlobalInvocationID \u003d stage_input.gl_GlobalInvocationID;\n        comp_main();\n    }\n\n\nSo it looks like Austin\u0027s theory is correct that this is being translated to an array of descriptors, instead of a single descriptor to an array.\n\n\u003e webgpu doesn\u0027t have descriptor arrays though\n\nThis is probably the key thing we should be acting on. We likely need a validation rule to error that this is currently not supported. At least then the mistake is understandable to the developer.\n\nWill copy all of this back into the bug.",
      "parentUuid": "7012f9d6_3c3a3ff4",
      "range": {
        "startLine": 358,
        "startChar": 8,
        "endLine": 366,
        "endChar": 9
      },
      "revId": "0831889f1db8cdb342d7606be3d5b9a9f1f7bde7",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}