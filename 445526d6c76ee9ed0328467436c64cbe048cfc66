{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e34cb9b0_e6c191ef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-06-19T01:50:38Z",
      "side": 1,
      "message": "PTAL",
      "revId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "19a5ac8c_07373bf1",
        "filename": "src/dawn/native/metal/QueueMTL.mm",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-19T18:04:02Z",
      "side": 1,
      "message": "I think this might break cases where WebGPU does the following:\n\n```\nrequestAnimationFrame(() \u003d\u003e {\n  queue.writeTexture({\n     texture: canvasContext.getCurrentTexture()\n  }, {\n     // stuff\n  }, /**/);\n});\n```\n\nThe `writeTexture` operations will still be in the pending commands but Chromium will only call `WaitForCommandsToBeScheduled` leading to a race between WebGPU and CC for example.\n\nWe could add an enum of boolean that says whether we want to flush or not, but I think the best solution would be to explicitly say what object we wait for commands to be scheduled for (like the STM). The STM has the ExecutionSerial for its last use and we can decide whether to flush or not. Better, we could keep the previously submitted command buffers around until they are scheduled, so we can ask `waitUntilScheduled` on something that was 3 submits ago and will be scheduled sooner than the last one.\n\nAside from that the logic LGTM. How do you want to proceed?",
      "revId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2783cd26_b6d3b424",
        "filename": "src/dawn/native/metal/QueueMTL.mm",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-06-19T18:12:53Z",
      "side": 1,
      "message": "In that case, I\u0027d like this to return a WGPUFuture that tracks the scheduled handler for pending (or last submitted if there are no pending) commands. Then we would call it in every Dawn EndAccess (instead of overlay BeginAccess), retrieve the future, and wait on the future(s) when we promote the IOSurface to a CoreAnimation overlay (in overlay BeginAccess).",
      "parentUuid": "19a5ac8c_07373bf1",
      "revId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "552a4164_1600d399",
        "filename": "src/dawn/native/metal/QueueMTL.mm",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-19T18:53:29Z",
      "side": 1,
      "message": "That\u0027d work, but would the WGPUFuture be per STM or on a per-device method like this one is?",
      "parentUuid": "2783cd26_b6d3b424",
      "revId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc690f60_bc8b2896",
        "filename": "src/dawn/native/metal/QueueMTL.mm",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-06-20T16:11:08Z",
      "side": 1,
      "message": "I was thinking a per-device method. I don\u0027t mind having it be per STM, but it seemed like a weird fit there given that STM implementations return GPU fences and this is basically like a CPU waitable event.\n\n+Austin for input",
      "parentUuid": "552a4164_1600d399",
      "revId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75827b59_a958570b",
        "filename": "src/dawn/native/metal/QueueMTL.mm",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-06-20T19:22:33Z",
      "side": 1,
      "message": "IMO either is fine. Putting it on STM gives you better precision for what exactly you want to wait for though, right? It would be exactly the last GPU usage of that texture, and not include any other pending commands enqueued since then. It could be a metal-only extension struct on wgpu::SharedTextureMemoryEndAccessState that way it is clearly separate from the fences.",
      "parentUuid": "fc690f60_bc8b2896",
      "revId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12f9c955_2f442fd2",
        "filename": "src/dawn/native/metal/QueueMTL.mm",
        "patchSetId": 2
      },
      "lineNbr": 105,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-06-21T00:02:58Z",
      "side": 1,
      "message": "I\u0027m going to abandon this CL now since it wasn\u0027t a contributor to the Motionmark paths performance issues - it was just something I noticed when debugging that. If we do this in the future, I\u0027ll pursue one of the two options discussed above.",
      "parentUuid": "75827b59_a958570b",
      "revId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13a64252_5c867675",
        "filename": "src/dawn/native/metal/QueueMTL.mm",
        "patchSetId": 2
      },
      "lineNbr": 152,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2024-06-19T18:04:02Z",
      "side": 1,
      "message": "```suggestion\n    // mLastSubmittedSerial so it is captured by value.\n```",
      "revId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one maximum vote for label \u0027Code-Review\u0027 is required"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "445526d6c76ee9ed0328467436c64cbe048cfc66",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}