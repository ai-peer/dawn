{
  "comments": [
    {
      "key": {
        "uuid": "c4ddad05_478cac7b",
        "filename": "src/dawn_native/BindGroup.cpp",
        "patchSetId": 2
      },
      "lineNbr": 202,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-04-07T23:49:41Z",
      "side": 1,
      "message": "whoops. this doesn\u0027t need updating",
      "range": {
        "startLine": 202,
        "startChar": 23,
        "endLine": 202,
        "endChar": 33
      },
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df4881ca_2c9c8c18",
        "filename": "src/dawn_native/BindGroup.h",
        "patchSetId": 2
      },
      "lineNbr": 77,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-04-08T09:01:14Z",
      "side": 1,
      "message": "nit: put it at the bottom so it isn\u0027t an issue id BindingDataPointers accidentally grow a non-trivial destructor.",
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e888d717_b588e8c7",
        "filename": "src/dawn_native/BindGroup.h",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2020-04-08T09:01:14Z",
      "side": 1,
      "message": "Can we also have a TODO to find a less fragile solution, for example with a deletion queue like you suggested in the bug? I think UBSan will complain about what we\u0027re doing here.",
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4534e8f3_59e74bc4",
        "filename": "src/dawn_native/BindGroup.h",
        "patchSetId": 2
      },
      "lineNbr": 81,
      "author": {
        "id": 1000262
      },
      "writtenOn": "2020-04-08T16:57:44Z",
      "side": 1,
      "message": "Reading through the code and bug, I understand what is happening. This CL will fix the problem but I agree with Corentin that mLayout should always be the last member variable, and be commented as such like you\u0027ve done.\n\nHaving a deletion queue means you need to service the queue regularly, which comes with its own set of drawbacks. \n\nOne way I can think to solve the problem is to have BindGroup be reference counted by a special smart pointer which holds a Ref to both the BindGroup and the allocator it belongs to. If calling Release on the BindGroup returns a reference count of 1, the special smart pointer knows it is holding onto the last reference to BindGroup and would tell the allocator to get rid of its memory. This way, BindGroup doesn\u0027t need special ordering of member variables. Deletion of its memory is guaranteed to happen outside of the object, after all destructors have run.",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 81,
        "endChar": 41
      },
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5e38741_c1d8094c",
        "filename": "src/dawn_native/BindGroup.h",
        "patchSetId": 2
      },
      "lineNbr": 81,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2020-04-08T21:42:55Z",
      "side": 1,
      "message": "Something like this seems like the ideal solution to me.",
      "parentUuid": "4534e8f3_59e74bc4",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 81,
        "endChar": 41
      },
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ecc9566_e19218e4",
        "filename": "src/dawn_native/BindGroup.h",
        "patchSetId": 2
      },
      "lineNbr": 81,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-04-08T21:46:46Z",
      "side": 1,
      "message": "I don\u0027t love the idea of needing a deletion queue, or making an extra object to ref things. The main issue is that we need to have better control of the destruction order.\nHere\u0027s another idea:\n\nWe take advantage of the fact that BindGroup is RefCounted and is only destroyed using \"delete this\" inside RefCounted::Release(). Rafael\u0027s private/protected destructor change should have helped with ensuring things stay this way.\n\nAdd an optional virtual function which by default just calls delete.\nvirtual void RefCounted::DeleteThis() { delete this; } \n\n\nBindGroupBase can override this:\n\nvoid BindGroupBase::DeleteThis() override {\n  Ref\u003cBindGroupLayoutBase\u003e layout \u003d std::move(this-\u003emLayout);\n  delete this;\n}\n\nThis makes sure that the BGL is always unref-ed after the BindGroup is completely destroyed.",
      "parentUuid": "4534e8f3_59e74bc4",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 81,
        "endChar": 41
      },
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d33a7954_0454b87a",
        "filename": "src/dawn_native/BindGroup.h",
        "patchSetId": 2
      },
      "lineNbr": 81,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2020-04-08T22:02:42Z",
      "side": 1,
      "message": "As an implementation idea for Rafael\u0027s suggestion, could we template-overload Ref\u003c\u003e for BindGroups and have that Ref overload hold an extra Ref to the allocator (or BGL)?\n\nI think your new suggestion would also work, though I don\u0027t think we need to `delete this` inside the helper. Couldn\u0027t it just be a pre-delete function?",
      "parentUuid": "e5e38741_c1d8094c",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 81,
        "endChar": 41
      },
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b96749e_52965e0e",
        "filename": "src/dawn_native/BindGroup.h",
        "patchSetId": 2
      },
      "lineNbr": 81,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-04-08T22:10:56Z",
      "side": 1,
      "message": "Don\u0027t think a template overload would work because we need it on RefCounted, not Ref; and holding an extra ref from the bind group wouldn\u0027t be sufficient. We have to hold it external to the bind group so that the BGL can completely outlive the bind group.\n\nWith the DeleteThese idea, it could indeed be a pre-delete acquire of a Ref\u003cObjectBase\u003e. But then we have to return only one object, or a list of objects. That seems suboptimal if in some future we want to acquire a variable number of resources.",
      "parentUuid": "d33a7954_0454b87a",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 81,
        "endChar": 41
      },
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a251fd84_1f6a25c9",
        "filename": "src/dawn_native/BindGroup.h",
        "patchSetId": 2
      },
      "lineNbr": 81,
      "author": {
        "id": 1000015
      },
      "writtenOn": "2020-04-08T22:17:06Z",
      "side": 1,
      "message": "I think this is what you said, but we couldn\u0027t have it be part of the RefCounted because then you still have circular ownership: the RefCounted itself is inside the slab allocation. (right?)\nHaving it be part of Ref seems like it would work - it\u0027s external to the BindGroup - even though every Ref to a BindGroup would also be one whole ref to its allocator or BGL.\n\nDeleteThis: Right, it\u0027s not just a pre-delete, but also a post-delete destructor. Never mind that then. DeleteThis looks OK.",
      "parentUuid": "9b96749e_52965e0e",
      "range": {
        "startLine": 81,
        "startChar": 0,
        "endLine": 81,
        "endChar": 41
      },
      "revId": "01f31d5dbc8a43e113a978a73a82d7b95faea884",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd",
      "unresolved": true
    }
  ]
}