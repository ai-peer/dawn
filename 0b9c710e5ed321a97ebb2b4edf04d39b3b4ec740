{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "051feeba_6a4d6968",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-24T08:58:57Z",
      "side": 1,
      "message": "PTAL, thanks!",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7656ce55_38a7ad0a",
        "filename": "src/dawn_native/CreatePipelineAsyncTracker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-03-24T17:21:48Z",
      "side": 1,
      "message": "Like for QueueBase::TaskInFlight we could just Device-\u003eIsLost at [1] before calling finish and call HandleLoss if the device is lost instead.",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eb028064_2c45bdc0",
        "filename": "src/dawn_native/CreatePipelineAsyncTracker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-25T05:52:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7656ce55_38a7ad0a",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1fe3c099_a32f5743",
        "filename": "src/dawn_native/CreatePipelineAsyncTracker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-03-24T17:21:48Z",
      "side": 1,
      "message": "Instead of manual Ref/Release, WDYT of making these object contain a Ref\u003cRenderPipeline\u003e and call ref.Release() before passing it to the callback?",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7692cf97_b7df9d4b",
        "filename": "src/dawn_native/CreatePipelineAsyncTracker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 63,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-25T05:52:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1fe3c099_a32f5743",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2839a189_341a371d",
        "filename": "src/dawn_native/CreatePipelineAsyncTracker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 123,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-03-24T17:21:48Z",
      "side": 1,
      "message": "[1]",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "33c65a40_fdee4ebe",
        "filename": "src/dawn_native/CreatePipelineAsyncTracker.cpp",
        "patchSetId": 3
      },
      "lineNbr": 123,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-25T05:52:15Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "2839a189_341a371d",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "383bf4ce_54b49142",
        "filename": "src/dawn_native/CreatePipelineAsyncTracker.h",
        "patchSetId": 3
      },
      "lineNbr": 35,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-03-24T17:21:48Z",
      "side": 1,
      "message": "nit: this can be Finish and HandleLoss like for QueueBase::TaskInFlight.",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8574dfa9_b4025050",
        "filename": "src/dawn_native/CreatePipelineAsyncTracker.h",
        "patchSetId": 3
      },
      "lineNbr": 35,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-25T05:52:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "383bf4ce_54b49142",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c565fd0d_fa2fe751",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 760,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-03-24T17:21:48Z",
      "side": 1,
      "message": "The usual pattern is that Foo wraps ConsumedError(FooInternal) and FooInternal does DAWN_TRY(ValidateFoo); DAWN_TRY(FooImpl); Can we have the same split here? (it would require adding MaybeError to CreateInternal, make it call ValidatePipelineDescriptor and only then call CreateImpl that has a default implementation on DeviceBase).",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26300e3a_c451f63f",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 760,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-25T05:52:15Z",
      "side": 1,
      "message": "I think Create*PipelineAsync is a bit different from other APIs as it shouldn\u0027t report any validation errors according to the SPEC. When there is a validation error on the descriptor, the error message should be returned to the caller through callback instead of being captured by ErrorScopeStack.",
      "parentUuid": "c565fd0d_fa2fe751",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c7acaa7_26d704f4",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 760,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-03-25T09:34:33Z",
      "side": 1,
      "message": "Thanks for the explanation, it makes sense that this is different. We should still use the \"Impl\" terminology to make it clear it can be overriden by backends.\n\nAlso I don\u0027t think the backends will do deferred validation. Maybe CreateRenderPipelineAsync could do the validation, if it fails enqueue a small task that says validation failed, and only otherwise call into the backend.",
      "parentUuid": "26300e3a_c451f63f",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1b8d185_ec652eff",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 760,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-03-25T16:16:10Z",
      "side": 1,
      "message": "Maybe we could just store ResultOrError\u003cRef\u003cRenderPipelineBase\u003e\u003e inside the task?\nThis way we would store a validation error from ValidateIsAlive() and ValidateRenderPipelineDescriptor() in the task. If there\u0027s an error we can call TrackTask and return early.\n\nIf there\u0027s no error, then we call CreateRenderPipelineAsyncImpl.\n\nIf we store ResultOrError, then we don\u0027t need two types of tasks. Also, since CreateRenderPipelineAsyncImpl is async, it could see a device lost error later on, so the error stored there is useful.",
      "parentUuid": "2c7acaa7_26d704f4",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00a8d808_a825b6d3",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 760,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-26T02:17:26Z",
      "side": 1,
      "message": "OK so both of you prefer not putting the validations into sub-threads? It may affect a lot to my implementation here.",
      "parentUuid": "e1b8d185_ec652eff",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1cf7386_54640b96",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 760,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-26T08:31:13Z",
      "side": 1,
      "message": "Both the sync and the async version of CreateComputePipeline should share most of the code (validation, object caching, shader compilation (HLSL), pipeline creation), and we need to properly treat them in two ways:\n1. always called in the main thread\n2. the code is shared but called in different threads (in main thread for sync version, and in the sub-thread for async version)\n\nAnd there is the code that is totally different in the sync and async version:\n- In sync code: return errors\n- In async code:\n  - Encapsulate a task and run it with PostWorkerTask()\n  - Put the result into a queue\n  - Call callback in device.Tick()",
      "parentUuid": "00a8d808_a825b6d3",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ecc54fa_35b36c26",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 760,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-03-29T14:25:24Z",
      "side": 1,
      "message": "\u003e OK so both of you prefer not putting the validations into sub-threads? It may affect a lot to my implementation here.\n\nYeah, the alternative is to completely copy the RenderPipelineDescriptor in the task (and including pointers to sub-structures, etc) so that we can call ValidateRenderPipelineDescriptor() inside the task. That\u0027s a lot of code and complexity for not much gain because the validation should be a very very small fraction of the total creation cost of a pipeline.\n\nYour last comment sound 100% correct. How does that influence the architecture you had in mind?",
      "parentUuid": "f1cf7386_54640b96",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e8b05b1_c81d8e36",
        "filename": "src/dawn_native/Device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 760,
      "author": {
        "id": 1000019
      },
      "writtenOn": "2021-03-31T07:55:44Z",
      "side": 1,
      "message": "I\u0027ve updated this CL to provide a framework to only treat the creation of the pipeline on the backend as an async task.\n\nNow in CreateComputePipelineAsync(), the callback will be called at once in the main thread when:\n- an error is caught by the front-end validations, or\n- we can find a proper pipeline object in the front-end cache\n\nOtherwise, the remaining work will all be put into CreateComputePipelineAsyncImpl(), where the newly-created pipeline object, the callback and userdata will be saved into CreatePipelineAsyncTracker.\n\nPTAL, thanks!",
      "parentUuid": "6ecc54fa_35b36c26",
      "revId": "0b9c710e5ed321a97ebb2b4edf04d39b3b4ec740",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}