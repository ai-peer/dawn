{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6674a7fc_8228cd82",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-09T12:36:32Z",
      "side": 1,
      "message": "Alternative way to fix the memory leaks bug in DawnWire due to api objects being used after last external ref to device is dropped.",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f517ed66_241bc07b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-09T13:41:35Z",
      "side": 1,
      "message": "PTAL.",
      "parentUuid": "6674a7fc_8228cd82",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d5e046a_c19e7d9d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-09T16:44:33Z",
      "side": 1,
      "message": "LGTM",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2db5ad4c_fffc6e0d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-10T09:51:23Z",
      "side": 1,
      "message": "Still LGTM! Loko PTAL since Austin is OOO today.",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76b996fa_fc8e365b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-10T17:11:47Z",
      "side": 1,
      "message": "LGTM",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4bf75c00_4283aa25",
        "filename": "dawn.json",
        "patchSetId": 2
      },
      "lineNbr": 1533,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-10T17:11:47Z",
      "side": 1,
      "message": "I think we can remove all the tags",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3d8ed6d9_e4cd7194",
        "filename": "dawn.json",
        "patchSetId": 2
      },
      "lineNbr": 1533,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-13T20:56:43Z",
      "side": 1,
      "message": "Done. btw, what is the difference between \"native\" and \"dawn\" tag?",
      "parentUuid": "4bf75c00_4283aa25",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "065fd531_9bd576f9",
        "filename": "dawn.json",
        "patchSetId": 2
      },
      "lineNbr": 1533,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-14T10:46:40Z",
      "side": 1,
      "message": "Ah https://dawn.googlesource.com/dawn/+/refs/heads/main/docs/dawn/codegen.md isn\u0027t super clear. \"native\" is this header that we try to agree on with Mozilla: https://github.com/webgpu-native/webgpu-headers/blob/main/webgpu.h",
      "parentUuid": "3d8ed6d9_e4cd7194",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9de5e347_b7ecb551",
        "filename": "include/dawn/native/DawnNative.h",
        "patchSetId": 2
      },
      "lineNbr": 190,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-09T16:44:33Z",
      "side": 1,
      "message": "Why does this need to be added to both the dawn::native API and the wgpu:: API?",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4bdacfe8_1a3becb4",
        "filename": "include/dawn/native/DawnNative.h",
        "patchSetId": 2
      },
      "lineNbr": 190,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-09T17:15:33Z",
      "side": 1,
      "message": "I think from chrome `webgpu_decoder_impl.cc` side, only this `DawnNative.h` header is exposed. I don\u0027t know the exact reasons. It\u0027s the same thing why we have to added `DeviceTick` function in this header. Chrome uses `DeviceTick` instead of `wgpu::Device::Tick`\n\nSo if we want to change the webgpu\u0027s polling code in chrome to invoke `Instance::ProcessEvents` instead of `Device::Tick` we need to add the `ProcessEvents` function here.",
      "parentUuid": "9de5e347_b7ecb551",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "246b543d_bf85c25a",
        "filename": "include/dawn/native/DawnNative.h",
        "patchSetId": 2
      },
      "lineNbr": 190,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-10T09:51:23Z",
      "side": 1,
      "message": "Ah! It\u0027s because the dawn::native:: version returns a boolean but not the wgpu:: version. Ok we can have the dual path for now and figure out if we can just have the wgpu:: one return a boolean later.",
      "parentUuid": "4bdacfe8_1a3becb4",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "78ba1b9e_cec86e9a",
        "filename": "include/dawn/native/DawnNative.h",
        "patchSetId": 2
      },
      "lineNbr": 190,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-10T09:51:33Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "246b543d_bf85c25a",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b94dd7c_9bafae0c",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 284,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-09T16:44:33Z",
      "side": 1,
      "message": "When does this happen? Is it because of mocking in tests?",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f950b068_1528c69c",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 284,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-09T17:15:33Z",
      "side": 1,
      "message": "`DeviceBase::DeviceBase()` ctor version doesn\u0027t have adapter passed in. I think this is used by mocking.\nBut not sure whether we actually call `Initialize` on the mock device. Should this be changed to ASSERT instead?",
      "parentUuid": "5b94dd7c_9bafae0c",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2757f62f_bfd1d2cf",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 284,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-09T17:32:49Z",
      "side": 1,
      "message": "Just checked. We do call `Initialize` on the mock device here https://source.chromium.org/chromium/chromium/src/+/main:third_party/dawn/src/dawn/tests/unittests/native/mocks/DeviceMock.cpp;drc\u003dbec0ef46974cd9a6bc0f1f1ae34baa11913f77af;l\u003d115",
      "parentUuid": "f950b068_1528c69c",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "166634d4_c8e7e0fa",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 284,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-10T09:51:23Z",
      "side": 1,
      "message": "Thanks for the explanation. It\u0027s unfortunate that code here would need to be defensive in case it is used in a mocking scenario. Can you open an issue about this to see if we can have an adapter in the DeviceMock in the future?",
      "parentUuid": "2757f62f_bfd1d2cf",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4273859_fe905b39",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 284,
      "author": {
        "id": 1002831
      },
      "writtenOn": "2023-03-13T18:31:41Z",
      "side": 1,
      "message": "The plan was to do so in the future. We just haven\u0027t needed it yet so I deprioritized that for now. In theory, we may be able to use the mock device for all the validation testing instead of needing the null device in the future.",
      "parentUuid": "166634d4_c8e7e0fa",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84bd7fe0_0b6b56c4",
        "filename": "src/dawn/native/Device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 284,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-13T20:56:43Z",
      "side": 1,
      "message": "Done. Added TODO (linked to crbug.com/dawn/1702).",
      "parentUuid": "c4273859_fe905b39",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe0df56f_546af971",
        "filename": "src/dawn/native/Instance.cpp",
        "patchSetId": 2
      },
      "lineNbr": 533,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-10T17:11:47Z",
      "side": 1,
      "message": "it should be possible to write a test with deviceA and deviceB, where calling Tick on deviceA releases deviceB (inside some callback) - making the second tick cause a use after free.\n\nI think we can fix this by making the vector of devices local to this function hold a Ref",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2c9f45fd_a4e45358",
        "filename": "src/dawn/native/Instance.cpp",
        "patchSetId": 2
      },
      "lineNbr": 533,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-13T20:56:43Z",
      "side": 1,
      "message": "Done. btw using Ref might not be enough if multithreading comes into the picture. The device might be under destruction on another thread, adding a Ref on current thread is not safe if we only store the `DeviceBase*` raw pointer in `InstanceBase`. I have a fix for it in the follow up CL.",
      "parentUuid": "fe0df56f_546af971",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8cd0f919_37b0b798",
        "filename": "src/dawn/tests/DawnTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1447,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-10T17:11:47Z",
      "side": 1,
      "message": "do we need the call to Tick still?",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96082d85_052d6eb2",
        "filename": "src/dawn/tests/DawnTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1447,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-13T20:56:43Z",
      "side": 1,
      "message": "`targetDevice` is an argument passed into this function, it might not be created from the same `mInstance`. So I think we should keep it.",
      "parentUuid": "8cd0f919_37b0b798",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c033e14_5f3a6904",
        "filename": "src/dawn/tests/DawnTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1447,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-13T21:52:03Z",
      "side": 1,
      "message": "hm, I don\u0027t think there are many (or any) cases where we have another instance. It\u0027s probably better to remove the argument entirely then - or if necessary change it to be wgpu::Instance so you can process events on the other instance",
      "parentUuid": "96082d85_052d6eb2",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb4d2792_f7017f16",
        "filename": "src/dawn/tests/DawnTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1447,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-14T18:40:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5c033e14_5f3a6904",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cbb7bb5_f6a86444",
        "filename": "src/dawn/wire/server/Server.cpp",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-10T17:11:47Z",
      "side": 1,
      "message": "is this to make sure no pending callbacks are in flight?\nshould we use the dawn::native:: version to call ProcessEvents until idle?",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4b274b2_39c0cea9",
        "filename": "src/dawn/wire/server/Server.cpp",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-13T20:56:43Z",
      "side": 1,
      "message": "What do you mean by \"use the dawn::native:: version to call ProcessEvents until idle\"?\n\nDoes it mean we should implement a `dawn::native` version of `ProcessEvents` where we keep calling `APIProcessEvents` until it returns false? Or we implement the \"looping until idle\" here but using `dawn::native` instead of `mProcs.instanceProcessEvents`?\n\nI don\u0027t see `dawn::native::DeviceTick` is implemented as a loop until idle btw.",
      "parentUuid": "7cbb7bb5_f6a86444",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8239461a_3bfdf184",
        "filename": "src/dawn/wire/server/Server.cpp",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-13T21:04:17Z",
      "side": 1,
      "message": "I meant implement the looping here - if the intent is to flush everything entirely. \n\nWhy do we need to flush here versus looping in the the fuzzer to make sure all callbacks are done?\nOverall - it is an invariant of the server that all callbacks are called when the server is destroyed? or is it an application bug to leak the callbacks?\n\nIMO it might be better to loop until idle in the fuzzer, instead of here; but I\u0027m not sure what the intent of the change was.",
      "parentUuid": "e4b274b2_39c0cea9",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7f1ae84_c4b70e27",
        "filename": "src/dawn/wire/server/Server.cpp",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-13T21:38:15Z",
      "side": 1,
      "message": "Yeah, you are right. Then intention of the processEvents call here was to flush remaining callbacks. Doing the loop in the fuzzer would fix the leak as well.\nI was just following Corentin\u0027s original suggestion of calling `device.Tick` in the server before the device is destroyed. But that was not enough because `MapAsync` could still be called after the device is destroyed (externally/or in server\u0027s point of view). In practice, the device might still be alive due to internal ref being kept by the buffer. Using `ProcessEvents` is the only way to trigger the callback after that. And I thought inside Server\u0027s dtor could be an appropriate place to call `ProcessEvents`.\n\nShouldn\u0027t we do the loop here so that any leaks would be automatically cleared for the application? Or it\u0027s the responsibility of the application to keep draining last remaining callbacks before destroying the server?",
      "parentUuid": "8239461a_3bfdf184",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b5e9e35_56877e52",
        "filename": "src/dawn/wire/server/Server.cpp",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-13T21:47:36Z",
      "side": 1,
      "message": "Now I think about it again, there is still another way to fix the callback leak:\nWe can make `ObjectBase` a subclass of `RefCountedWithExternalCount` and inside its `WillDropLastExternalRef`, we trigger `device.Tick()`.\n\nThat way, when a buffer is destroyed, any callback related to it will be flushed automatically.",
      "parentUuid": "a7f1ae84_c4b70e27",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2966fcbd_a6d3561d",
        "filename": "src/dawn/wire/server/Server.cpp",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-13T21:52:03Z",
      "side": 1,
      "message": "Right now, the WGPUInstance can outlive the server. It\u0027s \"injected\" into the server using `InjectInstance`. And, there\u0027s no way to un-inject it. So it could be a bit weird that the server \"takes over\" the instance in this way and will ensure that it flushes everything.\nWe could say that it\u0027s the application\u0027s responsibility since after injecting the instance, they may still retain a reference to it.\n\nThe application needs to manually call processEvents anyway in normal operation (like Chrome w/ PerformPollingWork). The wire doesn\u0027t do it for you. So it could be weird that we handle flushing this shutdown case, but not other more typical situations.\nSo for consistency, I think it is better for now to not flush on behalf of the application.",
      "parentUuid": "a7f1ae84_c4b70e27",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb7c9c29_b6621628",
        "filename": "src/dawn/wire/server/Server.cpp",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2023-03-13T21:54:23Z",
      "side": 1,
      "message": "\u003e We can make ObjectBase a subclass of RefCountedWithExternalCount and inside its WillDropLastExternalRef, we trigger device.Tick().\n\u003e That way, when a buffer is destroyed, any callback related to it will be flushed automatically.\n\nif we did this, we\u0027d want to only do it for the special objects that have this problem to avoid the extra refcount on all other objects. Seems like we nearly have instanceProcessEvents working though, and it\u0027s probably the more correct option? (given the desire to only call callbacks when the application checks for them)",
      "parentUuid": "2966fcbd_a6d3561d",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "993635d2_7504fe4f",
        "filename": "src/dawn/wire/server/Server.cpp",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1003501
      },
      "writtenOn": "2023-03-14T18:40:59Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cb7c9c29_b6621628",
      "revId": "b6123d6a9fb482a750149532bae31e80ad7206f0",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}