{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1ace438e_51cd2c77",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-12-08T21:33:20Z",
      "side": 1,
      "message": "PTAL!",
      "revId": "b8614655112d286c62264dcf222f53a331c982bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "762013aa_9302fe88",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-12-11T18:14:14Z",
      "side": 1,
      "message": "Thanks for the CL - it\u0027s a promising direction, but overall, I realized there are some big issues with having a library be per-device.\nChromium is going to do per-origin cache isolation which will be fine with the current design.\nPages from the same origin and device/adapter properties will be looking up pipelines in the same cache.\n\nThe big issue though is that we load the pipeline cache on device creation, store it on device destruction, and there\u0027s zero cross-device communication about pipelines added to the cache.\n\nThis means if I load both webgpu.shadertoy.com/foo and webgpu.shadertoy.com/bar in two tabs, then close foo first, then bar, foo\u0027s pipelines will be written into the persistent cache, then bar\u0027s will also be written and overwrite pipelines from foo.\n\nThis becomes less of a problem if/when we multiplex multiple logical devices onto the same physical device, but we don\u0027t want to block the caching implementation on that since we have no concrete timeline on multiplexing at this time.\n\nMaybe we should first write a concrete design about how we\u0027ll integrate this into Chromium. The other doc you have (which needs updating now that we\u0027ve iterated a bunch) talks mostly about the native APIs available and how we\u0027ll implement it in Dawn, but we also need to figure out integration with the embedder. Some primitive ideas here, but it seems like for D3D12 we will need some way to tell other Dawn devices created on different instances about new pipelines - can you even StorePipeline a PSO created on a different D3D12 device? For Vulkan maybe we can use vkMergePipelines.\n\nThat said.. I think the video work is more important at this time and we should focus on that unless it\u0027s blocked on something.",
      "revId": "b8614655112d286c62264dcf222f53a331c982bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b1bc634_ea6cf7cc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-12-15T20:00:45Z",
      "side": 1,
      "message": "Thanks for taking a look! I am still working through on the embedder side change.\n\nFor the overwrite pipeline concern, d3d12::PipelineCache::MergePipeline(src \u003d current library, dst \u003d newest) can be readily added to do the more optimal update-modify (aka vkMergePipelines) strategy in this CL or a follow-up. I was missing access to mCaches - a bit more plumbing is needed (WDYT of  DeviceBase::GetCachedRenderPipelines?) but that idea is spot on.\n\nIn D3D, StorePipeline must be called on the same device the pipeline was created with. note: a d3d device comes from a stateless factory so another but not different device can only use the same library (via key).\n\nI don\u0027t mind looking more into video but it would be nice to get a basic version of pipeline cache done while it\u0027s still fresh in my mind or while I wait on CRs.",
      "parentUuid": "762013aa_9302fe88",
      "revId": "b8614655112d286c62264dcf222f53a331c982bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cedd2288_cf4acac3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-12-15T20:03:52Z",
      "side": 1,
      "message": "How would this work on D3D12? From what I understand, if we make two tabs, the cache will \"fork\" so we have two \"newest\" versions that need to be merged. Is that possible?\n\n\u003e note: a d3d device comes from a stateless factory so another but not different device can only use the same library (via key).\nSo is that means that we *can* call StorePipeline cross-device if it came from the same factory?",
      "parentUuid": "0b1bc634_ea6cf7cc",
      "revId": "b8614655112d286c62264dcf222f53a331c982bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc726589_b12f5d6a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000268
      },
      "writtenOn": "2020-12-15T20:54:51Z",
      "side": 1,
      "message": "\u003e \"fork\" so we have two \"newest\" versions that need to be merged. Is that possible?\n\nRight. To merge, we load the cache again (get newest version) then call StorePipelines using mCaches. Optionally, swap (vs discard) to continue use of the newer version if not on shutdown. We\u0027ll eventually need to do more to keep caches synchronized like Vulkan does for you.\n\n\u003e So is that means that we *can* call StorePipeline cross-device if it came from the same factory?\n\nYup. a \"D3D device\" is nothing more than an AddRef. If two d3d devices correspond to the same adapter IDs then a d3d library created on one can be used with the other.",
      "parentUuid": "cedd2288_cf4acac3",
      "revId": "b8614655112d286c62264dcf222f53a331c982bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c4bdfbc_0f4acad3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-12-15T21:01:56Z",
      "side": 1,
      "message": "Ok, my intuition is we\u0027d just want to share the d3d library instead of retroactively adding pipelines from a different device. We should write up a concrete design for how this will work on all the backends.",
      "parentUuid": "bc726589_b12f5d6a",
      "revId": "b8614655112d286c62264dcf222f53a331c982bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe1bf6bf_1a43d67a",
        "filename": "src/dawn_native/d3d12/D3D12Error.cpp",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2020-12-11T18:14:14Z",
      "side": 1,
      "message": "comment about why we allow this error code",
      "range": {
        "startLine": 52,
        "startChar": 56,
        "endLine": 52,
        "endChar": 68
      },
      "revId": "b8614655112d286c62264dcf222f53a331c982bf",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}