{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "50852b56_586ad321",
        "filename": "src/tint/builtin/number.h",
        "patchSetId": 1
      },
      "lineNbr": 280,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-06-19T11:20:48Z",
      "side": 1,
      "message": "These `static_assert`s have put me on an adventure in FP / compiler research this morning.\n\n---\n\n[cppreference](https://en.cppreference.com/w/cpp/types/numeric_limits) says:\n\n\u003e The value of `std::numeric_limits\u003cT\u003e::has_infinity` is true for all types `T` capable of representing the positive infinity as a distinct special value. This constant is meaningful for all floating-point types and is guaranteed to be true if `std::numeric_limits\u003cT\u003e::is_iec559 \u003d\u003d true`.\n\n\u003e The value of `std::numeric_limits\u003cT\u003e::has_quiet_NaN` is true for all types `T` capable of representing the special value \"Quiet Not-A-Number\". This constant is meaningful for all floating-point types and is guaranteed to be true if `std::numeric_limits\u003cT\u003e::is_iec559 \u003d\u003d true`.\n\n---\n\nSo we\u0027re asserting that the **types** support infinities and NaN, but the CL says we\u0027re asserting `const-eval depends on inf and NaN support`. Const-eval is a runtime thing, so we need to also consider compiler flags and runtime flags.\n\nLet\u0027s assume that we\u0027re only interested in Clang.\n\nClang has a bunch of compiler flags for [`Controlling Floating Point Behavior`](https://clang.llvm.org/docs/UsersManual.html#controlling-floating-point-behavior). The interesting flags are: `no_honor_nans` and `no_honor_infinities`. [The `Floating Point Models` table](https://clang.llvm.org/docs/UsersManual.html#id14) say both NaNs and infinities may **not** be honoured with `-ffast-math`.\n\nSure enough, [these static_asserts do not fire with `-ffast-math` enabled](https://godbolt.org/z/6fGns1Kx5), and I know most games studios will enable `-ffast-math` by default.\n\nFor runtime behaviour, we need to also consider fp-control registers, which are clearly CPU \u0026 OS dependent. X86 / X64 have the [`_MCW_IC` mask which can be `_IC_AFFINE` or `_IC_PROJECTIVE`](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/control87-controlfp-control87-2?view\u003dmsvc-170). Documentation for what these flags actually mean is almost non-existent, but I believe `_IC_PROJECTIVE` has only a single representation for infinity (e.g. no sign to differentiate). Fun.\n\n\n\nSo what do we do with all this information? Probably nothing.\n\nWe already have unit tests in place that check we produce errors for infinities and NaNs. Assuming we run the unit tests on the same environment that we run the code in production then we should be good. Folks that change fp-control flags are taking their actions into their own hands (SwiftShader actually does this - which is really questionable behaviour if this isn\u0027t restored before returning to the caller).\n\nThese asserts seem fine, but clearly aren\u0027t going to prevent stuff being broken with compiler flags or runtime fp-control changes.",
      "revId": "8b5250e422da844f66e5e6b83e747dab994d2b63",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3931141f_a223ad48",
        "filename": "src/tint/builtin/number.h",
        "patchSetId": 1
      },
      "lineNbr": 280,
      "author": {
        "id": 1000033
      },
      "writtenOn": "2023-06-19T14:21:58Z",
      "side": 1,
      "message": "You dug deeper than I did.  :-)\n\nYes, the unit tests are the stronger statement.\nBut I also don\u0027t want the unit tests to be seen as going further than the intent of the feature code itself.\nI\u0027d be open to strengthening the comments in the code.  Merely having the infinite and NaN values is strictly weaker than what we need, like you say.\n\nHopefully a future SWE will come back to these notes if in doubt.",
      "parentUuid": "50852b56_586ad321",
      "revId": "8b5250e422da844f66e5e6b83e747dab994d2b63",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60f705d4_5c9bde07",
        "filename": "src/tint/builtin/number.h",
        "patchSetId": 1
      },
      "lineNbr": 283,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-06-19T11:20:48Z",
      "side": 1,
      "message": "Should we also not check for subnormal support with [`std::numeric_limits\u003cT\u003e::has_denorm`](https://en.cppreference.com/w/cpp/types/numeric_limits/has_denorm)? I presume FTZ is something we want to avoid?\n\nOr does the WGSL spec not define const-eval behaviour of subnormals?",
      "revId": "8b5250e422da844f66e5e6b83e747dab994d2b63",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93ed5eef_a39c64af",
        "filename": "src/tint/builtin/number.h",
        "patchSetId": 1
      },
      "lineNbr": 283,
      "author": {
        "id": 1000033
      },
      "writtenOn": "2023-06-19T14:21:58Z",
      "side": 1,
      "message": "WGSL spec doesn\u0027t say anything about const-eval behaviour of subnormals.  That\u0027s new territory.  I think that *might* be controversial.\n\nECMAScript doesn\u0027t say much, but one statement implies that implementations might not have to support denormals.  (\"Subnormal\" does not appear. \"denormal\" appears three times.)\n\n\u003e If an implementation does not support denormalized values, the value of Number.MIN_VALUE must be the smallest non-zero positive value that can actually be represented by the implementation.",
      "parentUuid": "60f705d4_5c9bde07",
      "revId": "8b5250e422da844f66e5e6b83e747dab994d2b63",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one maximum vote for label \u0027Code-Review\u0027 is required"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader AND -label:Code-Review=MIN"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["label:Code-Review=MAX,user=non_uploader"],"failingAtoms":["label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "8b5250e422da844f66e5e6b83e747dab994d2b63",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Kokoro",
        "description": {
          "value": "A maximum vote is required for the Kokoro label. A minimum vote is blocking."
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Kokoro\u003dMAX AND -label:Kokoro\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "uploader:dawn-autoroll@skia-public.iam.gserviceaccount.com"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Kokoro=MAX AND -label:Kokoro=MIN"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["label:Kokoro=MAX"],"failingAtoms":["label:Kokoro=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"uploader:dawn-autoroll@skia-public.iam.gserviceaccount.com"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["uploader:dawn-autoroll@skia-public.iam.gserviceaccount.com"]}
      },
      "patchSetCommitId": "8b5250e422da844f66e5e6b83e747dab994d2b63",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["is:review-enforced_gerrit"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforcement-satisfied_gerrit"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "8b5250e422da844f66e5e6b83e747dab994d2b63",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {
        "value": true
      }
    }
  ]
}