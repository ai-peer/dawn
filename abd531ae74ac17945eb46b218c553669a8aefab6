{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "cb9d6fec_0ecbd384",
        "filename": "/COMMIT_MSG",
        "patchSetId": 15
      },
      "lineNbr": 9,
      "author": {
        "id": 1002331
      },
      "writtenOn": "2024-02-13T15:13:55Z",
      "side": 1,
      "message": "FYI, I suspect releasing keyed mutex will forcing an extra command buffer flushing. So maybe tighten the keyed mutex scoped will hurt performance, especially the shared texture is used multiple times in one shared image access scope.\n\nWhat\u0027s the use cases of concurrent access? Are the concurrent accesses on different d3d11 device? Are those access on different threads?",
      "range": {
        "startLine": 9,
        "startChar": 35,
        "endLine": 9,
        "endChar": 70
      },
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b9783f7e_be46a8bb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 15
      },
      "lineNbr": 9,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-02-13T21:36:19Z",
      "side": 1,
      "message": "Discussed this offline, but tl;dr - the concurrent access is needed for video capture (camera) process textures which use keyed mutex and can be shared between multiple components (renderer processes, webgl, webgpu, compositor) and there\u0027s no guarantee how long a component will hold on to a scoped access.",
      "parentUuid": "cb9d6fec_0ecbd384",
      "range": {
        "startLine": 9,
        "startChar": 35,
        "endLine": 9,
        "endChar": 70
      },
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "51968e41_0114f735",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 15
      },
      "lineNbr": 0,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-02-08T19:09:43Z",
      "side": 1,
      "message": "This is ready for another review - PTAL, thanks!",
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f421c0d5_9f57885c",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 15
      },
      "lineNbr": 242,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-02-10T00:12:36Z",
      "side": 1,
      "message": "hm.. so we\u0027re going to be building up this vector even for non-keyed mutex textures. We should ideally not push_back at all when we don\u0027t need to.\n\nBut - why have a vector of scoped usages at all? An alternative would to use a absl::flat_hash_set\u003cKeyedMutex::Guard\u003e and we emplace into that. This would use less memory than the current approach, and wouldn\u0027t require you to do the counting of how many times the keyed mutex is acquired.\n\nThinking to d3d12 though - will d3d12 need to hold onto the keyed mutex until submit? If so, it might be more consistent to put that set of guards on the CommandRecordingContext. We\u0027ll release all the guards when the pending commands are \"submitted\" (pseudo submitted because d3d11 is immediate-mode). This is similar to how the CommandRecordingContext in Vulkan stores things like - buffers it needs to transition for mapping, external textures to transition for mapping, semaphores to wait on, semaphores to signal, etc.\n\nThat means though you\u0027ll need to force a flush if someone does WriteTexture to a KeyedMutex texture - both on d3d11 and d3d12. Otherwise the keyed mutex might not get released promptly without the explicit flush.",
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7dd06458_fad1a00c",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 15
      },
      "lineNbr": 242,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-02-10T00:51:45Z",
      "side": 1,
      "message": "\u003e But - why have a vector of scoped usages at all? An alternative would to use a absl::flat_hash_set\u003cKeyedMutex::Guard\u003e and we emplace into that. This would use less memory than the current approach, and wouldn\u0027t require you to do the counting of how many times the keyed mutex is acquired.\n\nHow about we return an optional\u003cKeyedMutex::Guard\u003e (or optional\u003cScopedTextureUse\u003e if we prefer to hide the keyed mutex detail) and push it into the vector only if the optional is not nullopt\n\nI\u0027m not sure how absl::flat_hash_set\u003cKeyedMutex::Guard\u003e would work unless you\u0027re also suggesting making KeyedMutex::Guard a RefCounted type? It\u0027s also a type without a default constructor so it needs to be wrapped in an optional - that was a choice I made on purpose to clarify that there\u0027s no \"null\" Guard (not strictly true since you can std::move it and create a null one that way, but there are no guarantees about that). Maybe you meant absl::flat_hash_map\u003coptional\u003cKeyedMutex::Guard\u003e\u003e instead - so the nullopts don\u0027t take any extra memory?\n\n\u003e Thinking to d3d12 though - will d3d12 need to hold onto the keyed mutex until submit?\n\nYes, d3d12 will also need to hold on to the keyed mutex, but it only needs to do that in ExecuteCommandLists where we already keep track of shared textures. So the ScopedTextureUses will only be kept there.\n\nThe D3D12 CL is also mostly ready - I was holding off on sending it until this one is reviewed: https://dawn-review.googlesource.com/c/dawn/+/171741",
      "parentUuid": "f421c0d5_9f57885c",
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b11eec7e_391ab006",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 15
      },
      "lineNbr": 242,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-02-12T18:11:25Z",
      "side": 1,
      "message": "feel like maybe the scoped guard is getting in the way of a simpler solution. Couldn\u0027t we have something like:\n\n```\nabsl::flat_hash_set\u003cComPtr\u003cIDXDIKeyedMutex\u003e\u003e mAcquiredKeyedMutexes;\n\n// when we sync before use:\nComPtr\u003cIDXDIKeyedMutex\u003e keyedMutex \u003d texture-\u003eGetKeyedMutex();\nif (keyedMutex \u0026\u0026 !mAcquiredKeyedMutexes.contains(keyedMutex)) {\n  DAWN_TRY(keyedMutex-\u003eAcquireSync(...));\n  mAcquiredKeyedMutexes.insert(std::move(keyedMutex));\n}\n\n\n// on submit:\nfor (auto km : mAcquiredKeyedMutexes) {\n  km-\u003eReleaseSync(...);\n}\nmAcquiredKeyedMutexes.clear();\n```\n\nI think the command recording context would be the only place that needs to acquire the keyed mutex, so I\u0027m not super worried about needing a Guard class to ensure correct release since it shouldn\u0027t be widely used.\n\nIn the future, we **could** have a transparent comparator to do lookups against KeyedMutex::Guard using just KeyedMutex (no need to acquire to perform `.find()`) - but not sure if it is worth the complexity right now.",
      "parentUuid": "7dd06458_fad1a00c",
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93db04aa_96c7d980",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 15
      },
      "lineNbr": 242,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-02-12T23:51:04Z",
      "side": 1,
      "message": "The way you suggest works for D3D12 where ~all work is submitted via command lists in one place, but with D3D11 being a more immediate-mode API, there are many sites where the keyed mutex has to be acquired (see all the ScopedTextureUses in this file).\n\nEven with D3D12, where we have a single place that keyed mutexes have to be acquired, we also want to prevent double acquires for the keyed mutex if a shared texture is imported multiple times - the KeyedMutex wrapper and its Guard helper ensure that.\n\nIMO the simplest solution that doesn\u0027t waste extra memory is probably something like this:\n\n```\nstd::optional\u003cKeyedMutex::Guard\u003e Texture::SynchronizeTextureBeforeUse(commandContext);\n\nstd::vector\u003cKeyedMutex::Guard\u003e acquiredKeyedMutexes;\n...\nfor (TextureBase* texture: ...) {\n  std::optional\u003cKeyedMutex::Guard\u003e keyedMutexGuard;\n  DAWN_TRY_ASSIGN(keyedMutexGuard, texture-\u003eAcquireKeyedMutex());\n  if (keyedMutexGuard) {\n    acquiredKeyedMutexes.emplace_back(std::move(*keyedMutexGuard));\n  }\n}\n```\n\nIt\u0027s a few more lines of code, but there are only like a few loops like this, so it seems fine to me.",
      "parentUuid": "b11eec7e_391ab006",
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b508253_0569b337",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 15
      },
      "lineNbr": 242,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2024-02-13T02:02:59Z",
      "side": 1,
      "message": "your proposal still puts duplicate entries in the vector though if you use the same texture twice, and we have to refcount the acquires.\n\nwhy doesn\u0027t storing a map on the command context work for D3D11? while there are many scoped uses here, we don\u0027t need to begin/end all the scopes this often to be correct. it should be sufficient for all of them to acquire the keyed mutex if it has not been already, and then when the command context is submitted, release all of them at once. I believe it only needs to be at the granularity of queue submit (or write texture)",
      "parentUuid": "93db04aa_96c7d980",
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19212587_704705fc",
        "filename": "src/dawn/native/d3d11/CommandBufferD3D11.cpp",
        "patchSetId": 15
      },
      "lineNbr": 242,
      "author": {
        "id": 1002701
      },
      "writtenOn": "2024-02-13T21:36:19Z",
      "side": 1,
      "message": "I\u0027ve incorporated your suggestion by having Texture::SynchronizeTextureBeforeUse enqueue the keyed mutex with CommandRecordingContext which will check if the keyed mutex is already acquired, acquire it if it\u0027s not, and then release it on submit. I agree that it\u0027s quite a bit simpler this way.",
      "parentUuid": "5b508253_0569b337",
      "revId": "abd531ae74ac17945eb46b218c553669a8aefab6",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}