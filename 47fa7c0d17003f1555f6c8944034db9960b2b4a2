{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "89fe941d_11ea519d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-05-31T06:56:32Z",
      "side": 1,
      "message": "This change should be OK. Hope that the bots will not complain...",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e8b0693_568a2eca",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 96,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-31T13:45:21Z",
      "side": 1,
      "message": "Why do we multiply by blockInfo.height? copySize.height should already be in texels, and * blockInfo.height does an unnecessary block -\u003e texel conversion.",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52cb3d37_d2b7aa8a",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 96,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-01T16:04:19Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "5e8b0693_568a2eca",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3564481c_f0eaa3e1",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 129,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-31T13:45:21Z",
      "side": 1,
      "message": "We should probably remove rowsPerImage from this function and always copySize.height (+ texelOffset.y). See https://dawn-review.googlesource.com/c/dawn/+/52720\n\nBasically depending on the type of copy (2D/2Darray or 3D) the handling of rowsPerImage is different so this function could just say that the copies regions say in bounds of the buffer, and the 3D split function will be responsible for adding back rowsPerImage.\n\nCan we edit TextureCopySplitterUnittests to cover this case as well?",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "140a8a95_363f575d",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 129,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-01T16:04:19Z",
      "side": 1,
      "message": "See my reply at that CL. Let\u0027s discuss that issue at that CL if needed.",
      "parentUuid": "3564481c_f0eaa3e1",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07b82e5b_0dc236ed",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-05-31T13:45:21Z",
      "side": 1,
      "message": "I think it might be simpler to ASSERT(texelOffset.y \u003c\u003d 1); and some special computations if texelOffset \u003d\u003d 1 (with a comment explaining which invariant we preserve when doing it):\n\n copy.copies[1].alignedOffset/.bufferSize.height/.bufferOffset.y \u003d ...;\n\n // stuff\n if (texelOffset \u003d\u003d 1) {\n   copy.copies[1].alignedOffset +\u003d bytesPerRow * 2;\n   copy.copies[1].bufferSize.height -\u003d 2;\n   copy.copies[1].bufferOffset.y -\u003d 2;\n }\n\nAlso can we add a check to TextureCopySplitter unittests for the bufferOffset invariants?",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "432fe2ac_81fdf89d",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-01T16:04:19Z",
      "side": 1,
      "message": "I tried, texelOffet.y should be less than blockInfo.height (not 1) in order to support compressed textures. \n\nThe computation of alignedOffset for copy1 can cover two situations for \"fake\" empty rows in copy regions: \n  - two empty row issue (like you pointed out), for example, if data in one row straddle two rows due to alignment adjustment, and there is an empty row at the first copy region for the first part of the row, the copy region for the second part will definitely has two empty rows if we don\u0027t recompute alignedOffset.\n  - one unwanted empty row issue. For example, if bytesPerRow \u003e\u003d 512 (let\u0027s say it is 512) and data in one row straddle two rows due to alignment adjustment, and there is NO EMPTY ROW in copy 0. The copy region for copy 1 will definitely has one empty row if we don\u0027t recompute alignedOffset for it (because data straddle rows). In this situation, the code above is incorrect.\n\nAnd recompute alignedOffset can handle both of these two situations.",
      "parentUuid": "07b82e5b_0dc236ed",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98e926f6_acebd0ff",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2021-06-01T18:48:55Z",
      "side": 1,
      "message": "\u003e I tried, texelOffet.y should be less than blockInfo.height (not 1) in order to support compressed textures. \n\nI keep forgetting about blockInfo.height :)\n\nThanks for the explanation of why we need to use ComputeTexelOffsets again. Can we have a comment explaining the two cases it handles in the code and the invariant it preserves? (also we need to add the invariant to the list of invariants and CopySplit test coverage)",
      "parentUuid": "432fe2ac_81fdf89d",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eba8d809_807d38f8",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-06-01T18:58:26Z",
      "side": 1,
      "message": "Maybe this is similar to Corentin\u0027s question, but\n\nFor both of these cases, is it true that alignedOffsetForCopy1 is always one row past alignedOffsetForCopy0 ? That is, copy0 and copy1 are always one row offset from each other, so maybe we can simply compute \" alignedOffsetForCopy1 \u003d copy.copies[0].alignedOffset + bytesPerRow \"",
      "parentUuid": "98e926f6_acebd0ff",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ecaa0d1_22f59094",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1000017
      },
      "writtenOn": "2021-06-02T06:59:26Z",
      "side": 1,
      "message": "To Corentin: I feel like that recompute the texelOffset is more straightforward, it is definitely correct. We may need to explain otherwise. So I don\u0027t think we need to explain it in code. But I did explain the two situations that can be benefited due to this change in commit log. I also inserted some testing code to capture code execution stream during unittests, it turned out that these two situation has already been covered by a lot of tests. For example, two empty row situation is covered by copySize \u003d {64, 1, 1} and bufferSpec \u003d {offset: 260, bytesPerRow: 256, ...} or bufferSpec \u003d {384, 256, ...}. But I added one more test that offset is exactly 256 and bytesPerRow is 256 and there is exactly one empty row. And I also added a couple invariants in comments. \n\nTo Austin: For the first situation I mentioned, there are two rows offset from Copy 1 to copy 0, and for the second situation, there is one row offset. So we can\u0027t simply add one bytesPerRow. And adding ifs to distinguish one row offset or two row offset is more complicated than recompute alignedOffset for copy1. In addition, adding bytesPerRow might be incorrect if it is not 512B-aligned (bytesPerRow is 256B-aligned. That\u0027s not enough. Because alignedOffset should be 512B-aligned) and it is one row offset, while recompute is definitely correct (with texelOffset.x \u003e 0).",
      "parentUuid": "eba8d809_807d38f8",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e45043f9_58b1f376",
        "filename": "src/dawn_native/d3d12/TextureCopySplitter.cpp",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1000032
      },
      "writtenOn": "2021-06-02T21:31:03Z",
      "side": 1,
      "message": "Ah, I see. Thank you for the explanation",
      "parentUuid": "3ecaa0d1_22f59094",
      "revId": "47fa7c0d17003f1555f6c8944034db9960b2b4a2",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}