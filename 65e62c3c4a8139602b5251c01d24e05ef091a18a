{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "68ed1a0f_0b765791",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001737
      },
      "writtenOn": "2023-03-30T16:31:08Z",
      "side": 1,
      "message": "+1 from me, assuming CTS doesn\u0027t catch fire.\n\nLet\u0027s not merge this to M113, just incase it does more damage than it fixes.\n\nCorentin for +2",
      "revId": "65e62c3c4a8139602b5251c01d24e05ef091a18a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b463d729_0165a950",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2023-03-30T17:48:45Z",
      "side": 1,
      "message": "Note that the Kokoro failure is just an infra error.",
      "revId": "65e62c3c4a8139602b5251c01d24e05ef091a18a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dc07d031_af598513",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000002
      },
      "writtenOn": "2023-03-30T17:56:45Z",
      "side": 1,
      "message": "LGTM!",
      "revId": "65e62c3c4a8139602b5251c01d24e05ef091a18a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "277de94c_bf9941e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2023-03-30T19:36:14Z",
      "side": 1,
      "message": "Hmm, CTS is failing on quantizeToF16 execution tests:\n\n```\ngpu_tests.webgpu_cts_integration_test.WebGpuCtsIntegrationTest.webgpu:shader,execution,expression,call,builtin,quantizeToF16:f32:inputSource\u003d\"storage_rw\";vectorize\u003d3\n```\n\n```\nwebgpu_cts_integration_test.py(330): AssertionError:   - EXPECTATION FAILED: D3D compile failed with: error X4028: note that in IEEE strict mode, all values are implicitly marked precise\n    C:\\b\\s\\w\\ir\\out\\Release_x64\\Shader@0x0000365C25E9B660(8,81-160): error X4028: expression has a minimum precision type and cannot be marked precise\n    \n     - While calling [Device].CreateComputePipeline([ComputePipelineDescriptor]).\n    \n        at GPUTest.fail (http://127.0.0.1:49482/third_party/webgpu-cts/src/common/framework/fixture.js:143:36)\n        at http://127.0.0.1:49482/third_party/webgpu-cts/src/webgpu/shader/execution/expression/expression.js:180:19\n        at async Promise.all (index 0)\n        at async run (http://127.0.0.1:49482/third_party/webgpu-cts/src/webgpu/shader/execution/expression/expression.js:185:5)\n        at async RunCaseSpecific.fn (http://127.0.0.1:49482/third_party/webgpu-cts/src/webgpu/shader/execution/expression/call/builtin/quantizeToF16.spec.js:54:5)\n```",
      "revId": "65e62c3c4a8139602b5251c01d24e05ef091a18a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e7fa372_957819fa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2023-03-30T20:58:06Z",
      "side": 1,
      "message": "Looked into this, and it\u0027s because Tint\u0027s HLSL backend uses `min16float` to implement `quantizeToF16`, and apparently this doesn\u0027t play nicely with the IEEE flag. Not sure why yet...",
      "parentUuid": "277de94c_bf9941e7",
      "revId": "65e62c3c4a8139602b5251c01d24e05ef091a18a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec05f848_f481cbb1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002361
      },
      "writtenOn": "2023-03-30T21:34:51Z",
      "side": 1,
      "message": "Okay, FXC doesn\u0027t like mixing min16float with IEEE strictness for some reason. Having said that, I found a proper workaround that actually is more correct than what we\u0027re doing in Tint right now. Currently, the HLSL backend is making use of min16float to turn an f32 into an f16, then it brings it back to f32:\n\n```\nbool GeneratorImpl::EmitQuantizeToF16Call(std::ostream\u0026 out,\n                                          const ast::CallExpression* expr,\n                                          const sem::Builtin* builtin) {\n    // Emulate by casting to min16float and back again.\n    std::string width;\n    if (auto* vec \u003d builtin-\u003eReturnType()-\u003eAs\u003ctype::Vector\u003e()) {\n        width \u003d std::to_string(vec-\u003eWidth());\n    }\n    out \u003c\u003c \"float\" \u003c\u003c width \u003c\u003c \"(min16float\" \u003c\u003c width \u003c\u003c \"(\";\n    if (!EmitExpression(out, expr-\u003eargs[0])) {\n        return false;\n    }\n    out \u003c\u003c \"))\";\n    return true;\n}\n```\n\nThe key line is:\n```\n    out \u003c\u003c \"float\" \u003c\u003c width \u003c\u003c \"(min16float\" \u003c\u003c width \u003c\u003c \"(\";\n```\n\nReading about `min16float`, it\u0027s not actually guaranteed that the driver will convert the result to f16 - indeed that\u0027s why it\u0027s called _min_16float (it can be mininum 16-bits or more). Instead, we can make use of `f32tof16` and `f16tof32` to properly convert the value, so we change the line to:\n\n```\n    out \u003c\u003c \"f16tof32(f32tof16\" \u003c\u003c \"(\";\n```\n\nWith this change, FXC no longer fails to compile, and CTS passes all tests for quantizeToF16.\n\nI\u0027m going to make a CL with this fix in Tint, and land that first. Then we can rebase this CL on top.",
      "parentUuid": "5e7fa372_957819fa",
      "revId": "65e62c3c4a8139602b5251c01d24e05ef091a18a",
      "serverId": "dd02978d-1a8e-36d7-bcc0-a5723e5c0abd"
    }
  ]
}